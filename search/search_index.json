{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Image-Baker","text":"<p>Let's bake an image.</p>"},{"location":"#why-is-it-relevant","title":"Why is it relevant?","text":"<p>When training computer vision models (especially for detection and segmentation), labeling large amounts of data is crucial for better model performance. Often, the process involves multiple cycles of labeling, training, and evaluation. By generating multiple realistic labeled datasets from a single image, the time spent on labeling can be significantly reduced.</p>"},{"location":"#whats-up-with-the-name","title":"What's up with the name?","text":"<p>The concept involves extracting portions of an image (e.g., objects of interest) using tools like polygons or models such as Segment Anything. These extractions are treated as layers, which can then be copied, pasted, and manipulated to create multiple instances of the desired object. By combining these layers step by step, a new labeled image with annotations in JSON format is created. The term \"Baking\" refers to the process of merging these layers into a single cohesive image.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#using-pip","title":"Using PIP","text":"<p>This project is also available in PyPI server.</p> <pre><code>pip install imagebaker\n</code></pre>"},{"location":"#developing","title":"Developing","text":"<p>Please, clone this repository and install it locally:</p> <pre><code>git clone https://github.com/q-viper/image-baker.git \ncd image-baker\npip install -e .\n</code></pre>"},{"location":"#first-run","title":"First Run","text":"<p>Run the following command to launch the GUI:</p> <pre><code>imagebaker\n</code></pre> <p>If the command does not work, try running the example script after cloning the project.:</p> <pre><code>python examples/app.py\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Annotating Images: Load a folder of images and annotate them using bounding boxes or polygons.</li> <li>Model Testing: Define models for detection, segmentation, and prompts (e.g., points or rectangles) by following the base model structure in imagebaker/models/base_model.py. See examples/loaded_models.py for a working example.</li> <li>Layerifying: Crop images based on annotations to create reusable layers. Each cropped image represents a single layer.</li> <li>Baking States: Arrange layers to create image variations by dragging, rotating, adjusting opacity, and more. Save the state using the Save State button or Ctrl + S.</li> <li>Playing States: Replay saved states, export them locally, or use them for further predictions.</li> <li>Exporting States: Export the final annotated JSON and the baked multilayer image.</li> </ul>"},{"location":"#shortcuts","title":"Shortcuts","text":"<ul> <li>Ctrl + C: Copy selected annotation/layer.</li> <li>Ctrl + V: Paste copied annotation/layer in its parent image/layer if it is currently open.</li> <li>Delete: Delete selected annotation/layer.</li> <li>Left Click: Select an annotation/layer on mouse position.</li> <li>Left Click + Drag: Drag a selected annotation/layer.</li> <li>Double Left Click: When using Polygon annotation, completes the polygon.</li> <li>Right Click: Deselect an annotation/layer. While on annotating polygon, undo last point.</li> <li>Ctrl + Mouse Wheel: Zoom In/Out on the mouse position i.e. resizes the viewport.</li> <li>Ctrl + Drag: If done on the background, the viewport is panned.</li> <li>Ctrl + S: Save State on Baker Tab.</li> <li>Ctrl + D: Draw Mode on Baker Tab. Drawing can happen on a selected or main layer.</li> <li>Ctrl + E: Erase Mode on Baker Tab.</li> <li>Wheel: Change size of the drawing pointer.</li> </ul>"},{"location":"#demo","title":"Demo","text":""},{"location":"#demo_1","title":"Demo","text":"<p>To see the tool in action, check out the demo video below:</p> <p></p> <p>Click on the image above to play the video on YouTube.</p>"},{"location":"#contributions","title":"Contributions","text":"<p>Contributions are welcome! </p> <p>Do you find this project to be useful and looking for some features that is not implemented yet? Feel free to open issues or submit pull requests to improve the project.</p>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#application","title":"Application","text":""},{"location":"api-reference/#app-module","title":"App Module","text":""},{"location":"api-reference/#imagebaker.window.app.find_and_import_subclass","title":"<code>find_and_import_subclass(file_path, base_class_name)</code>","text":"<p>Find and import the first subclass of a given base class in a Python file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the Python file to inspect.</p> required <code>base_class_name</code> <code>str</code> <p>The name of the base class to look for subclasses of.</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>The first subclass found, or None if no subclass is found.</p> Source code in <code>imagebaker/window/app.py</code> <pre><code>def find_and_import_subclass(file_path: str, base_class_name: str):\n    \"\"\"\n    Find and import the first subclass of a given base class in a Python file.\n\n    Args:\n        file_path (str): The path to the Python file to inspect.\n        base_class_name (str): The name of the base class to look for subclasses of.\n\n    Returns:\n        type: The first subclass found, or None if no subclass is found.\n    \"\"\"\n    with open(file_path, \"r\") as file:\n        tree = ast.parse(file.read(), filename=file_path)\n\n    for node in ast.walk(tree):\n        if isinstance(node, ast.ClassDef):\n            for base in node.bases:\n                if isinstance(base, ast.Name) and base.id == base_class_name:\n                    # Dynamically import the file and return the class\n                    module_name = Path(file_path).stem\n                    spec = importlib.util.spec_from_file_location(\n                        module_name, file_path\n                    )\n                    module = importlib.util.module_from_spec(spec)\n                    spec.loader.exec_module(module)\n                    return getattr(module, node.name)\n    return None\n</code></pre>"},{"location":"api-reference/#imagebaker.window.app.load_models","title":"<code>load_models(file_path)</code>","text":"<p>Dynamically load the LOADED_MODELS object from the specified file.</p> Source code in <code>imagebaker/window/app.py</code> <pre><code>def load_models(file_path: str):\n    \"\"\"Dynamically load the LOADED_MODELS object from the specified file.\"\"\"\n    try:\n        # Ensure the file path is absolute\n        file_path = Path(file_path).resolve()\n\n        # Execute the file and return its global variables\n        loaded_globals = runpy.run_path(str(file_path))\n    except Exception as e:\n        logger.error(f\"Failed to load models from {file_path}: {e}\")\n        return {}\n\n    # Ensure LOADED_MODELS exists in the loaded context\n    if \"LOADED_MODELS\" not in loaded_globals:\n        logger.warning(f\"No LOADED_MODELS object found in {file_path}.\")\n        return {}\n\n    return loaded_globals.get(\"LOADED_MODELS\", {})\n</code></pre>"},{"location":"api-reference/#imagebaker.window.app.run","title":"<code>run(models_file=typer.Option('loaded_models.py', help='Path to the Python file defining LOADED_MODELS.'), project_dir=typer.Option('.', help='The project directory to use for the application.'), configs_file=typer.Option('imagebaker/core/configs.py', help='The Python file to search for LayerConfig and CanvasConfig subclasses.'))</code>","text":"<p>Run the ImageBaker application.</p> <p>Parameters:</p> Name Type Description Default <code>models_file</code> <code>str</code> <p>Path to the Python file defining LOADED_MODELS.</p> <code>Option('loaded_models.py', help='Path to the Python file defining LOADED_MODELS.')</code> <code>project_dir</code> <code>str</code> <p>The project directory to use for the application.</p> <code>Option('.', help='The project directory to use for the application.')</code> <code>configs_file</code> <code>str</code> <p>The Python file to search for LayerConfig and CanvasConfig subclasses.</p> <code>Option('imagebaker/core/configs.py', help='The Python file to search for LayerConfig and CanvasConfig subclasses.')</code> Source code in <code>imagebaker/window/app.py</code> <pre><code>@app_cli.command()\ndef run(\n    models_file: str = typer.Option(\n        \"loaded_models.py\", help=\"Path to the Python file defining LOADED_MODELS.\"\n    ),\n    project_dir: str = typer.Option(\n        \".\", help=\"The project directory to use for the application.\"\n    ),\n    configs_file: str = typer.Option(\n        \"imagebaker/core/configs.py\",\n        help=\"The Python file to search for LayerConfig and CanvasConfig subclasses.\",\n    ),\n):\n    \"\"\"\n    Run the ImageBaker application.\n\n    Args:\n        models_file (str): Path to the Python file defining LOADED_MODELS.\n        project_dir (str): The project directory to use for the application.\n        configs_file (str): The Python file to search for LayerConfig and CanvasConfig subclasses.\n    \"\"\"\n    models_file_path = Path(models_file)\n    if not models_file_path.is_file():\n        logger.warning(f\"Models file not found: {models_file_path}\")\n        LOADED_MODELS = {None: None}\n    else:\n        LOADED_MODELS = load_models(models_file_path)\n\n    configs_file_path = Path(configs_file)\n    if not configs_file_path.is_file():\n        logger.warning(f\"Configs file not found: {configs_file_path}\")\n        layer_config_class = None\n        canvas_config_class = None\n    else:\n        # Find and import subclasses of LayerConfig and CanvasConfig\n        layer_config_class = find_and_import_subclass(configs_file_path, \"LayerConfig\")\n        canvas_config_class = find_and_import_subclass(\n            configs_file_path, \"CanvasConfig\"\n        )\n\n    # Use the imported subclass if found, or fall back to the default\n    if layer_config_class:\n        logger.info(f\"Using LayerConfig subclass: {layer_config_class.__name__}\")\n        layer_config = layer_config_class()\n    else:\n        logger.info(\"No LayerConfig subclass found. Using default LayerConfig.\")\n        layer_config = LayerConfig(project_dir=project_dir)\n\n    if canvas_config_class:\n        logger.info(f\"Using CanvasConfig subclass: {canvas_config_class.__name__}\")\n        canvas_config = canvas_config_class()\n    else:\n        logger.info(\"No CanvasConfig subclass found. Using default CanvasConfig.\")\n        canvas_config = CanvasConfig(project_dir=project_dir)\n\n    main(layer_config, canvas_config, LOADED_MODELS)\n</code></pre>"},{"location":"api-reference/#tabs","title":"Tabs","text":""},{"location":"api-reference/#layerify-tab","title":"Layerify Tab","text":"<p>               Bases: <code>QWidget</code></p> <p>Layerify Tab implementation</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>class LayerifyTab(QWidget):\n    \"\"\"Layerify Tab implementation\"\"\"\n\n    annotationRemoved = Signal(Annotation)\n    layerAdded = Signal(AnnotableLayer)\n    clearAnnotations = Signal()\n    messageSignal = Signal(str)\n    annotationAdded = Signal(Annotation)\n    annotationUpdated = Signal(Annotation)\n    gotToTab = Signal(int)\n\n    def __init__(\n        self,\n        main_window,\n        config: LayerConfig,\n        canvas_config: CanvasConfig,\n        loaded_models,\n    ):\n        \"\"\"\n        A tab for layerifying annotations and managing multiple layers.\n\n        Args:\n            main_window: The main window instance.\n            config: LayerConfig instance with settings for the tab.\n            canvas_config: CanvasConfig instance with settings for the canvas.\n            loaded_models: Dictionary of loaded models.\n        \"\"\"\n        super().__init__(parent=main_window)\n\n        self.setFocusPolicy(Qt.StrongFocus)\n        self.main_window = main_window\n        self.config = config\n        self.canvas_config = canvas_config\n        self.main_layout = QVBoxLayout(self)\n\n        self.all_models = loaded_models\n        self.current_model = list(self.all_models.values())[0]\n        self.current_label = self.config.default_label.name\n        self.image_entries = []\n        self.curr_image_idx = 0\n        self.processed_images = set()\n        self.annotable_layers: Deque[AnnotableLayer] = deque(\n            maxlen=self.config.deque_maxlen\n        )\n        self.baked_results: Deque[AnnotableLayer] = deque(\n            maxlen=self.config.deque_maxlen\n        )\n        self.layer = None\n        self.init_ui()\n        self._connect_signals()\n\n    def _connect_signals(self):\n        \"\"\"Connect all necessary signals\"\"\"\n        # Connect all layers in the deque to annotation list\n        for layer in self.annotable_layers:\n            # layer.annotationAdded.connect(self.annotation_list.update_list)\n            layer.annotationAdded.connect(self.on_annotation_added)\n            # layer.annotationUpdated.connect(self.annotation_list.update_list)\n            layer.annotationUpdated.connect(self.on_annotation_updated)\n            layer.messageSignal.connect(self.messageSignal)\n            layer.layerSignal.connect(self.add_layer)\n            layer.labelUpdated.connect(self.on_label_update)\n\n        # Connect image list panel signals\n        self.image_list_panel.imageSelected.connect(self.on_image_selected)\n        self.image_list_panel.activeImageEntries.connect(self.update_active_entries)\n\n    def init_ui(self):\n        \"\"\"Initialize the UI components\"\"\"\n        # Create annotation list and image list panel\n        self.annotation_list = AnnotationList(\n            None, parent=self.main_window, max_name_length=self.config.max_name_length\n        )\n        self.image_list_panel = ImageListPanel(\n            self.image_entries,\n            self.processed_images,\n            images_per_page=self.config.deque_maxlen,\n        )\n\n        self.main_window.addDockWidget(Qt.LeftDockWidgetArea, self.image_list_panel)\n\n        # Add multiple layers (canvas) to the main layout\n        for _ in range(self.annotable_layers.maxlen):\n            layer = AnnotableLayer(\n                parent=self.main_window,\n                config=self.config,\n                canvas_config=self.canvas_config,\n            )\n            layer.setVisible(False)  # Initially hide all layers\n            self.annotable_layers.append(layer)\n            self.main_layout.addWidget(layer)\n\n        # Set the annotation list to the first layer by default\n        if self.annotable_layers:\n            self.layer = self.annotable_layers[0]\n            self.layer.set_mode(MouseMode.RECTANGLE)\n            self.annotation_list.layer = self.layer\n\n        self.create_toolbar()\n\n        # Create a dock widget for the toolbar\n        self.toolbar_dock = QDockWidget(\"Tools\", self)\n        self.toolbar_dock.setWidget(self.toolbar)\n        self.toolbar_dock.setFeatures(\n            QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable\n        )\n        self.main_window.addDockWidget(Qt.BottomDockWidgetArea, self.toolbar_dock)\n\n        # Add annotation list to main window's docks\n        self.main_window.addDockWidget(Qt.RightDockWidgetArea, self.annotation_list)\n        self.load_default_images()\n\n    def on_image_selected(self, image_entry: ImageEntry):\n        \"\"\"Handle image selection from the image list panel.\"\"\"\n        logger.info(f\"Image selected: {image_entry}\")\n\n        # Hide all layers first\n        for idx, layer in enumerate(self.annotable_layers):\n            layer.setVisible(False)\n            # logger.info(f\"Layer {idx} hidden.\")\n        current_label = self.layer.current_label\n        current_color = self.layer.current_color\n\n        if not image_entry.is_baked_result:  # Regular image\n            image_path = image_entry.data\n            self.curr_image_idx = self.image_entries.index(image_entry)\n            # convert curr_image_idx to correct index\n            self.curr_image_idx = self.curr_image_idx % len(self.annotable_layers)\n\n            # Make the corresponding layer visible and set the image\n            selected_layer = self.annotable_layers[self.curr_image_idx]\n            selected_layer.setVisible(True)\n            # logger.info(f\"Layer {self.curr_image_idx} made visible for regular image.\")\n            selected_layer.set_image(image_path)  # Set the selected image\n            if self.layer:\n                selected_layer.set_mode(self.layer.mouse_mode)\n            self.layer = selected_layer  # Update the currently selected layer\n\n        else:  # Baked result\n            baked_result_layer = image_entry.data\n            self.curr_image_idx = self.image_entries.index(image_entry)\n\n            # Make the baked result layer visible\n            baked_result_layer.setVisible(True)\n            # logger.info(f\"Layer {self.curr_image_idx} made visible for baked result.\")\n            self.layer = baked_result_layer  # Set the baked result as the current layer\n\n        # Set the current label and color\n        self.layer.current_label = current_label\n        self.layer.current_color = current_color\n        self.annotation_list.layer = self.layer\n        self.annotation_list.update_list()\n\n        self.messageSignal.emit(\n            f\"Showing image {self.curr_image_idx + 1}/{len(self.image_entries)}\"\n        )\n        self.update()\n\n    def load_default_images(self):\n        \"\"\"Load the first set of images as the default.\"\"\"\n        # If no images are loaded, try to load from the assets folder\n        if not self.image_entries:\n            assets_folder = self.config.assets_folder\n            if assets_folder.exists() and assets_folder.is_dir():\n                self._load_images_from_folder(assets_folder)\n\n        # Load images into layers if any are found\n        if self.image_entries:\n            for i, layer in enumerate(self.annotable_layers):\n                if i &lt; len(self.image_entries):\n                    layer.set_image(self.image_entries[i].data)\n                    self.load_layer_annotations(layer)\n                    layer.layer_name = f\"Layer_{i + 1}\"\n                    layer.setVisible(\n                        i == 0\n                    )  # Only the first layer is visible by default\n                    if i == 0:\n                        self.layer = layer  # Set the first layer as the current layer\n                else:\n                    layer.setVisible(False)\n\n            self.messageSignal.emit(f\"Showing image 1/{len(self.image_entries)}\")\n        else:\n            # If no images are found, log a message\n            logger.warning(\"No images found in the assets folder.\")\n            self.messageSignal.emit(\"No images found in the assets folder.\")\n\n        # Update the image list panel\n        self.image_list_panel.update_image_list(self.image_entries)\n        self.update()\n\n    def save_layer_annotations(self, layer: AnnotableLayer):\n        \"\"\"Save annotations for a specific layer\"\"\"\n        if len(layer.annotations) &gt; 0:\n            file_path = layer.file_path\n            file_name = file_path.name\n            save_dir = self.config.cache_dir / f\"{file_name}.json\"\n            Annotation.save_as_json(layer.annotations, save_dir)\n            logger.info(f\"Saved annotations for {layer.layer_name} to {save_dir}\")\n\n    def load_layer_annotations(self, layer: AnnotableLayer):\n        \"\"\"Load annotations for a specific layer\"\"\"\n        if layer.file_path:\n            file_path = layer.file_path\n            file_name = file_path.name\n            load_dir = self.config.cache_dir / f\"{file_name}.json\"\n            if load_dir.exists():\n                layer.annotations = Annotation.load_from_json(load_dir)\n                logger.info(\n                    f\"Loaded annotations for {layer.layer_name} from {load_dir}\"\n                )\n            else:\n                logger.warning(f\"No annotations found for {layer.layer_name}\")\n\n    def update_active_entries(self, image_entries: list[ImageEntry]):\n        \"\"\"Update the active entries in the image list panel.\"\"\"\n        self.curr_image_idx = 0\n        for i, layer in enumerate(self.annotable_layers):\n            self.save_layer_annotations(layer)\n            layer.annotations = []\n\n            if i &lt; len(image_entries):\n                # get index on the self.image_entries\n                idx = self.image_entries.index(image_entries[i])\n                if self.image_entries[idx].is_baked_result:\n                    # if the image is a baked result, set the layer to the baked result\n                    layer = self.image_entries[idx].data\n                    layer.file_path = layer.file_path\n                else:\n                    layer.set_image(self.image_entries[idx].data)\n                self.load_layer_annotations(layer)\n\n                layer.layer_name = f\"Layer_{idx + 1}\"\n                layer.setVisible(i == 0)\n                if i == 0:\n                    self.layer = layer\n            else:\n                layer.setVisible(False)\n        logger.info(\"Updated active entries in image list panel.\")\n\n    def clear_annotations(self):\n        \"\"\"Safely clear all annotations\"\"\"\n        try:\n            # Clear layer annotations\n            self.clearAnnotations.emit()\n            self.messageSignal.emit(\"Annotations cleared\")\n            # clear cache annotation of layer\n            annotation_path = (\n                self.config.cache_dir / f\"{self.layer.file_path.name}.json\"\n            )\n            if annotation_path.exists():\n                os.remove(annotation_path)\n                logger.info(f\"Cleared annotations from {annotation_path}\")\n\n        except Exception as e:\n            logger.error(f\"Clear error: {str(e)}\")\n            self.messageSignal.emit(f\"Error clearing: {str(e)}\")\n\n    def on_annotation_added(self, annotation: Annotation):\n        \"\"\"Handle annotation added event\n\n        Args:\n            annotation (Annotation): The annotation that was added.\n        \"\"\"\n\n        # if annotation.label is not in the predefined labels, add it\n        if annotation.label not in [lbl.name for lbl in self.config.predefined_labels]:\n            logger.info(f\"Label {annotation.label} created.\")\n            self.config.predefined_labels.append(\n                Label(annotation.label, annotation.color)\n            )\n            self.update_label_combo()\n        logger.info(f\"Added annotation: {annotation.label}\")\n        self.messageSignal.emit(f\"Added annotation: {annotation.label}\")\n        self.save_layer_annotations(self.layer)\n\n        # Refresh the annotation list\n        self.annotation_list.update_list()\n\n    def on_annotation_updated(self, annotation: Annotation):\n        \"\"\"\n        A slot to handle the annotation updated signal.\n\n        Args:\n            annotation (Annotation): The updated annotation.\n        \"\"\"\n        # logger.info(f\"Updated annotation: {annotation}\")\n        self.messageSignal.emit(f\"Updated annotation: {annotation.label}\")\n\n        # Refresh the annotation list\n        self.annotation_list.update_list()\n        self.save_layer_annotations(self.layer)\n\n    def update_label_combo(self):\n        \"\"\"\n        Add predefined labels to the label combo box.\n\n        This method is called when a new label is added.\n        \"\"\"\n        self.label_combo.clear()\n        for label in self.config.predefined_labels:\n            pixmap = QPixmap(16, 16)\n            pixmap.fill(label.color)\n            self.label_combo.addItem(QIcon(pixmap), label.name)\n        logger.info(\"Updated label combo box with predefined labels.\")\n        self.label_combo.setCurrentText(self.current_label)\n\n    def on_label_update(self, old_new_label: tuple[str, str]):\n        new_labels = []\n        index = 0\n        for i, label in enumerate(self.config.predefined_labels):\n            if label.name == old_new_label[0]:\n                label.name = old_new_label[1]\n                index = i\n            new_labels.append(label)\n\n        self.config.predefined_labels = new_labels\n        logger.info(f\"Updated label from {old_new_label[0]} to {old_new_label[1]}\")\n        self.messageSignal.emit(\n            f\"Updated label from {old_new_label[0]} to {old_new_label[1]}.\"\n        )\n\n        self.update_label_combo()\n        self.handle_label_change(index=index)\n        self.label_combo.update()\n\n    def load_default_image(self):\n        \"\"\"\n        Load a default image from the assets folder.\n        \"\"\"\n        default_path = self.config.assets_folder / \"desk.png\"\n        if not default_path.exists():\n            default_path, _ = QFileDialog.getOpenFileName()\n            default_path = Path(default_path)\n\n        if default_path.exists():\n            self.layer.set_image(default_path)\n\n    def handle_predict(self):\n        \"\"\"\n        Handle the predict button click event.\n\n        \"\"\"\n        if self.current_model is None:\n            logger.warning(\"No model selected to predict\")\n            self.messageSignal.emit(\"No model selected/or loaded to predict\")\n            return\n        # get image as an numpy array from canvas\n        image = qpixmap_to_numpy(self.layer.image)\n        if image is None:\n            return\n        # get annotations from canvas\n        annotations = [\n            ann\n            for ann in self.layer.annotations\n            if not ann.is_model_generated and ann.visible\n        ]\n\n        if len(annotations) == 0:\n            logger.warning(\"No annotations to predict passing image to model\")\n            self.messageSignal.emit(\"No annotations to predict passing image to model\")\n            # return\n\n        points = []\n        polygons = []\n        rectangles = []\n        label_hints = []\n        for ann in annotations:\n            if ann.points:\n                points.append([[p.x(), p.y()] for p in ann.points])\n            if ann.polygon:\n                polygons.append([[p.x(), p.y()] for p in ann.polygon])\n            if ann.rectangle:\n                rectangles.append(\n                    [\n                        ann.rectangle.x(),\n                        ann.rectangle.y(),\n                        ann.rectangle.x() + ann.rectangle.width(),\n                        ann.rectangle.y() + ann.rectangle.height(),\n                    ]\n                )\n            label_hints.append([0])\n            ann.visible = False\n\n        points = points if len(points) &gt; 0 else None\n        polygons = polygons if len(polygons) &gt; 0 else None\n        rectangles = [rectangles] if len(rectangles) &gt; 0 else None\n        label_hints = label_hints if len(label_hints) &gt; 0 else None\n\n        self.loading_dialog = QProgressDialog(\n            \"Processing annotation...\",\n            \"Cancel\",  # Optional cancel button\n            0,\n            0,\n            self.parentWidget(),  # Or your main window reference\n        )\n        self.loading_dialog.setWindowTitle(\"Please Wait\")\n        self.loading_dialog.setWindowModality(Qt.WindowModal)\n        self.loading_dialog.setCancelButton(None)  # Remove cancel button if not needed\n        self.loading_dialog.show()\n\n        # Force UI update\n        QApplication.processEvents()\n\n        # Setup worker thread\n        self.worker_thread = QThread()\n        self.worker = ModelPredictionWorker(\n            self.current_model, image, points, polygons, rectangles, label_hints\n        )\n        self.worker.moveToThread(self.worker_thread)\n\n        # Connect signals\n        self.worker_thread.started.connect(self.worker.process)\n        self.worker.finished.connect(self.handle_model_result)\n        self.worker.finished.connect(self.worker_thread.quit)\n        self.worker.error.connect(self.handle_model_error)\n\n        # Cleanup connections\n        self.worker.finished.connect(self.worker.deleteLater)\n        self.worker_thread.finished.connect(self.worker_thread.deleteLater)\n        self.worker_thread.finished.connect(self.loading_dialog.close)\n\n        # Start processing\n        self.worker_thread.start()\n\n    def handle_model_result(self, predictions: list[PredictionResult]):\n        \"\"\"\n        A slot to handle the model prediction results.\n\n        Args:\n            predictions (list[PredictionResult]): The list of prediction results.\n        \"\"\"\n        # update canvas with predictions\n        for prediction in predictions:\n            if prediction.class_name not in self.config.predefined_labels:\n                self.config.predefined_labels.append(Label(prediction.class_name))\n                self.update_label_combo()\n            if prediction.rectangle:\n                # make sure the returned rectangle is within the image\n\n                self.layer.annotations.append(\n                    Annotation(\n                        annotation_id=len(self.layer.annotations),\n                        label=prediction.class_name,\n                        color=self.config.get_label_color(prediction.class_name)\n                        or QColor(255, 255, 255),\n                        rectangle=QRectF(*prediction.rectangle),\n                        is_complete=True,\n                        score=prediction.score,\n                        annotator=self.current_model.name,\n                        annotation_time=str(\n                            prediction.annotation_time\n                            if prediction.annotation_time\n                            else \"\"\n                        ),\n                        file_path=self.layer.file_path,\n                    )\n                )\n            elif prediction.polygon is not None:\n\n                self.layer.annotations.append(\n                    Annotation(\n                        annotation_id=len(self.layer.annotations),\n                        label=prediction.class_name,\n                        color=self.config.get_label_color(prediction.class_name)\n                        or QColor(255, 255, 255),\n                        polygon=QPolygonF([QPointF(*p) for p in prediction.polygon]),\n                        is_complete=True,\n                        score=prediction.score,\n                        annotator=self.current_model.name,\n                        annotation_time=str(prediction.annotation_time),\n                        file_path=self.layer.file_path,\n                    )\n                )\n            else:\n                # points as center of canvas\n                x, y = self.layer.width() // 2, self.layer.height() // 2\n                self.layer.annotations.append(\n                    Annotation(\n                        annotation_id=len(self.layer.annotations),\n                        label=prediction.class_name,\n                        color=self.config.get_label_color(prediction.class_name)\n                        or QColor(255, 255, 255),\n                        points=[QPointF(x, y)],\n                        is_complete=True,\n                        score=prediction.score,\n                        annotator=self.current_model.name,\n                        annotation_time=str(prediction.annotation_time),\n                        file_path=self.layer.file_path,\n                    )\n                )\n\n        self.layer.update()\n        self.annotation_list.update_list()\n        self.update_annotation_list()\n\n    def handle_model_change(self, index):\n        \"\"\"\n        Handle the model change event.\n\n        Args:\n            index (int): The index of the selected model.\n        \"\"\"\n        model_name = self.model_combo.currentText()\n        self.current_model = self.all_models[model_name]\n        msg = f\"Model changed to {model_name}\"\n        logger.info(msg)\n        self.messageSignal.emit(msg)\n\n    def handle_model_error(self, error):\n        logger.error(f\"Model error: {error}\")\n        QMessageBox.critical(self, \"Error\", f\"Model error: {error}\")\n        self.loading_dialog.close()\n\n    def save_annotations(self):\n        \"\"\"Save annotations to a JSON file.\"\"\"\n        if not self.layer.annotations:\n            QMessageBox.warning(self, \"Warning\", \"No annotations to save!\")\n            return\n\n        options = QFileDialog.Options()\n        file_name, _ = QFileDialog.getSaveFileName(\n            self, \"Save Annotations\", \"\", \"JSON Files (*.json)\", options=options\n        )\n\n        if file_name:\n            try:\n                Annotation.save_as_json(self.layer.annotations, file_name)\n\n                QMessageBox.information(\n                    self, \"Success\", \"Annotations saved successfully!\"\n                )\n\n            except Exception as e:\n                QMessageBox.critical(\n                    self, \"Error\", f\"Failed to save annotations: {str(e)}\"\n                )\n\n    def load_annotations(self):\n        \"\"\"\n        Load annotations from a JSON file.\n        \"\"\"\n        options = QFileDialog.Options()\n        file_name, _ = QFileDialog.getOpenFileName(\n            self, \"Load Annotations\", \"\", \"JSON Files (*.json)\", options=options\n        )\n\n        if file_name:\n            try:\n                self.layer.annotations = Annotation.load_from_json(file_name)\n                self.layer.update()\n                self.update_annotation_list()\n                QMessageBox.information(\n                    self, \"Success\", \"Annotations loaded successfully!\"\n                )\n\n            except Exception as e:\n                QMessageBox.critical(\n                    self, \"Error\", f\"Failed to load annotations: {str(e)}\"\n                )\n                self.layer.annotations = []\n                self.layer.update()\n\n    def update_annotation_list(self):\n        \"\"\"Update the annotation list with the current annotations.\"\"\"\n        self.annotation_list.update_list()\n\n    def choose_color(self):\n        \"\"\"Choose a color for the current label.\"\"\"\n        current_label = self.label_combo.currentText()\n        label_info = next(\n            (\n                label\n                for label in self.config.predefined_labels\n                if label.name == current_label\n            ),\n            None,\n        )\n\n        if label_info:\n            color = QColorDialog.getColor(label_info.color)\n            if color.isValid():\n                # Update label color\n                label_info.color = color\n                # Update combo box display\n                index = self.label_combo.currentIndex()\n                pixmap = QPixmap(16, 16)\n                pixmap.fill(color)\n                self.label_combo.setItemIcon(index, QIcon(pixmap))\n                # Update canvas color\n                self.layer.current_color = color\n                self.layer.update()\n        for annotation in self.layer.annotations:\n            if annotation.label == current_label:\n                annotation.color = color\n                self.layer.update()\n\n    def add_new_label(self):\n        \"\"\"Add a new label to the predefined labels.\"\"\"\n        name, ok = QInputDialog.getText(self, \"New Label\", \"Enter label name:\")\n        if not ok or not name:\n            return\n\n        # Check for existing label\n        existing_names = [label.name for label in self.config.predefined_labels]\n        if name in existing_names:\n            QMessageBox.warning(self, \"Duplicate\", \"Label name already exists!\")\n            return\n\n        color = QColorDialog.getColor()\n        if not color.isValid():\n            return\n\n        # Add new predefined label\n        self.config.predefined_labels.append(Label(name=name, color=color))\n\n        # Update combo box\n        self.update_label_combo()\n\n        # Select the new label\n        index = self.label_combo.findText(name)\n        self.label_combo.setCurrentIndex(index)\n\n    def handle_label_change(self, index):\n        \"\"\"Handle the label change event.\"\"\"\n        label_info = self.config.predefined_labels[index]\n        self.current_label = label_info.name\n        # sort the labels by putting selected label on top\n        self.config.predefined_labels.remove(label_info)\n        self.config.predefined_labels.insert(0, label_info)\n        # self.update_label_combo()\n\n        self.layer.current_color = label_info.color\n        self.layer.current_label = (\n            self.current_label if self.current_label != \"Custom\" else None\n        )\n        msg = f\"Label changed to {self.current_label}\"\n        self.messageSignal.emit(msg)\n        self.layer.selected_annotation = self.layer._get_selected_annotation()\n        if self.layer.selected_annotation:\n            annotations = []\n            for ann in self.layer.annotations:\n                if ann == self.layer.selected_annotation:\n                    ann.label = label_info.name\n                    ann.color = label_info.color\n                annotations.append(ann)\n\n            self.layer.annotations = annotations\n            self.on_annotation_updated(self.layer.selected_annotation)\n            # disable label change callback\n            self.label_combo.currentIndexChanged.disconnect()\n            self.label_combo.currentIndexChanged.connect(lambda: None)\n            self.update_label_combo()\n            # set it back\n            self.label_combo.currentIndexChanged.connect(self.handle_label_change)\n\n        self.layer.update()\n        self.update()\n\n    def add_layer(self, layer):\n        \"\"\"Add a new layer to the tab.\"\"\"\n        # this layer i.e. canvas will have only one annotation\n        logger.info(f\"AnnotableLayer added: {layer.annotations[0].label}\")\n        self.layerAdded.emit(layer)\n\n        self.layer.update()\n\n    def layerify_all(self):\n        \"\"\"Layerify all annotations in the current layer.\"\"\"\n        if len(self.layer.annotations) == 0:\n            logger.warning(\"No annotations to layerify\")\n            self.messageSignal.emit(\"No annotations to layerify\")\n\n            return\n        logger.info(\"Layerifying all annotations\")\n\n        # else appends already added too\n        self.layer.layerify_annotation(self.layer.annotations)\n\n    def create_toolbar(self):\n        \"\"\"Create Layerify-specific toolbar\"\"\"\n        self.toolbar = QWidget()\n        toolbar_layout = QHBoxLayout(self.toolbar)\n\n        modes = [\n            (\"\ud83d\udccd\", \"Point\", lambda x: self.layer.set_mode(MouseMode.POINT)),\n            (\"\ud83d\udd37\", \"Polygon\", lambda x: self.layer.set_mode(MouseMode.POLYGON)),\n            (\"\ud83d\udd33\", \"Rectangle\", lambda x: self.layer.set_mode(MouseMode.RECTANGLE)),\n            (\"\u23f3\", \"Idle\", lambda x: self.layer.set_mode(MouseMode.IDLE)),\n            (\"\ud83d\udcbe\", \"Annotations\", self.save_annotations),\n            (\"\ud83d\udcc2\", \"Annotations\", self.load_annotations),\n            (\"\ud83d\udd2e\", \"Predict\", self.handle_predict),\n            (\"\ud83c\udfa8\", \"Color\", self.choose_color),\n            (\"\ud83e\uddc5\", \"Layerify All\", self.layerify_all),\n            (\"\ud83c\udff7\ufe0f\", \"Add Label\", self.add_new_label),\n            (\"\ud83d\uddd1\ufe0f\", \"Clear\", self.clear_annotations),\n        ]\n\n        # Folder navigation buttons\n        self.select_folder_btn = QPushButton(\"Select Folder\")\n        self.select_folder_btn.clicked.connect(self.select_folder)\n        toolbar_layout.addWidget(self.select_folder_btn)\n\n        # Add mode buttons\n        for icon, text, mode in modes:\n            btn_txt = icon + text\n            btn = QPushButton(btn_txt)\n            btn.setToolTip(btn_txt)\n            btn.setMaximumWidth(80)\n            if isinstance(mode, MouseMode):\n                btn.clicked.connect(lambda _, m=mode: self.layer.set_mode(m))\n            else:\n                btn.clicked.connect(mode)\n            toolbar_layout.addWidget(btn)\n\n        # Add spacer\n        spacer = QWidget()\n        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\n        toolbar_layout.addWidget(spacer)\n\n        # Label and Model dropdowns\n        self.label_combo = QComboBox()\n        self.label_combo.setStyleSheet(\"QComboBox { min-width: 120px; }\")\n        for label in self.config.predefined_labels:\n            pixmap = QPixmap(16, 16)\n            pixmap.fill(label.color)\n            self.label_combo.addItem(QIcon(pixmap), label.name)\n        self.label_combo.currentIndexChanged.connect(self.handle_label_change)\n        toolbar_layout.addWidget(self.label_combo)\n\n        self.model_combo = QComboBox()\n        self.model_combo.setStyleSheet(\"QComboBox { min-width: 120px; }\")\n        for model_name in self.all_models.keys():\n            self.model_combo.addItem(model_name)\n        self.model_combo.currentIndexChanged.connect(self.handle_model_change)\n        toolbar_layout.addWidget(self.model_combo)\n\n    def _load_images_from_folder(self, folder_path: Path):\n        \"\"\"Load images from a folder and update the image list.\"\"\"\n        self.image_entries = []  # Clear the existing image paths\n\n        if self.config.full_search:\n            image_paths = list(folder_path.rglob(\"*.*\"))\n        else:\n            image_paths = list(folder_path.glob(\"*.*\"))\n\n        for img_path in image_paths:\n            if img_path.suffix.lower() in [\n                \".jpg\",\n                \".jpeg\",\n                \".png\",\n                \".bmp\",\n                \".tiff\",\n            ]:\n                self.image_entries.append(\n                    ImageEntry(is_baked_result=False, data=img_path)\n                )\n\n        # load from bake folder if it exists\n        bake_folder = self.config.bake_dir\n        if bake_folder.exists() and bake_folder.is_dir():\n            for img_path in bake_folder.glob(\"*.*\"):\n                if img_path.suffix.lower() in [\n                    \".jpg\",\n                    \".jpeg\",\n                    \".png\",\n                    \".bmp\",\n                    \".tiff\",\n                ]:\n                    self.image_entries.append(\n                        ImageEntry(is_baked_result=False, data=img_path)\n                    )\n\n    def select_folder(self):\n        \"\"\"Allow the user to select a folder and load images from it.\"\"\"\n        folder_path = QFileDialog.getExistingDirectory(self, \"Select Folder\")\n        if folder_path:\n            folder_path = Path(folder_path)\n\n            self._load_images_from_folder(folder_path)\n\n            self.curr_image_idx = 0  # Reset the current image index\n\n            if len(self.image_entries) &gt; 0:\n                msg = f\"Loaded {len(self.image_entries)} images from {folder_path}\"\n                logger.info(msg)\n                self.messageSignal.emit(msg)\n\n                # Update the image list panel with the new image paths\n                self.image_list_panel.image_entries = self.image_entries\n                self.image_list_panel.update_image_list(self.image_entries)\n\n                # Load the first set of images into the layers\n                self.load_default_images()\n\n            else:\n                QMessageBox.warning(\n                    self,\n                    \"No Images Found\",\n                    \"No valid image files found in the selected folder.\",\n                )\n\n    def __del__(self):\n        logger.warning(f\"Tab {id(self)} deleted\")\n\n    def add_baked_result(self, baking_result: BakingResult):\n        \"\"\"Add a baked result to the baked results list and update the image list.\"\"\"\n        # Create a new layer for the baked result\n        self.layer.setVisible(False)  # Hide the current layer\n        layer = AnnotableLayer(\n            parent=self.main_window,\n            config=self.config,\n            canvas_config=self.canvas_config,\n        )\n        # save it in cache\n        filename = baking_result.filename\n        filepath = self.config.bake_dir / filename.name\n        baking_result.image.save(str(filepath))\n        #\n        Annotation.save_as_json(\n            baking_result.annotations, self.config.cache_dir / f\"{filename.name}.json\"\n        )\n\n        layer.set_image(filepath)\n\n        layer.annotationAdded.connect(self.on_annotation_added)\n        layer.annotationUpdated.connect(self.on_annotation_updated)\n        layer.labelUpdated.connect(self.on_label_update)\n        layer.messageSignal.connect(self.messageSignal)\n        layer.layerSignal.connect(self.add_layer)\n\n        layer.set_image(baking_result.image)  # Set the baked result's image\n        layer.setVisible(True)  # Hide the layer initially\n        self.main_layout.addWidget(layer)  # Add the layer to the layout\n\n        # Add the baked result layer to annotable_layers for proper visibility management\n        self.annotable_layers.append(layer)\n\n        # Add baked result to image_entries\n        baked_result_entry = ImageEntry(is_baked_result=False, data=filepath)\n        self.image_entries.append(baked_result_entry)\n        # baking_result.image.save(str(baking_result.filename))\n        layer.update()\n\n        logger.info(\"A baked result has arrived, adding it to the image list.\")\n\n        # Update the image list panel\n        # find the page index where this layer is\n        page_index = (\n            self.image_entries.index(baked_result_entry) // self.config.deque_maxlen\n        )\n        # set the current page to the page index\n        self.image_list_panel.current_page = page_index\n        self.image_list_panel.update_image_list(self.image_entries)\n        self.image_list_panel.imageSelected.emit(baked_result_entry)\n\n        self.messageSignal.emit(\"Baked result added\")\n        self.gotToTab.emit(0)\n\n    def keyPressEvent(self, event):\n        \"\"\"Handle key press events for setting labels and deleting annotations.\"\"\"\n        key = event.key()\n\n        # Debugging: Log the key press\n        logger.info(f\"Key pressed in LayerifyTab: {key}\")\n\n        # Handle keys 0-9 for setting labels\n        if Qt.Key_0 &lt;= key &lt;= Qt.Key_9:\n            label_index = key - Qt.Key_0  # Convert key to index (0-9)\n            if label_index &lt; len(self.config.predefined_labels):\n                # Set the current label to the corresponding predefined label\n                self.current_label = self.config.predefined_labels[label_index].name\n                self.label_combo.setCurrentIndex(label_index)\n                self.layer.current_label = self.current_label\n                self.layer.update()\n                logger.info(f\"Label set to: {self.current_label}\")\n            else:\n                # Show dialog to add a new label if the index is out of range\n                self.add_new_label()\n\n        # Handle Delete key for removing the selected annotation\n        elif key == Qt.Key_Delete:\n            self.layer.selected_annotation = self.layer._get_selected_annotation()\n            if self.layer and self.layer.selected_annotation:\n\n                self.layer.annotations.remove(self.layer.selected_annotation)\n                self.layer.selected_annotation = None  # Clear the selection\n                self.layer.update()\n                self.annotation_list.update_list()\n                logger.info(\"Selected annotation deleted.\")\n\n        # if clicked q, set the mode to point\n        elif key == Qt.Key_Q:\n            self.layer.set_mode(MouseMode.POINT)\n            logger.info(\"Mouse mode set to POINT.\")\n        # if clicked w, set the mode to polygon\n        elif key == Qt.Key_W:\n            self.layer.set_mode(MouseMode.POLYGON)\n            logger.info(\"Mouse mode set to POLYGON.\")\n        # if clicked e, set the mode to rectangle\n        elif key == Qt.Key_E:\n            self.layer.set_mode(MouseMode.RECTANGLE)\n            logger.info(\"Mouse mode set to RECTANGLE.\")\n\n        # Pass the event to the annotation list if it needs to handle it\n        if self.annotation_list.hasFocus():\n            self.annotation_list.keyPressEvent(event)\n\n        # Pass unhandled events to the base class\n        super().keyPressEvent(event)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.add_baked_result","title":"<code>add_baked_result(baking_result)</code>","text":"<p>Add a baked result to the baked results list and update the image list.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def add_baked_result(self, baking_result: BakingResult):\n    \"\"\"Add a baked result to the baked results list and update the image list.\"\"\"\n    # Create a new layer for the baked result\n    self.layer.setVisible(False)  # Hide the current layer\n    layer = AnnotableLayer(\n        parent=self.main_window,\n        config=self.config,\n        canvas_config=self.canvas_config,\n    )\n    # save it in cache\n    filename = baking_result.filename\n    filepath = self.config.bake_dir / filename.name\n    baking_result.image.save(str(filepath))\n    #\n    Annotation.save_as_json(\n        baking_result.annotations, self.config.cache_dir / f\"{filename.name}.json\"\n    )\n\n    layer.set_image(filepath)\n\n    layer.annotationAdded.connect(self.on_annotation_added)\n    layer.annotationUpdated.connect(self.on_annotation_updated)\n    layer.labelUpdated.connect(self.on_label_update)\n    layer.messageSignal.connect(self.messageSignal)\n    layer.layerSignal.connect(self.add_layer)\n\n    layer.set_image(baking_result.image)  # Set the baked result's image\n    layer.setVisible(True)  # Hide the layer initially\n    self.main_layout.addWidget(layer)  # Add the layer to the layout\n\n    # Add the baked result layer to annotable_layers for proper visibility management\n    self.annotable_layers.append(layer)\n\n    # Add baked result to image_entries\n    baked_result_entry = ImageEntry(is_baked_result=False, data=filepath)\n    self.image_entries.append(baked_result_entry)\n    # baking_result.image.save(str(baking_result.filename))\n    layer.update()\n\n    logger.info(\"A baked result has arrived, adding it to the image list.\")\n\n    # Update the image list panel\n    # find the page index where this layer is\n    page_index = (\n        self.image_entries.index(baked_result_entry) // self.config.deque_maxlen\n    )\n    # set the current page to the page index\n    self.image_list_panel.current_page = page_index\n    self.image_list_panel.update_image_list(self.image_entries)\n    self.image_list_panel.imageSelected.emit(baked_result_entry)\n\n    self.messageSignal.emit(\"Baked result added\")\n    self.gotToTab.emit(0)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.add_layer","title":"<code>add_layer(layer)</code>","text":"<p>Add a new layer to the tab.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def add_layer(self, layer):\n    \"\"\"Add a new layer to the tab.\"\"\"\n    # this layer i.e. canvas will have only one annotation\n    logger.info(f\"AnnotableLayer added: {layer.annotations[0].label}\")\n    self.layerAdded.emit(layer)\n\n    self.layer.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.add_new_label","title":"<code>add_new_label()</code>","text":"<p>Add a new label to the predefined labels.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def add_new_label(self):\n    \"\"\"Add a new label to the predefined labels.\"\"\"\n    name, ok = QInputDialog.getText(self, \"New Label\", \"Enter label name:\")\n    if not ok or not name:\n        return\n\n    # Check for existing label\n    existing_names = [label.name for label in self.config.predefined_labels]\n    if name in existing_names:\n        QMessageBox.warning(self, \"Duplicate\", \"Label name already exists!\")\n        return\n\n    color = QColorDialog.getColor()\n    if not color.isValid():\n        return\n\n    # Add new predefined label\n    self.config.predefined_labels.append(Label(name=name, color=color))\n\n    # Update combo box\n    self.update_label_combo()\n\n    # Select the new label\n    index = self.label_combo.findText(name)\n    self.label_combo.setCurrentIndex(index)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.choose_color","title":"<code>choose_color()</code>","text":"<p>Choose a color for the current label.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def choose_color(self):\n    \"\"\"Choose a color for the current label.\"\"\"\n    current_label = self.label_combo.currentText()\n    label_info = next(\n        (\n            label\n            for label in self.config.predefined_labels\n            if label.name == current_label\n        ),\n        None,\n    )\n\n    if label_info:\n        color = QColorDialog.getColor(label_info.color)\n        if color.isValid():\n            # Update label color\n            label_info.color = color\n            # Update combo box display\n            index = self.label_combo.currentIndex()\n            pixmap = QPixmap(16, 16)\n            pixmap.fill(color)\n            self.label_combo.setItemIcon(index, QIcon(pixmap))\n            # Update canvas color\n            self.layer.current_color = color\n            self.layer.update()\n    for annotation in self.layer.annotations:\n        if annotation.label == current_label:\n            annotation.color = color\n            self.layer.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.clear_annotations","title":"<code>clear_annotations()</code>","text":"<p>Safely clear all annotations</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def clear_annotations(self):\n    \"\"\"Safely clear all annotations\"\"\"\n    try:\n        # Clear layer annotations\n        self.clearAnnotations.emit()\n        self.messageSignal.emit(\"Annotations cleared\")\n        # clear cache annotation of layer\n        annotation_path = (\n            self.config.cache_dir / f\"{self.layer.file_path.name}.json\"\n        )\n        if annotation_path.exists():\n            os.remove(annotation_path)\n            logger.info(f\"Cleared annotations from {annotation_path}\")\n\n    except Exception as e:\n        logger.error(f\"Clear error: {str(e)}\")\n        self.messageSignal.emit(f\"Error clearing: {str(e)}\")\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.create_toolbar","title":"<code>create_toolbar()</code>","text":"<p>Create Layerify-specific toolbar</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def create_toolbar(self):\n    \"\"\"Create Layerify-specific toolbar\"\"\"\n    self.toolbar = QWidget()\n    toolbar_layout = QHBoxLayout(self.toolbar)\n\n    modes = [\n        (\"\ud83d\udccd\", \"Point\", lambda x: self.layer.set_mode(MouseMode.POINT)),\n        (\"\ud83d\udd37\", \"Polygon\", lambda x: self.layer.set_mode(MouseMode.POLYGON)),\n        (\"\ud83d\udd33\", \"Rectangle\", lambda x: self.layer.set_mode(MouseMode.RECTANGLE)),\n        (\"\u23f3\", \"Idle\", lambda x: self.layer.set_mode(MouseMode.IDLE)),\n        (\"\ud83d\udcbe\", \"Annotations\", self.save_annotations),\n        (\"\ud83d\udcc2\", \"Annotations\", self.load_annotations),\n        (\"\ud83d\udd2e\", \"Predict\", self.handle_predict),\n        (\"\ud83c\udfa8\", \"Color\", self.choose_color),\n        (\"\ud83e\uddc5\", \"Layerify All\", self.layerify_all),\n        (\"\ud83c\udff7\ufe0f\", \"Add Label\", self.add_new_label),\n        (\"\ud83d\uddd1\ufe0f\", \"Clear\", self.clear_annotations),\n    ]\n\n    # Folder navigation buttons\n    self.select_folder_btn = QPushButton(\"Select Folder\")\n    self.select_folder_btn.clicked.connect(self.select_folder)\n    toolbar_layout.addWidget(self.select_folder_btn)\n\n    # Add mode buttons\n    for icon, text, mode in modes:\n        btn_txt = icon + text\n        btn = QPushButton(btn_txt)\n        btn.setToolTip(btn_txt)\n        btn.setMaximumWidth(80)\n        if isinstance(mode, MouseMode):\n            btn.clicked.connect(lambda _, m=mode: self.layer.set_mode(m))\n        else:\n            btn.clicked.connect(mode)\n        toolbar_layout.addWidget(btn)\n\n    # Add spacer\n    spacer = QWidget()\n    spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\n    toolbar_layout.addWidget(spacer)\n\n    # Label and Model dropdowns\n    self.label_combo = QComboBox()\n    self.label_combo.setStyleSheet(\"QComboBox { min-width: 120px; }\")\n    for label in self.config.predefined_labels:\n        pixmap = QPixmap(16, 16)\n        pixmap.fill(label.color)\n        self.label_combo.addItem(QIcon(pixmap), label.name)\n    self.label_combo.currentIndexChanged.connect(self.handle_label_change)\n    toolbar_layout.addWidget(self.label_combo)\n\n    self.model_combo = QComboBox()\n    self.model_combo.setStyleSheet(\"QComboBox { min-width: 120px; }\")\n    for model_name in self.all_models.keys():\n        self.model_combo.addItem(model_name)\n    self.model_combo.currentIndexChanged.connect(self.handle_model_change)\n    toolbar_layout.addWidget(self.model_combo)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.handle_label_change","title":"<code>handle_label_change(index)</code>","text":"<p>Handle the label change event.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def handle_label_change(self, index):\n    \"\"\"Handle the label change event.\"\"\"\n    label_info = self.config.predefined_labels[index]\n    self.current_label = label_info.name\n    # sort the labels by putting selected label on top\n    self.config.predefined_labels.remove(label_info)\n    self.config.predefined_labels.insert(0, label_info)\n    # self.update_label_combo()\n\n    self.layer.current_color = label_info.color\n    self.layer.current_label = (\n        self.current_label if self.current_label != \"Custom\" else None\n    )\n    msg = f\"Label changed to {self.current_label}\"\n    self.messageSignal.emit(msg)\n    self.layer.selected_annotation = self.layer._get_selected_annotation()\n    if self.layer.selected_annotation:\n        annotations = []\n        for ann in self.layer.annotations:\n            if ann == self.layer.selected_annotation:\n                ann.label = label_info.name\n                ann.color = label_info.color\n            annotations.append(ann)\n\n        self.layer.annotations = annotations\n        self.on_annotation_updated(self.layer.selected_annotation)\n        # disable label change callback\n        self.label_combo.currentIndexChanged.disconnect()\n        self.label_combo.currentIndexChanged.connect(lambda: None)\n        self.update_label_combo()\n        # set it back\n        self.label_combo.currentIndexChanged.connect(self.handle_label_change)\n\n    self.layer.update()\n    self.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.handle_model_change","title":"<code>handle_model_change(index)</code>","text":"<p>Handle the model change event.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the selected model.</p> required Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def handle_model_change(self, index):\n    \"\"\"\n    Handle the model change event.\n\n    Args:\n        index (int): The index of the selected model.\n    \"\"\"\n    model_name = self.model_combo.currentText()\n    self.current_model = self.all_models[model_name]\n    msg = f\"Model changed to {model_name}\"\n    logger.info(msg)\n    self.messageSignal.emit(msg)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.handle_model_result","title":"<code>handle_model_result(predictions)</code>","text":"<p>A slot to handle the model prediction results.</p> <p>Parameters:</p> Name Type Description Default <code>predictions</code> <code>list[PredictionResult]</code> <p>The list of prediction results.</p> required Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def handle_model_result(self, predictions: list[PredictionResult]):\n    \"\"\"\n    A slot to handle the model prediction results.\n\n    Args:\n        predictions (list[PredictionResult]): The list of prediction results.\n    \"\"\"\n    # update canvas with predictions\n    for prediction in predictions:\n        if prediction.class_name not in self.config.predefined_labels:\n            self.config.predefined_labels.append(Label(prediction.class_name))\n            self.update_label_combo()\n        if prediction.rectangle:\n            # make sure the returned rectangle is within the image\n\n            self.layer.annotations.append(\n                Annotation(\n                    annotation_id=len(self.layer.annotations),\n                    label=prediction.class_name,\n                    color=self.config.get_label_color(prediction.class_name)\n                    or QColor(255, 255, 255),\n                    rectangle=QRectF(*prediction.rectangle),\n                    is_complete=True,\n                    score=prediction.score,\n                    annotator=self.current_model.name,\n                    annotation_time=str(\n                        prediction.annotation_time\n                        if prediction.annotation_time\n                        else \"\"\n                    ),\n                    file_path=self.layer.file_path,\n                )\n            )\n        elif prediction.polygon is not None:\n\n            self.layer.annotations.append(\n                Annotation(\n                    annotation_id=len(self.layer.annotations),\n                    label=prediction.class_name,\n                    color=self.config.get_label_color(prediction.class_name)\n                    or QColor(255, 255, 255),\n                    polygon=QPolygonF([QPointF(*p) for p in prediction.polygon]),\n                    is_complete=True,\n                    score=prediction.score,\n                    annotator=self.current_model.name,\n                    annotation_time=str(prediction.annotation_time),\n                    file_path=self.layer.file_path,\n                )\n            )\n        else:\n            # points as center of canvas\n            x, y = self.layer.width() // 2, self.layer.height() // 2\n            self.layer.annotations.append(\n                Annotation(\n                    annotation_id=len(self.layer.annotations),\n                    label=prediction.class_name,\n                    color=self.config.get_label_color(prediction.class_name)\n                    or QColor(255, 255, 255),\n                    points=[QPointF(x, y)],\n                    is_complete=True,\n                    score=prediction.score,\n                    annotator=self.current_model.name,\n                    annotation_time=str(prediction.annotation_time),\n                    file_path=self.layer.file_path,\n                )\n            )\n\n    self.layer.update()\n    self.annotation_list.update_list()\n    self.update_annotation_list()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.handle_predict","title":"<code>handle_predict()</code>","text":"<p>Handle the predict button click event.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def handle_predict(self):\n    \"\"\"\n    Handle the predict button click event.\n\n    \"\"\"\n    if self.current_model is None:\n        logger.warning(\"No model selected to predict\")\n        self.messageSignal.emit(\"No model selected/or loaded to predict\")\n        return\n    # get image as an numpy array from canvas\n    image = qpixmap_to_numpy(self.layer.image)\n    if image is None:\n        return\n    # get annotations from canvas\n    annotations = [\n        ann\n        for ann in self.layer.annotations\n        if not ann.is_model_generated and ann.visible\n    ]\n\n    if len(annotations) == 0:\n        logger.warning(\"No annotations to predict passing image to model\")\n        self.messageSignal.emit(\"No annotations to predict passing image to model\")\n        # return\n\n    points = []\n    polygons = []\n    rectangles = []\n    label_hints = []\n    for ann in annotations:\n        if ann.points:\n            points.append([[p.x(), p.y()] for p in ann.points])\n        if ann.polygon:\n            polygons.append([[p.x(), p.y()] for p in ann.polygon])\n        if ann.rectangle:\n            rectangles.append(\n                [\n                    ann.rectangle.x(),\n                    ann.rectangle.y(),\n                    ann.rectangle.x() + ann.rectangle.width(),\n                    ann.rectangle.y() + ann.rectangle.height(),\n                ]\n            )\n        label_hints.append([0])\n        ann.visible = False\n\n    points = points if len(points) &gt; 0 else None\n    polygons = polygons if len(polygons) &gt; 0 else None\n    rectangles = [rectangles] if len(rectangles) &gt; 0 else None\n    label_hints = label_hints if len(label_hints) &gt; 0 else None\n\n    self.loading_dialog = QProgressDialog(\n        \"Processing annotation...\",\n        \"Cancel\",  # Optional cancel button\n        0,\n        0,\n        self.parentWidget(),  # Or your main window reference\n    )\n    self.loading_dialog.setWindowTitle(\"Please Wait\")\n    self.loading_dialog.setWindowModality(Qt.WindowModal)\n    self.loading_dialog.setCancelButton(None)  # Remove cancel button if not needed\n    self.loading_dialog.show()\n\n    # Force UI update\n    QApplication.processEvents()\n\n    # Setup worker thread\n    self.worker_thread = QThread()\n    self.worker = ModelPredictionWorker(\n        self.current_model, image, points, polygons, rectangles, label_hints\n    )\n    self.worker.moveToThread(self.worker_thread)\n\n    # Connect signals\n    self.worker_thread.started.connect(self.worker.process)\n    self.worker.finished.connect(self.handle_model_result)\n    self.worker.finished.connect(self.worker_thread.quit)\n    self.worker.error.connect(self.handle_model_error)\n\n    # Cleanup connections\n    self.worker.finished.connect(self.worker.deleteLater)\n    self.worker_thread.finished.connect(self.worker_thread.deleteLater)\n    self.worker_thread.finished.connect(self.loading_dialog.close)\n\n    # Start processing\n    self.worker_thread.start()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.init_ui","title":"<code>init_ui()</code>","text":"<p>Initialize the UI components</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def init_ui(self):\n    \"\"\"Initialize the UI components\"\"\"\n    # Create annotation list and image list panel\n    self.annotation_list = AnnotationList(\n        None, parent=self.main_window, max_name_length=self.config.max_name_length\n    )\n    self.image_list_panel = ImageListPanel(\n        self.image_entries,\n        self.processed_images,\n        images_per_page=self.config.deque_maxlen,\n    )\n\n    self.main_window.addDockWidget(Qt.LeftDockWidgetArea, self.image_list_panel)\n\n    # Add multiple layers (canvas) to the main layout\n    for _ in range(self.annotable_layers.maxlen):\n        layer = AnnotableLayer(\n            parent=self.main_window,\n            config=self.config,\n            canvas_config=self.canvas_config,\n        )\n        layer.setVisible(False)  # Initially hide all layers\n        self.annotable_layers.append(layer)\n        self.main_layout.addWidget(layer)\n\n    # Set the annotation list to the first layer by default\n    if self.annotable_layers:\n        self.layer = self.annotable_layers[0]\n        self.layer.set_mode(MouseMode.RECTANGLE)\n        self.annotation_list.layer = self.layer\n\n    self.create_toolbar()\n\n    # Create a dock widget for the toolbar\n    self.toolbar_dock = QDockWidget(\"Tools\", self)\n    self.toolbar_dock.setWidget(self.toolbar)\n    self.toolbar_dock.setFeatures(\n        QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable\n    )\n    self.main_window.addDockWidget(Qt.BottomDockWidgetArea, self.toolbar_dock)\n\n    # Add annotation list to main window's docks\n    self.main_window.addDockWidget(Qt.RightDockWidgetArea, self.annotation_list)\n    self.load_default_images()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.keyPressEvent","title":"<code>keyPressEvent(event)</code>","text":"<p>Handle key press events for setting labels and deleting annotations.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def keyPressEvent(self, event):\n    \"\"\"Handle key press events for setting labels and deleting annotations.\"\"\"\n    key = event.key()\n\n    # Debugging: Log the key press\n    logger.info(f\"Key pressed in LayerifyTab: {key}\")\n\n    # Handle keys 0-9 for setting labels\n    if Qt.Key_0 &lt;= key &lt;= Qt.Key_9:\n        label_index = key - Qt.Key_0  # Convert key to index (0-9)\n        if label_index &lt; len(self.config.predefined_labels):\n            # Set the current label to the corresponding predefined label\n            self.current_label = self.config.predefined_labels[label_index].name\n            self.label_combo.setCurrentIndex(label_index)\n            self.layer.current_label = self.current_label\n            self.layer.update()\n            logger.info(f\"Label set to: {self.current_label}\")\n        else:\n            # Show dialog to add a new label if the index is out of range\n            self.add_new_label()\n\n    # Handle Delete key for removing the selected annotation\n    elif key == Qt.Key_Delete:\n        self.layer.selected_annotation = self.layer._get_selected_annotation()\n        if self.layer and self.layer.selected_annotation:\n\n            self.layer.annotations.remove(self.layer.selected_annotation)\n            self.layer.selected_annotation = None  # Clear the selection\n            self.layer.update()\n            self.annotation_list.update_list()\n            logger.info(\"Selected annotation deleted.\")\n\n    # if clicked q, set the mode to point\n    elif key == Qt.Key_Q:\n        self.layer.set_mode(MouseMode.POINT)\n        logger.info(\"Mouse mode set to POINT.\")\n    # if clicked w, set the mode to polygon\n    elif key == Qt.Key_W:\n        self.layer.set_mode(MouseMode.POLYGON)\n        logger.info(\"Mouse mode set to POLYGON.\")\n    # if clicked e, set the mode to rectangle\n    elif key == Qt.Key_E:\n        self.layer.set_mode(MouseMode.RECTANGLE)\n        logger.info(\"Mouse mode set to RECTANGLE.\")\n\n    # Pass the event to the annotation list if it needs to handle it\n    if self.annotation_list.hasFocus():\n        self.annotation_list.keyPressEvent(event)\n\n    # Pass unhandled events to the base class\n    super().keyPressEvent(event)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.layerify_all","title":"<code>layerify_all()</code>","text":"<p>Layerify all annotations in the current layer.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def layerify_all(self):\n    \"\"\"Layerify all annotations in the current layer.\"\"\"\n    if len(self.layer.annotations) == 0:\n        logger.warning(\"No annotations to layerify\")\n        self.messageSignal.emit(\"No annotations to layerify\")\n\n        return\n    logger.info(\"Layerifying all annotations\")\n\n    # else appends already added too\n    self.layer.layerify_annotation(self.layer.annotations)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.load_annotations","title":"<code>load_annotations()</code>","text":"<p>Load annotations from a JSON file.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def load_annotations(self):\n    \"\"\"\n    Load annotations from a JSON file.\n    \"\"\"\n    options = QFileDialog.Options()\n    file_name, _ = QFileDialog.getOpenFileName(\n        self, \"Load Annotations\", \"\", \"JSON Files (*.json)\", options=options\n    )\n\n    if file_name:\n        try:\n            self.layer.annotations = Annotation.load_from_json(file_name)\n            self.layer.update()\n            self.update_annotation_list()\n            QMessageBox.information(\n                self, \"Success\", \"Annotations loaded successfully!\"\n            )\n\n        except Exception as e:\n            QMessageBox.critical(\n                self, \"Error\", f\"Failed to load annotations: {str(e)}\"\n            )\n            self.layer.annotations = []\n            self.layer.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.load_default_image","title":"<code>load_default_image()</code>","text":"<p>Load a default image from the assets folder.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def load_default_image(self):\n    \"\"\"\n    Load a default image from the assets folder.\n    \"\"\"\n    default_path = self.config.assets_folder / \"desk.png\"\n    if not default_path.exists():\n        default_path, _ = QFileDialog.getOpenFileName()\n        default_path = Path(default_path)\n\n    if default_path.exists():\n        self.layer.set_image(default_path)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.load_default_images","title":"<code>load_default_images()</code>","text":"<p>Load the first set of images as the default.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def load_default_images(self):\n    \"\"\"Load the first set of images as the default.\"\"\"\n    # If no images are loaded, try to load from the assets folder\n    if not self.image_entries:\n        assets_folder = self.config.assets_folder\n        if assets_folder.exists() and assets_folder.is_dir():\n            self._load_images_from_folder(assets_folder)\n\n    # Load images into layers if any are found\n    if self.image_entries:\n        for i, layer in enumerate(self.annotable_layers):\n            if i &lt; len(self.image_entries):\n                layer.set_image(self.image_entries[i].data)\n                self.load_layer_annotations(layer)\n                layer.layer_name = f\"Layer_{i + 1}\"\n                layer.setVisible(\n                    i == 0\n                )  # Only the first layer is visible by default\n                if i == 0:\n                    self.layer = layer  # Set the first layer as the current layer\n            else:\n                layer.setVisible(False)\n\n        self.messageSignal.emit(f\"Showing image 1/{len(self.image_entries)}\")\n    else:\n        # If no images are found, log a message\n        logger.warning(\"No images found in the assets folder.\")\n        self.messageSignal.emit(\"No images found in the assets folder.\")\n\n    # Update the image list panel\n    self.image_list_panel.update_image_list(self.image_entries)\n    self.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.load_layer_annotations","title":"<code>load_layer_annotations(layer)</code>","text":"<p>Load annotations for a specific layer</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def load_layer_annotations(self, layer: AnnotableLayer):\n    \"\"\"Load annotations for a specific layer\"\"\"\n    if layer.file_path:\n        file_path = layer.file_path\n        file_name = file_path.name\n        load_dir = self.config.cache_dir / f\"{file_name}.json\"\n        if load_dir.exists():\n            layer.annotations = Annotation.load_from_json(load_dir)\n            logger.info(\n                f\"Loaded annotations for {layer.layer_name} from {load_dir}\"\n            )\n        else:\n            logger.warning(f\"No annotations found for {layer.layer_name}\")\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.on_annotation_added","title":"<code>on_annotation_added(annotation)</code>","text":"<p>Handle annotation added event</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>The annotation that was added.</p> required Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def on_annotation_added(self, annotation: Annotation):\n    \"\"\"Handle annotation added event\n\n    Args:\n        annotation (Annotation): The annotation that was added.\n    \"\"\"\n\n    # if annotation.label is not in the predefined labels, add it\n    if annotation.label not in [lbl.name for lbl in self.config.predefined_labels]:\n        logger.info(f\"Label {annotation.label} created.\")\n        self.config.predefined_labels.append(\n            Label(annotation.label, annotation.color)\n        )\n        self.update_label_combo()\n    logger.info(f\"Added annotation: {annotation.label}\")\n    self.messageSignal.emit(f\"Added annotation: {annotation.label}\")\n    self.save_layer_annotations(self.layer)\n\n    # Refresh the annotation list\n    self.annotation_list.update_list()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.on_annotation_updated","title":"<code>on_annotation_updated(annotation)</code>","text":"<p>A slot to handle the annotation updated signal.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Annotation</code> <p>The updated annotation.</p> required Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def on_annotation_updated(self, annotation: Annotation):\n    \"\"\"\n    A slot to handle the annotation updated signal.\n\n    Args:\n        annotation (Annotation): The updated annotation.\n    \"\"\"\n    # logger.info(f\"Updated annotation: {annotation}\")\n    self.messageSignal.emit(f\"Updated annotation: {annotation.label}\")\n\n    # Refresh the annotation list\n    self.annotation_list.update_list()\n    self.save_layer_annotations(self.layer)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.on_image_selected","title":"<code>on_image_selected(image_entry)</code>","text":"<p>Handle image selection from the image list panel.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def on_image_selected(self, image_entry: ImageEntry):\n    \"\"\"Handle image selection from the image list panel.\"\"\"\n    logger.info(f\"Image selected: {image_entry}\")\n\n    # Hide all layers first\n    for idx, layer in enumerate(self.annotable_layers):\n        layer.setVisible(False)\n        # logger.info(f\"Layer {idx} hidden.\")\n    current_label = self.layer.current_label\n    current_color = self.layer.current_color\n\n    if not image_entry.is_baked_result:  # Regular image\n        image_path = image_entry.data\n        self.curr_image_idx = self.image_entries.index(image_entry)\n        # convert curr_image_idx to correct index\n        self.curr_image_idx = self.curr_image_idx % len(self.annotable_layers)\n\n        # Make the corresponding layer visible and set the image\n        selected_layer = self.annotable_layers[self.curr_image_idx]\n        selected_layer.setVisible(True)\n        # logger.info(f\"Layer {self.curr_image_idx} made visible for regular image.\")\n        selected_layer.set_image(image_path)  # Set the selected image\n        if self.layer:\n            selected_layer.set_mode(self.layer.mouse_mode)\n        self.layer = selected_layer  # Update the currently selected layer\n\n    else:  # Baked result\n        baked_result_layer = image_entry.data\n        self.curr_image_idx = self.image_entries.index(image_entry)\n\n        # Make the baked result layer visible\n        baked_result_layer.setVisible(True)\n        # logger.info(f\"Layer {self.curr_image_idx} made visible for baked result.\")\n        self.layer = baked_result_layer  # Set the baked result as the current layer\n\n    # Set the current label and color\n    self.layer.current_label = current_label\n    self.layer.current_color = current_color\n    self.annotation_list.layer = self.layer\n    self.annotation_list.update_list()\n\n    self.messageSignal.emit(\n        f\"Showing image {self.curr_image_idx + 1}/{len(self.image_entries)}\"\n    )\n    self.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.save_annotations","title":"<code>save_annotations()</code>","text":"<p>Save annotations to a JSON file.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def save_annotations(self):\n    \"\"\"Save annotations to a JSON file.\"\"\"\n    if not self.layer.annotations:\n        QMessageBox.warning(self, \"Warning\", \"No annotations to save!\")\n        return\n\n    options = QFileDialog.Options()\n    file_name, _ = QFileDialog.getSaveFileName(\n        self, \"Save Annotations\", \"\", \"JSON Files (*.json)\", options=options\n    )\n\n    if file_name:\n        try:\n            Annotation.save_as_json(self.layer.annotations, file_name)\n\n            QMessageBox.information(\n                self, \"Success\", \"Annotations saved successfully!\"\n            )\n\n        except Exception as e:\n            QMessageBox.critical(\n                self, \"Error\", f\"Failed to save annotations: {str(e)}\"\n            )\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.save_layer_annotations","title":"<code>save_layer_annotations(layer)</code>","text":"<p>Save annotations for a specific layer</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def save_layer_annotations(self, layer: AnnotableLayer):\n    \"\"\"Save annotations for a specific layer\"\"\"\n    if len(layer.annotations) &gt; 0:\n        file_path = layer.file_path\n        file_name = file_path.name\n        save_dir = self.config.cache_dir / f\"{file_name}.json\"\n        Annotation.save_as_json(layer.annotations, save_dir)\n        logger.info(f\"Saved annotations for {layer.layer_name} to {save_dir}\")\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.select_folder","title":"<code>select_folder()</code>","text":"<p>Allow the user to select a folder and load images from it.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def select_folder(self):\n    \"\"\"Allow the user to select a folder and load images from it.\"\"\"\n    folder_path = QFileDialog.getExistingDirectory(self, \"Select Folder\")\n    if folder_path:\n        folder_path = Path(folder_path)\n\n        self._load_images_from_folder(folder_path)\n\n        self.curr_image_idx = 0  # Reset the current image index\n\n        if len(self.image_entries) &gt; 0:\n            msg = f\"Loaded {len(self.image_entries)} images from {folder_path}\"\n            logger.info(msg)\n            self.messageSignal.emit(msg)\n\n            # Update the image list panel with the new image paths\n            self.image_list_panel.image_entries = self.image_entries\n            self.image_list_panel.update_image_list(self.image_entries)\n\n            # Load the first set of images into the layers\n            self.load_default_images()\n\n        else:\n            QMessageBox.warning(\n                self,\n                \"No Images Found\",\n                \"No valid image files found in the selected folder.\",\n            )\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.update_active_entries","title":"<code>update_active_entries(image_entries)</code>","text":"<p>Update the active entries in the image list panel.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def update_active_entries(self, image_entries: list[ImageEntry]):\n    \"\"\"Update the active entries in the image list panel.\"\"\"\n    self.curr_image_idx = 0\n    for i, layer in enumerate(self.annotable_layers):\n        self.save_layer_annotations(layer)\n        layer.annotations = []\n\n        if i &lt; len(image_entries):\n            # get index on the self.image_entries\n            idx = self.image_entries.index(image_entries[i])\n            if self.image_entries[idx].is_baked_result:\n                # if the image is a baked result, set the layer to the baked result\n                layer = self.image_entries[idx].data\n                layer.file_path = layer.file_path\n            else:\n                layer.set_image(self.image_entries[idx].data)\n            self.load_layer_annotations(layer)\n\n            layer.layer_name = f\"Layer_{idx + 1}\"\n            layer.setVisible(i == 0)\n            if i == 0:\n                self.layer = layer\n        else:\n            layer.setVisible(False)\n    logger.info(\"Updated active entries in image list panel.\")\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.update_annotation_list","title":"<code>update_annotation_list()</code>","text":"<p>Update the annotation list with the current annotations.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def update_annotation_list(self):\n    \"\"\"Update the annotation list with the current annotations.\"\"\"\n    self.annotation_list.update_list()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.layerify_tab.LayerifyTab.update_label_combo","title":"<code>update_label_combo()</code>","text":"<p>Add predefined labels to the label combo box.</p> <p>This method is called when a new label is added.</p> Source code in <code>imagebaker/tabs/layerify_tab.py</code> <pre><code>def update_label_combo(self):\n    \"\"\"\n    Add predefined labels to the label combo box.\n\n    This method is called when a new label is added.\n    \"\"\"\n    self.label_combo.clear()\n    for label in self.config.predefined_labels:\n        pixmap = QPixmap(16, 16)\n        pixmap.fill(label.color)\n        self.label_combo.addItem(QIcon(pixmap), label.name)\n    logger.info(\"Updated label combo box with predefined labels.\")\n    self.label_combo.setCurrentText(self.current_label)\n</code></pre>"},{"location":"api-reference/#baker-tab","title":"Baker Tab","text":"<p>               Bases: <code>QWidget</code></p> <p>Baker Tab implementation</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>class BakerTab(QWidget):\n    \"\"\"Baker Tab implementation\"\"\"\n\n    messageSignal = Signal(str)\n    bakingResult = Signal(BakingResult)\n\n    def __init__(self, main_window, config: CanvasConfig):\n        \"\"\"Initialize the Baker Tab.\"\"\"\n        super().__init__(main_window)\n        self.main_window = main_window\n        self.config = config\n        self.toolbar = None\n        self.main_layout = QVBoxLayout(self)\n\n        # Deque to store multiple CanvasLayer objects with a fixed size\n        self.canvases = deque(maxlen=self.config.deque_maxlen)\n\n        # Currently selected canvas\n        self.current_canvas = None\n\n        self.init_ui()\n\n    def init_ui(self):\n        \"\"\"Initialize the UI components.\"\"\"\n        # Create toolbar\n        self.create_toolbar()\n\n        # Create a single canvas for now\n        self.current_canvas = CanvasLayer(parent=self.main_window, config=self.config)\n        self.current_canvas.setVisible(True)  # Initially hide all canvases\n        self.canvases.append(self.current_canvas)\n        self.main_layout.addWidget(self.current_canvas)\n\n        # Create and add CanvasList\n        self.canvas_list = CanvasList(self.canvases, parent=self.main_window)\n        self.main_window.addDockWidget(Qt.LeftDockWidgetArea, self.canvas_list)\n\n        # Create and add LayerList\n        self.layer_settings = LayerSettings(\n            parent=self.main_window,\n            max_xpos=self.config.max_xpos,\n            max_ypos=self.config.max_ypos,\n            max_scale=self.config.max_scale,\n            max_edge_width=self.config.max_edge_width,\n        )\n        self.layer_list = LayerList(\n            canvas=self.current_canvas,\n            parent=self.main_window,\n            layer_settings=self.layer_settings,\n        )\n        self.layer_settings.setVisible(False)\n        self.main_window.addDockWidget(Qt.RightDockWidgetArea, self.layer_list)\n        self.main_window.addDockWidget(Qt.RightDockWidgetArea, self.layer_settings)\n\n        # Create a dock widget for the toolbar\n        self.toolbar_dock = QDockWidget(\"Tools\", self)\n        self.toolbar_dock.setWidget(self.toolbar)\n        self.toolbar_dock.setFeatures(\n            QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable\n        )\n        self.main_window.addDockWidget(Qt.BottomDockWidgetArea, self.toolbar_dock)\n\n        # Connections\n        self.layer_settings.messageSignal.connect(self.messageSignal.emit)\n        self.current_canvas.bakingResult.connect(self.bakingResult.emit)\n        self.current_canvas.layersChanged.connect(self.update_list)\n        self.current_canvas.layerRemoved.connect(self.update_list)\n\n        self.canvas_list.canvasSelected.connect(self.on_canvas_selected)\n        self.canvas_list.canvasAdded.connect(self.on_canvas_added)\n        self.canvas_list.canvasDeleted.connect(self.on_canvas_deleted)\n        # self.current_canvas.thumbnailsAvailable.connect(self.generate_state_previews)\n\n    def update_slider_range(self, steps):\n        \"\"\"Update the slider range based on the number of steps.\"\"\"\n        self.timeline_slider.setMaximum(steps - 1)\n        self.messageSignal.emit(f\"Updated steps to {steps}\")\n        self.timeline_slider.setEnabled(False)  # Disable the slider\n        self.timeline_slider.update()\n\n    def generate_state_previews(self):\n        \"\"\"Generate previews for each state.\"\"\"\n        # Clear existing previews\n        for i in reversed(range(self.preview_layout.count())):\n            widget = self.preview_layout.itemAt(i).widget()\n            if widget:\n                widget.deleteLater()\n\n        # Generate a preview for each state\n        for step, states in sorted(self.current_canvas.states.items()):\n            # Create a container widget for the preview\n            preview_widget = QWidget()\n            preview_layout = QVBoxLayout(preview_widget)\n            preview_layout.setContentsMargins(0, 0, 0, 0)\n            preview_layout.setSpacing(2)\n\n            # Placeholder thumbnail\n            placeholder = QPixmap(50, 50)\n            placeholder.fill(Qt.gray)  # Gray placeholder\n            thumbnail_label = QLabel()\n            thumbnail_label.setPixmap(placeholder)\n            thumbnail_label.setFixedSize(50, 50)  # Set a fixed size for the thumbnail\n            thumbnail_label.setScaledContents(True)\n\n            # Add the step number on top of the thumbnail\n            step_label = QLabel(f\"Step {step}\")\n            step_label.setAlignment(Qt.AlignCenter)\n            step_label.setStyleSheet(\"font-weight: bold; font-size: 10px;\")\n\n            # Add a button to make the preview clickable\n            preview_button = QPushButton()\n            preview_button.setFixedSize(\n                50, 70\n            )  # Match the size of the thumbnail + step label\n            preview_button.setStyleSheet(\"background: transparent; border: none;\")\n            preview_button.clicked.connect(lambda _, s=step: self.seek_state(s))\n\n            # Add the thumbnail and step label to the layout\n            preview_layout.addWidget(thumbnail_label)\n            preview_layout.addWidget(step_label)\n\n            # Add the preview widget to the button\n            preview_button.setLayout(preview_layout)\n\n            # Add the button to the preview panel\n            self.preview_layout.addWidget(preview_button)\n\n            # Update the thumbnail dynamically when it becomes available\n            self.current_canvas.thumbnailsAvailable.connect(\n                lambda step=step, label=thumbnail_label: self.update_thumbnail(\n                    step, label\n                )\n            )\n\n        # Refresh the preview panel\n        self.preview_panel.update()\n\n    def update_thumbnail(self, step, thumbnail_label):\n        \"\"\"Update the thumbnail for a specific step.\"\"\"\n        if step in self.current_canvas.state_thumbnail:\n            thumbnail = self.current_canvas.state_thumbnail[step]\n            thumbnail_label.setPixmap(thumbnail)\n            thumbnail_label.update()\n\n    def update_list(self, layer=None):\n        \"\"\"Update the layer list and layer settings.\"\"\"\n        if layer:\n            self.layer_list.layers = self.current_canvas.layers\n        self.layer_list.update_list()\n        self.layer_settings.update_sliders()\n        self.update()\n\n    def on_canvas_deleted(self, canvas: CanvasLayer):\n        \"\"\"Handle the deletion of a canvas.\"\"\"\n        # Ensure only the currently selected canvas is visible\n        if self.canvases:\n            self.layer_list.canvas = self.canvases[-1]\n            self.layer_list.layers = self.canvases[-1].layers\n            self.current_canvas = self.canvases[-1]  # Select the last canvas\n            self.current_canvas.setVisible(True)  # Show the last canvas\n        else:\n            self.current_canvas = None  # No canvases left\n            self.messageSignal.emit(\"No canvases available.\")  # Notify the user\n            self.layer_list.canvas = None\n            self.layer_list.layers = []\n            self.layer_settings.selected_layer = None\n        self.layer_settings.update_sliders()\n        self.canvas_list.update_canvas_list()  # Update the canvas list\n        self.layer_list.update_list()\n        self.update()\n\n    def on_canvas_selected(self, canvas: CanvasLayer):\n        \"\"\"Handle canvas selection from the CanvasList.\"\"\"\n        # Hide all canvases and show only the selected one\n        for layer in self.canvases:\n            layer.setVisible(layer == canvas)\n\n        # Update the current canvas\n        self.current_canvas = canvas\n        self.layer_list.canvas = canvas\n        self.layer_list.layers = canvas.layers\n        self.layer_settings.selected_layer = canvas.selected_layer\n        self.layer_list.layer_settings = self.layer_settings\n\n        self.layer_list.update_list()\n        self.layer_settings.update_sliders()\n\n        logger.info(f\"Selected canvas: {canvas.layer_name}\")\n        self.update()\n\n    def on_canvas_added(self, new_canvas: CanvasLayer):\n        \"\"\"Handle the addition of a new canvas.\"\"\"\n        logger.info(f\"New canvas added: {new_canvas.layer_name}\")\n        self.main_layout.addWidget(new_canvas)  # Add the new canvas to the layout\n        if self.current_canvas is not None:\n            self.current_canvas.setVisible(False)  # Hide the current canvas\n\n        # self.canvases.append(new_canvas)  # Add the new canvas to the deque\n        # connect it to the layer list\n        self.layer_list.canvas = new_canvas\n        self.current_canvas = new_canvas  # Update the current canvas\n        self.canvas_list.update_canvas_list()  # Update the canvas list\n        new_canvas.setVisible(True)  # Hide the new canvas initially\n        # already added to the list\n        # self.canvases.append(new_canvas)  # Add to the deque\n\n        self.current_canvas.bakingResult.connect(self.bakingResult.emit)\n        self.current_canvas.layersChanged.connect(self.update_list)\n        self.current_canvas.layerRemoved.connect(self.update_list)\n\n        self.current_canvas.update()\n        self.layer_list.layers = new_canvas.layers\n        self.layer_list.update_list()\n        self.layer_settings.selected_layer = None\n        self.layer_settings.update_sliders()\n\n    def create_toolbar(self):\n        \"\"\"Create Baker-specific toolbar\"\"\"\n        self.toolbar = QWidget()\n        baker_toolbar_layout = QHBoxLayout(self.toolbar)\n        baker_toolbar_layout.setContentsMargins(5, 5, 5, 5)\n        baker_toolbar_layout.setSpacing(10)\n\n        # Add a label for \"Steps\"\n        steps_label = QLabel(\"Steps:\")\n        steps_label.setStyleSheet(\"font-weight: bold;\")\n        baker_toolbar_layout.addWidget(steps_label)\n\n        # Add a spin box for entering the number of steps\n        self.steps_spinbox = QSpinBox()\n        self.steps_spinbox.setMinimum(1)\n        self.steps_spinbox.setMaximum(1000)  # Arbitrary maximum value\n        self.steps_spinbox.setValue(1)  # Default value\n        self.steps_spinbox.valueChanged.connect(self.update_slider_range)\n        baker_toolbar_layout.addWidget(self.steps_spinbox)\n\n        # Add buttons for Baker modes with emojis\n        baker_modes = [\n            (\"\ud83d\udce4 Export Current State\", self.export_current_state),\n            (\"\ud83d\udcbe Save State\", self.save_current_state),\n            (\"\ud83d\udd2e Predict State\", self.predict_state),\n            (\"\u25b6\ufe0f Play States\", self.play_saved_states),\n            (\"\ud83d\uddd1\ufe0f Clear States\", self.clear_states),  # New button\n            (\"\ud83d\udce4 Annotate States\", self.export_for_annotation),\n            (\"\ud83d\udce4 Export States\", self.export_locally),\n        ]\n\n        for text, callback in baker_modes:\n            btn = QPushButton(text)\n            btn.clicked.connect(callback)\n            baker_toolbar_layout.addWidget(btn)\n\n            # If the button is \"Play States\", add the slider beside it\n            if text == \"\u25b6\ufe0f Play States\":\n                self.timeline_slider = QSlider(Qt.Horizontal)  # Create the slider\n                self.timeline_slider.setMinimum(0)\n                self.timeline_slider.setMaximum(0)  # Will be updated dynamically\n                self.timeline_slider.setValue(0)\n                self.timeline_slider.setSingleStep(\n                    1\n                )  # Set the granularity of the slider\n                self.timeline_slider.setPageStep(1)  # Allow smoother jumps\n                self.timeline_slider.setEnabled(False)  # Initially disabled\n                self.timeline_slider.valueChanged.connect(self.seek_state)\n                baker_toolbar_layout.addWidget(self.timeline_slider)\n\n        # Add a drawing button\n        draw_button = QPushButton(\"\u270f\ufe0f Draw\")\n        draw_button.setCheckable(True)  # Make it toggleable\n        draw_button.clicked.connect(self.toggle_drawing_mode)\n        baker_toolbar_layout.addWidget(draw_button)\n\n        # Add an erase button\n        erase_button = QPushButton(\"\ud83e\uddf9 Erase\")\n        erase_button.setCheckable(True)  # Make it toggleable\n        erase_button.clicked.connect(self.toggle_erase_mode)\n        baker_toolbar_layout.addWidget(erase_button)\n\n        # Add a color picker button\n        color_picker_button = QPushButton(\"\ud83c\udfa8\")\n        color_picker_button.clicked.connect(self.open_color_picker)\n        baker_toolbar_layout.addWidget(color_picker_button)\n\n        # Add a spacer to push the rest of the elements to the right\n        spacer = QWidget()\n        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\n        baker_toolbar_layout.addWidget(spacer)\n\n        # Add the toolbar to the main layout\n        self.main_layout.addWidget(self.toolbar)\n\n    def toggle_drawing_mode(self):\n        \"\"\"Toggle drawing mode on the current canvas.\"\"\"\n        if self.current_canvas:\n            self.current_canvas.mouse_mode = (\n                MouseMode.DRAW\n                if self.current_canvas.mouse_mode != MouseMode.DRAW\n                else MouseMode.IDLE\n            )\n            mode = self.current_canvas.mouse_mode.name.lower()\n            self.messageSignal.emit(f\"Drawing mode {mode}.\")\n\n    def toggle_erase_mode(self):\n        \"\"\"Toggle drawing mode on the current canvas.\"\"\"\n        if self.current_canvas:\n            self.current_canvas.mouse_mode = (\n                MouseMode.ERASE\n                if self.current_canvas.mouse_mode != MouseMode.ERASE\n                else MouseMode.IDLE\n            )\n            mode = self.current_canvas.mouse_mode.name.lower()\n            self.messageSignal.emit(f\"Erasing mode {mode}.\")\n\n    def open_color_picker(self):\n        \"\"\"Open a color picker dialog to select a custom color.\"\"\"\n        color = QColorDialog.getColor()\n        if color.isValid():\n            self.current_canvas.drawing_color = color\n            self.messageSignal.emit(f\"Selected custom color: {color.name()}\")\n\n    def export_for_annotation(self):\n        \"\"\"Export the baked states for annotation.\"\"\"\n        self.messageSignal.emit(\"Exporting states for prediction...\")\n        self.current_canvas.export_baked_states(export_to_annotation_tab=True)\n\n    def export_locally(self):\n        \"\"\"Export the baked states locally.\"\"\"\n        self.messageSignal.emit(\"Exporting baked states...\")\n        self.current_canvas.export_baked_states()\n\n    def play_saved_states(self):\n        \"\"\"Play the saved states in sequence.\"\"\"\n        self.messageSignal.emit(\"Playing saved state...\")\n\n        # Enable the timeline slider\n\n        # Update the slider range based on the number of states\n        if self.current_canvas.states:\n            num_states = len(self.current_canvas.states)\n            self.timeline_slider.setMaximum(num_states - 1)\n            self.steps_spinbox.setValue(\n                num_states\n            )  # Sync the spinbox with the number of states\n            self.timeline_slider.setEnabled(True)\n        else:\n            self.timeline_slider.setMaximum(0)\n            self.steps_spinbox.setValue(1)\n            self.messageSignal.emit(\"No saved states available.\")\n            self.timeline_slider.setEnabled(False)\n\n        self.timeline_slider.update()\n        # Start playing the states\n        self.current_canvas.play_states()\n\n    def save_current_state(self):\n        \"\"\"Save the current state of the canvas.\"\"\"\n        self.messageSignal.emit(\"Saving current state...\")\n        logger.info(f\"Saving current state for {self.steps_spinbox.value()}...\")\n\n        self.current_canvas.save_current_state(steps=self.steps_spinbox.value())\n        self.messageSignal.emit(\n            \"Current state saved. Total states: {}\".format(\n                len(self.current_canvas.states)\n            )\n        )\n\n        self.steps_spinbox.setValue(1)  # Reset the spinbox value\n        self.steps_spinbox.update()\n        # Disable the timeline slider\n        self.timeline_slider.setEnabled(False)\n        self.timeline_slider.update()\n\n    def clear_states(self):\n        \"\"\"Clear all saved states and disable the timeline slider.\"\"\"\n        self.messageSignal.emit(\"Clearing all saved states...\")\n        if self.current_canvas:\n            self.current_canvas.previous_state = None\n            self.current_canvas.current_step = 0\n            self.current_canvas.states.clear()  # Clear all saved states\n        self.timeline_slider.setEnabled(False)  # Disable the slider\n        self.timeline_slider.setMaximum(0)  # Reset the slider range\n        self.timeline_slider.setValue(0)  # Reset the slider position\n        self.messageSignal.emit(\"All states cleared.\")\n        self.steps_spinbox.setValue(1)  # Reset the spinbox value\n\n        self.steps_spinbox.update()\n        self.timeline_slider.update()\n        self.current_canvas.update()\n\n    def seek_state(self, step):\n        \"\"\"Seek to a specific state using the timeline slider.\"\"\"\n        self.messageSignal.emit(f\"Seeking to step {step}\")\n        logger.info(f\"Seeking to step {step}\")\n        self.current_canvas.seek_state(step)\n\n        # Update the canvas\n        self.current_canvas.update()\n\n    def export_current_state(self):\n        \"\"\"Export the current state as an image.\"\"\"\n        self.messageSignal.emit(\"Exporting current state...\")\n        self.current_canvas.export_current_state()\n\n    def predict_state(self):\n        \"\"\"Pass the current state to predict.\"\"\"\n        self.messageSignal.emit(\"Predicting state...\")\n\n        self.current_canvas.predict_state()\n\n    def add_layer(self, layer: CanvasLayer):\n        \"\"\"Add a new layer to the canvas.\"\"\"\n        self.layer_list.add_layer(layer)\n        self.layer_settings.selected_layer = self.current_canvas.selected_layer\n        self.layer_settings.update_sliders()\n\n    def keyPressEvent(self, event):\n        \"\"\"Handle key press events.\"\"\"\n        # Ctrl + S: Save the current state\n        curr_mode = self.current_canvas.mouse_mode\n        if event.key() == Qt.Key_S and event.modifiers() == Qt.ControlModifier:\n            self.save_current_state()\n            self.current_canvas.mouse_mode = curr_mode\n            self.current_canvas.update()\n        # if ctrl + D: Toggle drawing mode\n        if event.key() == Qt.Key_D and event.modifiers() == Qt.ControlModifier:\n            self.toggle_drawing_mode()\n            self.current_canvas.update()\n        # if ctrl + E: Toggle erase mode\n        if event.key() == Qt.Key_E and event.modifiers() == Qt.ControlModifier:\n            self.toggle_erase_mode()\n            self.current_canvas.update()\n\n        # Delete: Delete the selected layer\n        if event.key() == Qt.Key_Delete:\n            if (\n                self.current_canvas.selected_layer\n                and self.current_canvas.selected_layer in self.current_canvas.layers\n            ):\n                self.current_canvas.layers.remove(self.current_canvas.selected_layer)\n                self.current_canvas.selected_layer = None\n                self.layer_settings.selected_layer = None\n\n            self.current_canvas.update()\n            self.layer_list.update_list()\n            self.layer_settings.update_sliders()\n            self.messageSignal.emit(\"Deleted selected layer\")\n\n        # Ctrl + N: Add a new layer to the current canvas\n        if event.key() == Qt.Key_N and event.modifiers() == Qt.ControlModifier:\n            new_layer = CanvasLayer(parent=self.current_canvas)\n            new_layer.layer_name = f\"Layer {len(self.current_canvas.layers) + 1}\"\n            new_layer.annotations = [\n                Annotation(annotation_id=0, label=\"New Annotation\"),\n            ]\n            balnk_qimage = QPixmap(self.current_canvas.size())\n            balnk_qimage.fill(Qt.transparent)\n            new_layer.set_image(balnk_qimage)\n            self.current_canvas.layers.append(new_layer)\n            self.current_canvas.update()\n            self.layer_list.update_list()\n            self.messageSignal.emit(f\"Added new layer: {new_layer.layer_name}\")\n\n        self.update()\n        return super().keyPressEvent(event)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.add_layer","title":"<code>add_layer(layer)</code>","text":"<p>Add a new layer to the canvas.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def add_layer(self, layer: CanvasLayer):\n    \"\"\"Add a new layer to the canvas.\"\"\"\n    self.layer_list.add_layer(layer)\n    self.layer_settings.selected_layer = self.current_canvas.selected_layer\n    self.layer_settings.update_sliders()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.clear_states","title":"<code>clear_states()</code>","text":"<p>Clear all saved states and disable the timeline slider.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def clear_states(self):\n    \"\"\"Clear all saved states and disable the timeline slider.\"\"\"\n    self.messageSignal.emit(\"Clearing all saved states...\")\n    if self.current_canvas:\n        self.current_canvas.previous_state = None\n        self.current_canvas.current_step = 0\n        self.current_canvas.states.clear()  # Clear all saved states\n    self.timeline_slider.setEnabled(False)  # Disable the slider\n    self.timeline_slider.setMaximum(0)  # Reset the slider range\n    self.timeline_slider.setValue(0)  # Reset the slider position\n    self.messageSignal.emit(\"All states cleared.\")\n    self.steps_spinbox.setValue(1)  # Reset the spinbox value\n\n    self.steps_spinbox.update()\n    self.timeline_slider.update()\n    self.current_canvas.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.create_toolbar","title":"<code>create_toolbar()</code>","text":"<p>Create Baker-specific toolbar</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def create_toolbar(self):\n    \"\"\"Create Baker-specific toolbar\"\"\"\n    self.toolbar = QWidget()\n    baker_toolbar_layout = QHBoxLayout(self.toolbar)\n    baker_toolbar_layout.setContentsMargins(5, 5, 5, 5)\n    baker_toolbar_layout.setSpacing(10)\n\n    # Add a label for \"Steps\"\n    steps_label = QLabel(\"Steps:\")\n    steps_label.setStyleSheet(\"font-weight: bold;\")\n    baker_toolbar_layout.addWidget(steps_label)\n\n    # Add a spin box for entering the number of steps\n    self.steps_spinbox = QSpinBox()\n    self.steps_spinbox.setMinimum(1)\n    self.steps_spinbox.setMaximum(1000)  # Arbitrary maximum value\n    self.steps_spinbox.setValue(1)  # Default value\n    self.steps_spinbox.valueChanged.connect(self.update_slider_range)\n    baker_toolbar_layout.addWidget(self.steps_spinbox)\n\n    # Add buttons for Baker modes with emojis\n    baker_modes = [\n        (\"\ud83d\udce4 Export Current State\", self.export_current_state),\n        (\"\ud83d\udcbe Save State\", self.save_current_state),\n        (\"\ud83d\udd2e Predict State\", self.predict_state),\n        (\"\u25b6\ufe0f Play States\", self.play_saved_states),\n        (\"\ud83d\uddd1\ufe0f Clear States\", self.clear_states),  # New button\n        (\"\ud83d\udce4 Annotate States\", self.export_for_annotation),\n        (\"\ud83d\udce4 Export States\", self.export_locally),\n    ]\n\n    for text, callback in baker_modes:\n        btn = QPushButton(text)\n        btn.clicked.connect(callback)\n        baker_toolbar_layout.addWidget(btn)\n\n        # If the button is \"Play States\", add the slider beside it\n        if text == \"\u25b6\ufe0f Play States\":\n            self.timeline_slider = QSlider(Qt.Horizontal)  # Create the slider\n            self.timeline_slider.setMinimum(0)\n            self.timeline_slider.setMaximum(0)  # Will be updated dynamically\n            self.timeline_slider.setValue(0)\n            self.timeline_slider.setSingleStep(\n                1\n            )  # Set the granularity of the slider\n            self.timeline_slider.setPageStep(1)  # Allow smoother jumps\n            self.timeline_slider.setEnabled(False)  # Initially disabled\n            self.timeline_slider.valueChanged.connect(self.seek_state)\n            baker_toolbar_layout.addWidget(self.timeline_slider)\n\n    # Add a drawing button\n    draw_button = QPushButton(\"\u270f\ufe0f Draw\")\n    draw_button.setCheckable(True)  # Make it toggleable\n    draw_button.clicked.connect(self.toggle_drawing_mode)\n    baker_toolbar_layout.addWidget(draw_button)\n\n    # Add an erase button\n    erase_button = QPushButton(\"\ud83e\uddf9 Erase\")\n    erase_button.setCheckable(True)  # Make it toggleable\n    erase_button.clicked.connect(self.toggle_erase_mode)\n    baker_toolbar_layout.addWidget(erase_button)\n\n    # Add a color picker button\n    color_picker_button = QPushButton(\"\ud83c\udfa8\")\n    color_picker_button.clicked.connect(self.open_color_picker)\n    baker_toolbar_layout.addWidget(color_picker_button)\n\n    # Add a spacer to push the rest of the elements to the right\n    spacer = QWidget()\n    spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)\n    baker_toolbar_layout.addWidget(spacer)\n\n    # Add the toolbar to the main layout\n    self.main_layout.addWidget(self.toolbar)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.export_current_state","title":"<code>export_current_state()</code>","text":"<p>Export the current state as an image.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def export_current_state(self):\n    \"\"\"Export the current state as an image.\"\"\"\n    self.messageSignal.emit(\"Exporting current state...\")\n    self.current_canvas.export_current_state()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.export_for_annotation","title":"<code>export_for_annotation()</code>","text":"<p>Export the baked states for annotation.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def export_for_annotation(self):\n    \"\"\"Export the baked states for annotation.\"\"\"\n    self.messageSignal.emit(\"Exporting states for prediction...\")\n    self.current_canvas.export_baked_states(export_to_annotation_tab=True)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.export_locally","title":"<code>export_locally()</code>","text":"<p>Export the baked states locally.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def export_locally(self):\n    \"\"\"Export the baked states locally.\"\"\"\n    self.messageSignal.emit(\"Exporting baked states...\")\n    self.current_canvas.export_baked_states()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.generate_state_previews","title":"<code>generate_state_previews()</code>","text":"<p>Generate previews for each state.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def generate_state_previews(self):\n    \"\"\"Generate previews for each state.\"\"\"\n    # Clear existing previews\n    for i in reversed(range(self.preview_layout.count())):\n        widget = self.preview_layout.itemAt(i).widget()\n        if widget:\n            widget.deleteLater()\n\n    # Generate a preview for each state\n    for step, states in sorted(self.current_canvas.states.items()):\n        # Create a container widget for the preview\n        preview_widget = QWidget()\n        preview_layout = QVBoxLayout(preview_widget)\n        preview_layout.setContentsMargins(0, 0, 0, 0)\n        preview_layout.setSpacing(2)\n\n        # Placeholder thumbnail\n        placeholder = QPixmap(50, 50)\n        placeholder.fill(Qt.gray)  # Gray placeholder\n        thumbnail_label = QLabel()\n        thumbnail_label.setPixmap(placeholder)\n        thumbnail_label.setFixedSize(50, 50)  # Set a fixed size for the thumbnail\n        thumbnail_label.setScaledContents(True)\n\n        # Add the step number on top of the thumbnail\n        step_label = QLabel(f\"Step {step}\")\n        step_label.setAlignment(Qt.AlignCenter)\n        step_label.setStyleSheet(\"font-weight: bold; font-size: 10px;\")\n\n        # Add a button to make the preview clickable\n        preview_button = QPushButton()\n        preview_button.setFixedSize(\n            50, 70\n        )  # Match the size of the thumbnail + step label\n        preview_button.setStyleSheet(\"background: transparent; border: none;\")\n        preview_button.clicked.connect(lambda _, s=step: self.seek_state(s))\n\n        # Add the thumbnail and step label to the layout\n        preview_layout.addWidget(thumbnail_label)\n        preview_layout.addWidget(step_label)\n\n        # Add the preview widget to the button\n        preview_button.setLayout(preview_layout)\n\n        # Add the button to the preview panel\n        self.preview_layout.addWidget(preview_button)\n\n        # Update the thumbnail dynamically when it becomes available\n        self.current_canvas.thumbnailsAvailable.connect(\n            lambda step=step, label=thumbnail_label: self.update_thumbnail(\n                step, label\n            )\n        )\n\n    # Refresh the preview panel\n    self.preview_panel.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.init_ui","title":"<code>init_ui()</code>","text":"<p>Initialize the UI components.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def init_ui(self):\n    \"\"\"Initialize the UI components.\"\"\"\n    # Create toolbar\n    self.create_toolbar()\n\n    # Create a single canvas for now\n    self.current_canvas = CanvasLayer(parent=self.main_window, config=self.config)\n    self.current_canvas.setVisible(True)  # Initially hide all canvases\n    self.canvases.append(self.current_canvas)\n    self.main_layout.addWidget(self.current_canvas)\n\n    # Create and add CanvasList\n    self.canvas_list = CanvasList(self.canvases, parent=self.main_window)\n    self.main_window.addDockWidget(Qt.LeftDockWidgetArea, self.canvas_list)\n\n    # Create and add LayerList\n    self.layer_settings = LayerSettings(\n        parent=self.main_window,\n        max_xpos=self.config.max_xpos,\n        max_ypos=self.config.max_ypos,\n        max_scale=self.config.max_scale,\n        max_edge_width=self.config.max_edge_width,\n    )\n    self.layer_list = LayerList(\n        canvas=self.current_canvas,\n        parent=self.main_window,\n        layer_settings=self.layer_settings,\n    )\n    self.layer_settings.setVisible(False)\n    self.main_window.addDockWidget(Qt.RightDockWidgetArea, self.layer_list)\n    self.main_window.addDockWidget(Qt.RightDockWidgetArea, self.layer_settings)\n\n    # Create a dock widget for the toolbar\n    self.toolbar_dock = QDockWidget(\"Tools\", self)\n    self.toolbar_dock.setWidget(self.toolbar)\n    self.toolbar_dock.setFeatures(\n        QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable\n    )\n    self.main_window.addDockWidget(Qt.BottomDockWidgetArea, self.toolbar_dock)\n\n    # Connections\n    self.layer_settings.messageSignal.connect(self.messageSignal.emit)\n    self.current_canvas.bakingResult.connect(self.bakingResult.emit)\n    self.current_canvas.layersChanged.connect(self.update_list)\n    self.current_canvas.layerRemoved.connect(self.update_list)\n\n    self.canvas_list.canvasSelected.connect(self.on_canvas_selected)\n    self.canvas_list.canvasAdded.connect(self.on_canvas_added)\n    self.canvas_list.canvasDeleted.connect(self.on_canvas_deleted)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.keyPressEvent","title":"<code>keyPressEvent(event)</code>","text":"<p>Handle key press events.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def keyPressEvent(self, event):\n    \"\"\"Handle key press events.\"\"\"\n    # Ctrl + S: Save the current state\n    curr_mode = self.current_canvas.mouse_mode\n    if event.key() == Qt.Key_S and event.modifiers() == Qt.ControlModifier:\n        self.save_current_state()\n        self.current_canvas.mouse_mode = curr_mode\n        self.current_canvas.update()\n    # if ctrl + D: Toggle drawing mode\n    if event.key() == Qt.Key_D and event.modifiers() == Qt.ControlModifier:\n        self.toggle_drawing_mode()\n        self.current_canvas.update()\n    # if ctrl + E: Toggle erase mode\n    if event.key() == Qt.Key_E and event.modifiers() == Qt.ControlModifier:\n        self.toggle_erase_mode()\n        self.current_canvas.update()\n\n    # Delete: Delete the selected layer\n    if event.key() == Qt.Key_Delete:\n        if (\n            self.current_canvas.selected_layer\n            and self.current_canvas.selected_layer in self.current_canvas.layers\n        ):\n            self.current_canvas.layers.remove(self.current_canvas.selected_layer)\n            self.current_canvas.selected_layer = None\n            self.layer_settings.selected_layer = None\n\n        self.current_canvas.update()\n        self.layer_list.update_list()\n        self.layer_settings.update_sliders()\n        self.messageSignal.emit(\"Deleted selected layer\")\n\n    # Ctrl + N: Add a new layer to the current canvas\n    if event.key() == Qt.Key_N and event.modifiers() == Qt.ControlModifier:\n        new_layer = CanvasLayer(parent=self.current_canvas)\n        new_layer.layer_name = f\"Layer {len(self.current_canvas.layers) + 1}\"\n        new_layer.annotations = [\n            Annotation(annotation_id=0, label=\"New Annotation\"),\n        ]\n        balnk_qimage = QPixmap(self.current_canvas.size())\n        balnk_qimage.fill(Qt.transparent)\n        new_layer.set_image(balnk_qimage)\n        self.current_canvas.layers.append(new_layer)\n        self.current_canvas.update()\n        self.layer_list.update_list()\n        self.messageSignal.emit(f\"Added new layer: {new_layer.layer_name}\")\n\n    self.update()\n    return super().keyPressEvent(event)\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.on_canvas_added","title":"<code>on_canvas_added(new_canvas)</code>","text":"<p>Handle the addition of a new canvas.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def on_canvas_added(self, new_canvas: CanvasLayer):\n    \"\"\"Handle the addition of a new canvas.\"\"\"\n    logger.info(f\"New canvas added: {new_canvas.layer_name}\")\n    self.main_layout.addWidget(new_canvas)  # Add the new canvas to the layout\n    if self.current_canvas is not None:\n        self.current_canvas.setVisible(False)  # Hide the current canvas\n\n    # self.canvases.append(new_canvas)  # Add the new canvas to the deque\n    # connect it to the layer list\n    self.layer_list.canvas = new_canvas\n    self.current_canvas = new_canvas  # Update the current canvas\n    self.canvas_list.update_canvas_list()  # Update the canvas list\n    new_canvas.setVisible(True)  # Hide the new canvas initially\n    # already added to the list\n    # self.canvases.append(new_canvas)  # Add to the deque\n\n    self.current_canvas.bakingResult.connect(self.bakingResult.emit)\n    self.current_canvas.layersChanged.connect(self.update_list)\n    self.current_canvas.layerRemoved.connect(self.update_list)\n\n    self.current_canvas.update()\n    self.layer_list.layers = new_canvas.layers\n    self.layer_list.update_list()\n    self.layer_settings.selected_layer = None\n    self.layer_settings.update_sliders()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.on_canvas_deleted","title":"<code>on_canvas_deleted(canvas)</code>","text":"<p>Handle the deletion of a canvas.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def on_canvas_deleted(self, canvas: CanvasLayer):\n    \"\"\"Handle the deletion of a canvas.\"\"\"\n    # Ensure only the currently selected canvas is visible\n    if self.canvases:\n        self.layer_list.canvas = self.canvases[-1]\n        self.layer_list.layers = self.canvases[-1].layers\n        self.current_canvas = self.canvases[-1]  # Select the last canvas\n        self.current_canvas.setVisible(True)  # Show the last canvas\n    else:\n        self.current_canvas = None  # No canvases left\n        self.messageSignal.emit(\"No canvases available.\")  # Notify the user\n        self.layer_list.canvas = None\n        self.layer_list.layers = []\n        self.layer_settings.selected_layer = None\n    self.layer_settings.update_sliders()\n    self.canvas_list.update_canvas_list()  # Update the canvas list\n    self.layer_list.update_list()\n    self.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.on_canvas_selected","title":"<code>on_canvas_selected(canvas)</code>","text":"<p>Handle canvas selection from the CanvasList.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def on_canvas_selected(self, canvas: CanvasLayer):\n    \"\"\"Handle canvas selection from the CanvasList.\"\"\"\n    # Hide all canvases and show only the selected one\n    for layer in self.canvases:\n        layer.setVisible(layer == canvas)\n\n    # Update the current canvas\n    self.current_canvas = canvas\n    self.layer_list.canvas = canvas\n    self.layer_list.layers = canvas.layers\n    self.layer_settings.selected_layer = canvas.selected_layer\n    self.layer_list.layer_settings = self.layer_settings\n\n    self.layer_list.update_list()\n    self.layer_settings.update_sliders()\n\n    logger.info(f\"Selected canvas: {canvas.layer_name}\")\n    self.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.open_color_picker","title":"<code>open_color_picker()</code>","text":"<p>Open a color picker dialog to select a custom color.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def open_color_picker(self):\n    \"\"\"Open a color picker dialog to select a custom color.\"\"\"\n    color = QColorDialog.getColor()\n    if color.isValid():\n        self.current_canvas.drawing_color = color\n        self.messageSignal.emit(f\"Selected custom color: {color.name()}\")\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.play_saved_states","title":"<code>play_saved_states()</code>","text":"<p>Play the saved states in sequence.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def play_saved_states(self):\n    \"\"\"Play the saved states in sequence.\"\"\"\n    self.messageSignal.emit(\"Playing saved state...\")\n\n    # Enable the timeline slider\n\n    # Update the slider range based on the number of states\n    if self.current_canvas.states:\n        num_states = len(self.current_canvas.states)\n        self.timeline_slider.setMaximum(num_states - 1)\n        self.steps_spinbox.setValue(\n            num_states\n        )  # Sync the spinbox with the number of states\n        self.timeline_slider.setEnabled(True)\n    else:\n        self.timeline_slider.setMaximum(0)\n        self.steps_spinbox.setValue(1)\n        self.messageSignal.emit(\"No saved states available.\")\n        self.timeline_slider.setEnabled(False)\n\n    self.timeline_slider.update()\n    # Start playing the states\n    self.current_canvas.play_states()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.predict_state","title":"<code>predict_state()</code>","text":"<p>Pass the current state to predict.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def predict_state(self):\n    \"\"\"Pass the current state to predict.\"\"\"\n    self.messageSignal.emit(\"Predicting state...\")\n\n    self.current_canvas.predict_state()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.save_current_state","title":"<code>save_current_state()</code>","text":"<p>Save the current state of the canvas.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def save_current_state(self):\n    \"\"\"Save the current state of the canvas.\"\"\"\n    self.messageSignal.emit(\"Saving current state...\")\n    logger.info(f\"Saving current state for {self.steps_spinbox.value()}...\")\n\n    self.current_canvas.save_current_state(steps=self.steps_spinbox.value())\n    self.messageSignal.emit(\n        \"Current state saved. Total states: {}\".format(\n            len(self.current_canvas.states)\n        )\n    )\n\n    self.steps_spinbox.setValue(1)  # Reset the spinbox value\n    self.steps_spinbox.update()\n    # Disable the timeline slider\n    self.timeline_slider.setEnabled(False)\n    self.timeline_slider.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.seek_state","title":"<code>seek_state(step)</code>","text":"<p>Seek to a specific state using the timeline slider.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def seek_state(self, step):\n    \"\"\"Seek to a specific state using the timeline slider.\"\"\"\n    self.messageSignal.emit(f\"Seeking to step {step}\")\n    logger.info(f\"Seeking to step {step}\")\n    self.current_canvas.seek_state(step)\n\n    # Update the canvas\n    self.current_canvas.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.toggle_drawing_mode","title":"<code>toggle_drawing_mode()</code>","text":"<p>Toggle drawing mode on the current canvas.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def toggle_drawing_mode(self):\n    \"\"\"Toggle drawing mode on the current canvas.\"\"\"\n    if self.current_canvas:\n        self.current_canvas.mouse_mode = (\n            MouseMode.DRAW\n            if self.current_canvas.mouse_mode != MouseMode.DRAW\n            else MouseMode.IDLE\n        )\n        mode = self.current_canvas.mouse_mode.name.lower()\n        self.messageSignal.emit(f\"Drawing mode {mode}.\")\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.toggle_erase_mode","title":"<code>toggle_erase_mode()</code>","text":"<p>Toggle drawing mode on the current canvas.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def toggle_erase_mode(self):\n    \"\"\"Toggle drawing mode on the current canvas.\"\"\"\n    if self.current_canvas:\n        self.current_canvas.mouse_mode = (\n            MouseMode.ERASE\n            if self.current_canvas.mouse_mode != MouseMode.ERASE\n            else MouseMode.IDLE\n        )\n        mode = self.current_canvas.mouse_mode.name.lower()\n        self.messageSignal.emit(f\"Erasing mode {mode}.\")\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.update_list","title":"<code>update_list(layer=None)</code>","text":"<p>Update the layer list and layer settings.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def update_list(self, layer=None):\n    \"\"\"Update the layer list and layer settings.\"\"\"\n    if layer:\n        self.layer_list.layers = self.current_canvas.layers\n    self.layer_list.update_list()\n    self.layer_settings.update_sliders()\n    self.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.update_slider_range","title":"<code>update_slider_range(steps)</code>","text":"<p>Update the slider range based on the number of steps.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def update_slider_range(self, steps):\n    \"\"\"Update the slider range based on the number of steps.\"\"\"\n    self.timeline_slider.setMaximum(steps - 1)\n    self.messageSignal.emit(f\"Updated steps to {steps}\")\n    self.timeline_slider.setEnabled(False)  # Disable the slider\n    self.timeline_slider.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.tabs.baker_tab.BakerTab.update_thumbnail","title":"<code>update_thumbnail(step, thumbnail_label)</code>","text":"<p>Update the thumbnail for a specific step.</p> Source code in <code>imagebaker/tabs/baker_tab.py</code> <pre><code>def update_thumbnail(self, step, thumbnail_label):\n    \"\"\"Update the thumbnail for a specific step.\"\"\"\n    if step in self.current_canvas.state_thumbnail:\n        thumbnail = self.current_canvas.state_thumbnail[step]\n        thumbnail_label.setPixmap(thumbnail)\n        thumbnail_label.update()\n</code></pre>"},{"location":"api-reference/#list-views","title":"List Views","text":""},{"location":"api-reference/#image-list-panel","title":"Image List Panel","text":"<p>               Bases: <code>QDockWidget</code></p> Source code in <code>imagebaker/list_views/image_list.py</code> <pre><code>class ImageListPanel(QDockWidget):\n    imageSelected = Signal(Path)\n    activeImageEntries = Signal(list)\n\n    def __init__(\n        self,\n        image_entries: list[\"ImageEntry\"],\n        processed_images: set[Path],\n        parent=None,\n        max_name_length=15,\n        images_per_page=10,\n    ):\n        \"\"\"\n        :param image_entries: List of image paths to display.\n        :param processed_images: Set of image paths that have already been processed.\n        \"\"\"\n        super().__init__(\"Image List\", parent)\n        self.image_entries: list[\"ImageEntry\"] = image_entries\n        self.processed_images = processed_images\n        self.current_page = 0\n        self.images_per_page = images_per_page\n        self.max_name_length = max_name_length\n        self.init_ui()\n\n    def init_ui(self):\n        \"\"\"Initialize the UI for the image list panel.\"\"\"\n        logger.info(\"Initializing ImageListPanel\")\n        self.setMinimumWidth(150)\n        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)\n\n        widget = QWidget()\n        layout = QVBoxLayout(widget)\n\n        # Image list widget\n        self.list_widget = QListWidget()\n        self.list_widget.itemClicked.connect(self.handle_item_clicked)  # Connect signal\n        layout.addWidget(self.list_widget)\n\n        # Pagination controls\n        pagination_layout = QHBoxLayout()\n        self.prev_page_btn = QPushButton(\"Prev\")\n        self.prev_page_btn.clicked.connect(self.show_prev_page)\n        self.next_page_btn = QPushButton(\"Next\")\n        self.next_page_btn.clicked.connect(self.show_next_page)\n        pagination_layout.addWidget(self.prev_page_btn)\n        pagination_layout.addWidget(self.next_page_btn)\n        layout.addLayout(pagination_layout)\n\n        # Pagination info\n        self.pagination_label = QLabel(\"Showing 0 of 0\")\n        layout.addWidget(self.pagination_label)\n\n        self.setWidget(widget)\n        self.setFeatures(\n            QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable\n        )\n\n        self.update_image_list(self.image_entries)\n\n    def show_next_page(self):\n        \"\"\"Show the next page of images\"\"\"\n        if (self.current_page + 1) * self.images_per_page &lt; len(self.image_entries):\n            self.current_page += 1\n            self.update_image_list(self.image_entries)\n\n    def show_prev_page(self):\n        \"\"\"Show the previous page of images\"\"\"\n        if self.current_page &gt; 0:\n            self.current_page -= 1\n            self.update_image_list(self.image_entries)\n\n    def update_image_list(self, image_entries):\n        \"\"\"Update the image list with image paths and baked results.\"\"\"\n        self.list_widget.clear()\n\n        # Calculate the range of images to display for the current page\n        start_index = self.current_page * self.images_per_page\n        end_index = min(start_index + self.images_per_page, len(image_entries))\n\n        # Update the pagination label\n        self.pagination_label.setText(\n            f\"Showing {start_index + 1} to {end_index} of {len(image_entries)}\"\n        )\n\n        # Display only the images for the current page\n        active_image_entries = []\n        for idx, image_entry in enumerate(\n            image_entries[start_index:end_index], start=start_index + 1\n        ):\n            item_widget = QWidget()\n            item_layout = QHBoxLayout(item_widget)\n            item_layout.setContentsMargins(5, 5, 5, 5)\n\n            # Generate thumbnail\n            thumbnail_label = QLabel()\n            if image_entry.is_baked_result:\n                thumbnail_pixmap = (\n                    image_entry.data.get_thumbnail()\n                )  # Baked result thumbnail\n                name_label_text = f\"Baked Result {idx}\"\n            else:\n                thumbnail_pixmap = QPixmap(str(image_entry.data)).scaled(\n                    50, 50, Qt.KeepAspectRatio, Qt.SmoothTransformation\n                )\n                name_label_text = Path(image_entry.data).name[: self.max_name_length]\n\n            thumbnail_label.setPixmap(thumbnail_pixmap)\n            item_layout.addWidget(thumbnail_label)\n\n            # Text for image\n            name_label = QLabel(name_label_text)\n            name_label.setStyleSheet(\"font-weight: bold;\")\n            item_layout.addWidget(name_label)\n\n            item_layout.addStretch()\n\n            # Add the custom widget to the list\n            list_item = QListWidgetItem(self.list_widget)\n            list_item.setSizeHint(item_widget.sizeHint())\n            self.list_widget.addItem(list_item)\n            self.list_widget.setItemWidget(list_item, item_widget)\n\n            # Store metadata for the image\n            list_item.setData(Qt.UserRole, image_entry)\n            active_image_entries.append(image_entry)\n\n        self.activeImageEntries.emit(active_image_entries)\n        self.update()\n\n    def handle_item_clicked(self, item: QListWidgetItem):\n        \"\"\"Handle item click and emit the imageSelected signal.\"\"\"\n        item_data = item.data(Qt.UserRole)\n        if item_data:\n            self.imageSelected.emit(item_data)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.image_list.ImageListPanel.handle_item_clicked","title":"<code>handle_item_clicked(item)</code>","text":"<p>Handle item click and emit the imageSelected signal.</p> Source code in <code>imagebaker/list_views/image_list.py</code> <pre><code>def handle_item_clicked(self, item: QListWidgetItem):\n    \"\"\"Handle item click and emit the imageSelected signal.\"\"\"\n    item_data = item.data(Qt.UserRole)\n    if item_data:\n        self.imageSelected.emit(item_data)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.image_list.ImageListPanel.init_ui","title":"<code>init_ui()</code>","text":"<p>Initialize the UI for the image list panel.</p> Source code in <code>imagebaker/list_views/image_list.py</code> <pre><code>def init_ui(self):\n    \"\"\"Initialize the UI for the image list panel.\"\"\"\n    logger.info(\"Initializing ImageListPanel\")\n    self.setMinimumWidth(150)\n    self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)\n\n    widget = QWidget()\n    layout = QVBoxLayout(widget)\n\n    # Image list widget\n    self.list_widget = QListWidget()\n    self.list_widget.itemClicked.connect(self.handle_item_clicked)  # Connect signal\n    layout.addWidget(self.list_widget)\n\n    # Pagination controls\n    pagination_layout = QHBoxLayout()\n    self.prev_page_btn = QPushButton(\"Prev\")\n    self.prev_page_btn.clicked.connect(self.show_prev_page)\n    self.next_page_btn = QPushButton(\"Next\")\n    self.next_page_btn.clicked.connect(self.show_next_page)\n    pagination_layout.addWidget(self.prev_page_btn)\n    pagination_layout.addWidget(self.next_page_btn)\n    layout.addLayout(pagination_layout)\n\n    # Pagination info\n    self.pagination_label = QLabel(\"Showing 0 of 0\")\n    layout.addWidget(self.pagination_label)\n\n    self.setWidget(widget)\n    self.setFeatures(\n        QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable\n    )\n\n    self.update_image_list(self.image_entries)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.image_list.ImageListPanel.show_next_page","title":"<code>show_next_page()</code>","text":"<p>Show the next page of images</p> Source code in <code>imagebaker/list_views/image_list.py</code> <pre><code>def show_next_page(self):\n    \"\"\"Show the next page of images\"\"\"\n    if (self.current_page + 1) * self.images_per_page &lt; len(self.image_entries):\n        self.current_page += 1\n        self.update_image_list(self.image_entries)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.image_list.ImageListPanel.show_prev_page","title":"<code>show_prev_page()</code>","text":"<p>Show the previous page of images</p> Source code in <code>imagebaker/list_views/image_list.py</code> <pre><code>def show_prev_page(self):\n    \"\"\"Show the previous page of images\"\"\"\n    if self.current_page &gt; 0:\n        self.current_page -= 1\n        self.update_image_list(self.image_entries)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.image_list.ImageListPanel.update_image_list","title":"<code>update_image_list(image_entries)</code>","text":"<p>Update the image list with image paths and baked results.</p> Source code in <code>imagebaker/list_views/image_list.py</code> <pre><code>def update_image_list(self, image_entries):\n    \"\"\"Update the image list with image paths and baked results.\"\"\"\n    self.list_widget.clear()\n\n    # Calculate the range of images to display for the current page\n    start_index = self.current_page * self.images_per_page\n    end_index = min(start_index + self.images_per_page, len(image_entries))\n\n    # Update the pagination label\n    self.pagination_label.setText(\n        f\"Showing {start_index + 1} to {end_index} of {len(image_entries)}\"\n    )\n\n    # Display only the images for the current page\n    active_image_entries = []\n    for idx, image_entry in enumerate(\n        image_entries[start_index:end_index], start=start_index + 1\n    ):\n        item_widget = QWidget()\n        item_layout = QHBoxLayout(item_widget)\n        item_layout.setContentsMargins(5, 5, 5, 5)\n\n        # Generate thumbnail\n        thumbnail_label = QLabel()\n        if image_entry.is_baked_result:\n            thumbnail_pixmap = (\n                image_entry.data.get_thumbnail()\n            )  # Baked result thumbnail\n            name_label_text = f\"Baked Result {idx}\"\n        else:\n            thumbnail_pixmap = QPixmap(str(image_entry.data)).scaled(\n                50, 50, Qt.KeepAspectRatio, Qt.SmoothTransformation\n            )\n            name_label_text = Path(image_entry.data).name[: self.max_name_length]\n\n        thumbnail_label.setPixmap(thumbnail_pixmap)\n        item_layout.addWidget(thumbnail_label)\n\n        # Text for image\n        name_label = QLabel(name_label_text)\n        name_label.setStyleSheet(\"font-weight: bold;\")\n        item_layout.addWidget(name_label)\n\n        item_layout.addStretch()\n\n        # Add the custom widget to the list\n        list_item = QListWidgetItem(self.list_widget)\n        list_item.setSizeHint(item_widget.sizeHint())\n        self.list_widget.addItem(list_item)\n        self.list_widget.setItemWidget(list_item, item_widget)\n\n        # Store metadata for the image\n        list_item.setData(Qt.UserRole, image_entry)\n        active_image_entries.append(image_entry)\n\n    self.activeImageEntries.emit(active_image_entries)\n    self.update()\n</code></pre>"},{"location":"api-reference/#annotation-list","title":"Annotation List","text":"<p>               Bases: <code>QDockWidget</code></p> Source code in <code>imagebaker/list_views/annotation_list.py</code> <pre><code>class AnnotationList(QDockWidget):\n    messageSignal = Signal(str)\n\n    def __init__(self, layer: AnnotableLayer, parent=None, max_name_length=15):\n        super().__init__(\"Annotations\", parent)\n        self.layer = layer\n        self.max_name_length = max_name_length\n        self.init_ui()\n\n    def init_ui(self):\n        logger.info(\"Initializing AnnotationList\")\n        self.setMinimumWidth(150)\n        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)\n\n        widget = QWidget()\n        layout = QVBoxLayout(widget)\n        self.list_widget = QListWidget()\n\n        # Set the size policy for the list widget to expand dynamically\n        self.list_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n\n        layout.addWidget(self.list_widget)\n        self.setWidget(widget)\n        self.setFeatures(\n            QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable\n        )\n\n    def update_list(self):\n        self.list_widget.clear()\n        if self.layer is None:\n            return\n        for idx, ann in enumerate(self.layer.annotations):\n\n            item = QListWidgetItem(self.list_widget)\n\n            # Create container widget\n            widget = QWidget()\n            widget.setSizePolicy(QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed))\n\n            layout = QHBoxLayout(widget)\n            layout.setContentsMargins(1, 1, 2, 2)\n\n            # on clicking this element, select the annotation\n            widget.mousePressEvent = lambda event, i=idx: self.on_annotation_selected(i)\n\n            widget.setCursor(Qt.PointingHandCursor)\n\n            # Color indicator\n            color_label = QLabel()\n            color = QColor(ann.color)\n            if not ann.visible:\n                color.setAlpha(128)\n            pixmap = QPixmap(20, 20)\n            pixmap.fill(ann.color)\n            color_label.setPixmap(pixmap)\n            layout.addWidget(color_label)\n\n            # Text container\n            text_container = QWidget()\n            text_layout = QVBoxLayout(text_container)\n            text_layout.setContentsMargins(0, 0, 0, 0)\n\n            # Main label with conditional color\n            main_label = QLabel(f\"{ann.name}\")\n            main_color = \"#666\" if not ann.visible else \"black\"\n            main_label.setStyleSheet(f\"font-weight: bold; color: {main_color};\")\n            text_layout.addWidget(main_label)\n\n            # Change the text color of the selected annotation\n            if ann.selected:\n                main_label.setStyleSheet(\"font-weight: bold; color: blue;\")\n            else:\n                main_label.setStyleSheet(f\"font-weight: bold; color: {main_color};\")\n\n            # Secondary info\n            secondary_text = []\n            score_text = (\n                f\"{ann.annotator}: {ann.score:.2f}\"\n                if ann.score is not None\n                else ann.annotator\n            )\n            secondary_text.append(score_text)\n            short_path = ann.file_path.stem[: self.max_name_length]\n            secondary_text.append(f\"&lt;span style='color:#666;'&gt;{short_path}&lt;/span&gt;\")\n\n            if secondary_text:\n                info_color = \"#888\" if not ann.visible else \"#444\"\n                info_label = QLabel(\"&lt;br&gt;\".join(secondary_text))\n                info_label.setStyleSheet(f\"color: {info_color}; font-size: 10px;\")\n                text_layout.addWidget(info_label)\n\n            text_layout.addStretch()\n            layout.addWidget(text_container)\n            layout.addStretch()\n\n            # Buttons\n            btn_container = QWidget()\n            btn_layout = QHBoxLayout(btn_container)\n\n            layerify_btn = QPushButton(\"\ud83d\udda8\")\n            layerify_btn.setFixedWidth(30)\n            layerify_btn.setToolTip(\"Make AnnotableLayer from annotation\")\n            layerify_btn.clicked.connect(lambda _, i=idx: self.layerify_annotation(i))\n            btn_layout.addWidget(layerify_btn)\n\n            vis_btn = QPushButton(\"\ud83d\udc40\" if ann.visible else \"\ud83d\udc41\ufe0f\")\n            vis_btn.setFixedWidth(30)\n            vis_btn.setCheckable(True)\n            vis_btn.setChecked(ann.visible)\n            vis_btn.setToolTip(\"Visible\" if ann.visible else \"Hidden\")\n            vis_btn.clicked.connect(lambda _, i=idx: self.toggle_visibility(i))\n            btn_layout.addWidget(vis_btn)\n\n            del_btn = QPushButton(\"\ud83d\uddd1\ufe0f\")\n            del_btn.setFixedWidth(30)\n            del_btn.setToolTip(\"Delete annotation\")\n            del_btn.clicked.connect(lambda _, i=idx: self.delete_annotation(i))\n            btn_layout.addWidget(del_btn)\n\n            layout.addWidget(btn_container)\n\n            item.setSizeHint(widget.sizeHint())\n            self.list_widget.setItemWidget(item, widget)\n        self.update()\n\n    def create_color_icon(self, color):\n        pixmap = QPixmap(16, 16)\n        pixmap.fill(color)\n        return QIcon(pixmap)\n\n    def on_annotation_selected(self, index):\n        if 0 &lt;= index &lt; len(self.layer.annotations):\n            ann = self.layer.annotations[index]\n            ann.selected = not ann.selected\n            # Set other annotations to not selected\n            for i, a in enumerate(self.layer.annotations):\n                if i != index:\n                    a.selected = False\n            self.layer.update()\n            self.update_list()\n\n    def delete_annotation(self, index):\n        if 0 &lt;= index &lt; len(self.layer.annotations):\n            logger.info(f\"Deleting annotation: {self.layer.annotations[index].label}\")\n            del self.layer.annotations[index]\n            self.layer.update()\n            self.update_list()\n            logger.info(\"Annotation deleted\")\n\n    def toggle_visibility(self, index):\n        if 0 &lt;= index &lt; len(self.layer.annotations):\n            ann = self.layer.annotations[index]\n            ann.visible = not ann.visible\n            self.layer.update()\n            self.update_list()\n            logger.info(f\"Annotation visibility toggled: {ann.label}, {ann.visible}\")\n\n    def layerify_annotation(self, index):\n        if 0 &lt;= index &lt; len(self.layer.annotations):\n            ann = self.layer.annotations[index]\n            logger.info(f\"Layerifying annotation: {ann.label}\")\n\n            self.update_list()\n            self.layer.layerify_annotation([ann])\n            self.layer.update()\n\n    def sizeHint(self):\n        \"\"\"Calculate the preferred size based on the content.\"\"\"\n        base_size = super().sizeHint()\n        content_width = self.list_widget.sizeHintForColumn(0) + 40  # Add padding\n        return QSize(max(base_size.width(), content_width), base_size.height())\n\n    def keyPressEvent(self, event):\n        key = event.key()\n        logger.info(f\"Key pressed in AnnotationList: {key}\")\n        if event.key() == Qt.Key_C and event.modifiers() == Qt.ControlModifier:\n            self.layer.copy_annotation()\n        elif event.key() == Qt.Key_V and event.modifiers() == Qt.ControlModifier:\n            self.layer.paste_annotation()\n        elif event.key() == Qt.Key_Delete:\n            self.delete_annotation(self.layer.selected_annotation_index)\n        else:\n            self.parentWidget().keyPressEvent(event)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.annotation_list.AnnotationList.sizeHint","title":"<code>sizeHint()</code>","text":"<p>Calculate the preferred size based on the content.</p> Source code in <code>imagebaker/list_views/annotation_list.py</code> <pre><code>def sizeHint(self):\n    \"\"\"Calculate the preferred size based on the content.\"\"\"\n    base_size = super().sizeHint()\n    content_width = self.list_widget.sizeHintForColumn(0) + 40  # Add padding\n    return QSize(max(base_size.width(), content_width), base_size.height())\n</code></pre>"},{"location":"api-reference/#canvas-list","title":"Canvas List","text":"<p>               Bases: <code>QDockWidget</code></p> Source code in <code>imagebaker/list_views/canvas_list.py</code> <pre><code>class CanvasList(QDockWidget):\n    canvasSelected = Signal(CanvasLayer)\n    canvasDeleted = Signal(CanvasLayer)\n    canvasAdded = Signal(CanvasLayer)\n\n    def __init__(self, canvases: list[CanvasLayer], parent=None):\n        \"\"\"\n        :param canvases: List of CanvasLayer objects to display.\n        \"\"\"\n        super().__init__(\"Canvas List\", parent)\n        self.canvases = canvases\n        self.current_page = 0\n        self.canvases_per_page = 10\n        self.init_ui()\n\n    def init_ui(self):\n        \"\"\"Initialize the UI for the canvas list panel.\"\"\"\n        logger.info(\"Initializing CanvasList\")\n        self.setMinimumWidth(150)\n        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)\n\n        widget = QWidget()\n        layout = QVBoxLayout(widget)\n\n        # Add \"Create New Canvas\" button\n        self.create_canvas_button = QPushButton(\"Create New Canvas\")\n        self.create_canvas_button.clicked.connect(self.create_new_canvas)\n        layout.addWidget(self.create_canvas_button)\n\n        # Canvas list widget\n        self.list_widget = QListWidget()\n        self.list_widget.itemClicked.connect(self.handle_item_clicked)\n        layout.addWidget(self.list_widget)\n        # set first item as selected\n        if len(self.canvases) &gt; 0:\n            self.list_widget.setCurrentRow(0)\n\n        # Pagination controls\n        pagination_layout = QHBoxLayout()\n        self.prev_page_btn = QPushButton(\"Prev\")\n        self.prev_page_btn.clicked.connect(self.show_prev_page)\n        self.next_page_btn = QPushButton(\"Next\")\n        self.next_page_btn.clicked.connect(self.show_next_page)\n        pagination_layout.addWidget(self.prev_page_btn)\n        pagination_layout.addWidget(self.next_page_btn)\n        layout.addLayout(pagination_layout)\n\n        # Pagination info\n        self.pagination_label = QLabel(\"Showing 0 of 0\")\n        layout.addWidget(self.pagination_label)\n\n        self.setWidget(widget)\n        self.setFeatures(\n            QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable\n        )\n\n        self.update_canvas_list()\n\n    def create_new_canvas(self):\n        \"\"\"Create a new canvas and emit the canvasAdded signal.\"\"\"\n        canvas_idx = len(self.canvases) + 1\n        default_name = f\"Canvas {canvas_idx}\"\n\n        # Show input dialog to ask for canvas name\n        canvas_name, ok = QInputDialog.getText(\n            self, \"New Canvas\", \"Enter canvas name:\", text=default_name\n        )\n\n        # If the user cancels or provides an empty name, use the default name\n        if not ok or not canvas_name.strip():\n            canvas_name = default_name\n\n        # Create the new canvas\n        new_canvas = CanvasLayer(parent=self.parent())\n        new_canvas.layer_name = canvas_name  # Assign the name to the canvas\n        self.canvases.append(new_canvas)  # Add the new canvas to the list\n        self.canvasAdded.emit(\n            new_canvas\n        )  # Emit the signal to notify about the new canvas\n        self.update_canvas_list()  # Refresh the canvas list\n\n    def show_next_page(self):\n        \"\"\"Show the next page of canvases.\"\"\"\n        if (self.current_page + 1) * self.canvases_per_page &lt; len(self.canvases):\n            self.current_page += 1\n            self.update_canvas_list()\n\n    def show_prev_page(self):\n        \"\"\"Show the previous page of canvases.\"\"\"\n        if self.current_page &gt; 0:\n            self.current_page -= 1\n            self.update_canvas_list()\n\n    def update_canvas_list(self):\n        \"\"\"Update the canvas list with pagination.\"\"\"\n        self.list_widget.clear()\n\n        canvases_list = list(self.canvases)\n\n        start_idx = self.current_page * self.canvases_per_page\n        end_idx = min(start_idx + self.canvases_per_page, len(canvases_list))\n\n        for idx, canvas in enumerate(canvases_list[start_idx:end_idx], start=start_idx):\n            item_widget = QWidget()\n            item_layout = QHBoxLayout(item_widget)\n            item_layout.setContentsMargins(5, 5, 5, 5)\n\n            # Thumbnail\n            thumbnail_label = QLabel()\n            thumbnail_pixmap = canvas.get_thumbnail().scaled(\n                50, 50, Qt.KeepAspectRatio, Qt.SmoothTransformation\n            )\n            thumbnail_label.setPixmap(thumbnail_pixmap)\n            item_layout.addWidget(thumbnail_label)\n\n            # Canvas name\n            canvas_name = getattr(canvas, \"layer_name\", f\"Canvas {idx + 1}\")\n            name_label = QLabel(canvas_name)\n            name_label.setStyleSheet(\"font-weight: bold;\")\n            item_layout.addWidget(name_label)\n\n            # Delete button\n            delete_button = QPushButton(\"Delete\")\n            delete_button.setStyleSheet(\n                \"background-color: red; color: white; font-weight: bold;\"\n            )\n            delete_button.clicked.connect(partial(self.delete_canvas, canvas))\n            item_layout.addWidget(delete_button)\n\n            item_layout.addStretch()\n\n            # Add the custom widget to the list\n            list_item = QListWidgetItem(self.list_widget)\n            list_item.setSizeHint(item_widget.sizeHint())\n            self.list_widget.addItem(list_item)\n            self.list_widget.setItemWidget(list_item, item_widget)\n\n            # Store metadata for the canvas\n            list_item.setData(Qt.UserRole, canvas)\n\n        # Select the first item by default if it exists\n        if self.list_widget.count() &gt; 0:\n            self.list_widget.setCurrentRow(0)\n            first_item = self.list_widget.item(0)\n            self.handle_item_clicked(first_item)\n\n        self.pagination_label.setText(\n            f\"Showing {start_idx + 1} to {end_idx} of {len(canvases_list)}\"\n        )\n        self.update()\n\n    def handle_item_clicked(self, item: QListWidgetItem):\n        \"\"\"Handle item click and emit the canvasSelected signal.\"\"\"\n        canvas = item.data(Qt.UserRole)\n        if canvas:\n            self.canvasSelected.emit(canvas)\n\n    def delete_canvas(self, canvas: CanvasLayer):\n        \"\"\"Delete a canvas from the list.\"\"\"\n        if canvas in self.canvases:\n            canvas.layers.clear()\n            logger.info(f\"Deleting canvas: {canvas.layer_name}\")\n            canvas.setVisible(False)\n            canvas.deleteLater()\n            self.canvases.remove(canvas)\n            self.canvasDeleted.emit(canvas)\n            self.update_canvas_list()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.canvas_list.CanvasList.create_new_canvas","title":"<code>create_new_canvas()</code>","text":"<p>Create a new canvas and emit the canvasAdded signal.</p> Source code in <code>imagebaker/list_views/canvas_list.py</code> <pre><code>def create_new_canvas(self):\n    \"\"\"Create a new canvas and emit the canvasAdded signal.\"\"\"\n    canvas_idx = len(self.canvases) + 1\n    default_name = f\"Canvas {canvas_idx}\"\n\n    # Show input dialog to ask for canvas name\n    canvas_name, ok = QInputDialog.getText(\n        self, \"New Canvas\", \"Enter canvas name:\", text=default_name\n    )\n\n    # If the user cancels or provides an empty name, use the default name\n    if not ok or not canvas_name.strip():\n        canvas_name = default_name\n\n    # Create the new canvas\n    new_canvas = CanvasLayer(parent=self.parent())\n    new_canvas.layer_name = canvas_name  # Assign the name to the canvas\n    self.canvases.append(new_canvas)  # Add the new canvas to the list\n    self.canvasAdded.emit(\n        new_canvas\n    )  # Emit the signal to notify about the new canvas\n    self.update_canvas_list()  # Refresh the canvas list\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.canvas_list.CanvasList.delete_canvas","title":"<code>delete_canvas(canvas)</code>","text":"<p>Delete a canvas from the list.</p> Source code in <code>imagebaker/list_views/canvas_list.py</code> <pre><code>def delete_canvas(self, canvas: CanvasLayer):\n    \"\"\"Delete a canvas from the list.\"\"\"\n    if canvas in self.canvases:\n        canvas.layers.clear()\n        logger.info(f\"Deleting canvas: {canvas.layer_name}\")\n        canvas.setVisible(False)\n        canvas.deleteLater()\n        self.canvases.remove(canvas)\n        self.canvasDeleted.emit(canvas)\n        self.update_canvas_list()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.canvas_list.CanvasList.handle_item_clicked","title":"<code>handle_item_clicked(item)</code>","text":"<p>Handle item click and emit the canvasSelected signal.</p> Source code in <code>imagebaker/list_views/canvas_list.py</code> <pre><code>def handle_item_clicked(self, item: QListWidgetItem):\n    \"\"\"Handle item click and emit the canvasSelected signal.\"\"\"\n    canvas = item.data(Qt.UserRole)\n    if canvas:\n        self.canvasSelected.emit(canvas)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.canvas_list.CanvasList.init_ui","title":"<code>init_ui()</code>","text":"<p>Initialize the UI for the canvas list panel.</p> Source code in <code>imagebaker/list_views/canvas_list.py</code> <pre><code>def init_ui(self):\n    \"\"\"Initialize the UI for the canvas list panel.\"\"\"\n    logger.info(\"Initializing CanvasList\")\n    self.setMinimumWidth(150)\n    self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)\n\n    widget = QWidget()\n    layout = QVBoxLayout(widget)\n\n    # Add \"Create New Canvas\" button\n    self.create_canvas_button = QPushButton(\"Create New Canvas\")\n    self.create_canvas_button.clicked.connect(self.create_new_canvas)\n    layout.addWidget(self.create_canvas_button)\n\n    # Canvas list widget\n    self.list_widget = QListWidget()\n    self.list_widget.itemClicked.connect(self.handle_item_clicked)\n    layout.addWidget(self.list_widget)\n    # set first item as selected\n    if len(self.canvases) &gt; 0:\n        self.list_widget.setCurrentRow(0)\n\n    # Pagination controls\n    pagination_layout = QHBoxLayout()\n    self.prev_page_btn = QPushButton(\"Prev\")\n    self.prev_page_btn.clicked.connect(self.show_prev_page)\n    self.next_page_btn = QPushButton(\"Next\")\n    self.next_page_btn.clicked.connect(self.show_next_page)\n    pagination_layout.addWidget(self.prev_page_btn)\n    pagination_layout.addWidget(self.next_page_btn)\n    layout.addLayout(pagination_layout)\n\n    # Pagination info\n    self.pagination_label = QLabel(\"Showing 0 of 0\")\n    layout.addWidget(self.pagination_label)\n\n    self.setWidget(widget)\n    self.setFeatures(\n        QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable\n    )\n\n    self.update_canvas_list()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.canvas_list.CanvasList.show_next_page","title":"<code>show_next_page()</code>","text":"<p>Show the next page of canvases.</p> Source code in <code>imagebaker/list_views/canvas_list.py</code> <pre><code>def show_next_page(self):\n    \"\"\"Show the next page of canvases.\"\"\"\n    if (self.current_page + 1) * self.canvases_per_page &lt; len(self.canvases):\n        self.current_page += 1\n        self.update_canvas_list()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.canvas_list.CanvasList.show_prev_page","title":"<code>show_prev_page()</code>","text":"<p>Show the previous page of canvases.</p> Source code in <code>imagebaker/list_views/canvas_list.py</code> <pre><code>def show_prev_page(self):\n    \"\"\"Show the previous page of canvases.\"\"\"\n    if self.current_page &gt; 0:\n        self.current_page -= 1\n        self.update_canvas_list()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.canvas_list.CanvasList.update_canvas_list","title":"<code>update_canvas_list()</code>","text":"<p>Update the canvas list with pagination.</p> Source code in <code>imagebaker/list_views/canvas_list.py</code> <pre><code>def update_canvas_list(self):\n    \"\"\"Update the canvas list with pagination.\"\"\"\n    self.list_widget.clear()\n\n    canvases_list = list(self.canvases)\n\n    start_idx = self.current_page * self.canvases_per_page\n    end_idx = min(start_idx + self.canvases_per_page, len(canvases_list))\n\n    for idx, canvas in enumerate(canvases_list[start_idx:end_idx], start=start_idx):\n        item_widget = QWidget()\n        item_layout = QHBoxLayout(item_widget)\n        item_layout.setContentsMargins(5, 5, 5, 5)\n\n        # Thumbnail\n        thumbnail_label = QLabel()\n        thumbnail_pixmap = canvas.get_thumbnail().scaled(\n            50, 50, Qt.KeepAspectRatio, Qt.SmoothTransformation\n        )\n        thumbnail_label.setPixmap(thumbnail_pixmap)\n        item_layout.addWidget(thumbnail_label)\n\n        # Canvas name\n        canvas_name = getattr(canvas, \"layer_name\", f\"Canvas {idx + 1}\")\n        name_label = QLabel(canvas_name)\n        name_label.setStyleSheet(\"font-weight: bold;\")\n        item_layout.addWidget(name_label)\n\n        # Delete button\n        delete_button = QPushButton(\"Delete\")\n        delete_button.setStyleSheet(\n            \"background-color: red; color: white; font-weight: bold;\"\n        )\n        delete_button.clicked.connect(partial(self.delete_canvas, canvas))\n        item_layout.addWidget(delete_button)\n\n        item_layout.addStretch()\n\n        # Add the custom widget to the list\n        list_item = QListWidgetItem(self.list_widget)\n        list_item.setSizeHint(item_widget.sizeHint())\n        self.list_widget.addItem(list_item)\n        self.list_widget.setItemWidget(list_item, item_widget)\n\n        # Store metadata for the canvas\n        list_item.setData(Qt.UserRole, canvas)\n\n    # Select the first item by default if it exists\n    if self.list_widget.count() &gt; 0:\n        self.list_widget.setCurrentRow(0)\n        first_item = self.list_widget.item(0)\n        self.handle_item_clicked(first_item)\n\n    self.pagination_label.setText(\n        f\"Showing {start_idx + 1} to {end_idx} of {len(canvases_list)}\"\n    )\n    self.update()\n</code></pre>"},{"location":"api-reference/#layer-list","title":"Layer List","text":"<p>               Bases: <code>QDockWidget</code></p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>class LayerList(QDockWidget):\n\n    layersSelected = Signal(list)\n    messageSignal = Signal(str)\n\n    def __init__(\n        self,\n        canvas: Canvas,\n        layer_settings: LayerSettings,\n        parent=None,\n    ):\n        super().__init__(\"Layers\", parent)\n        self.canvas = canvas\n        self.layers: list[BaseLayer] = []\n        self.layer_settings = layer_settings\n        self.init_ui()\n\n    def init_ui(self):\n        logger.info(\"Initializing LayerList\")\n        main_widget = QWidget()\n        main_layout = QVBoxLayout(main_widget)\n        self.setMinimumWidth(150)\n\n        # Create list widget for layers\n        self.list_widget = QListWidget()\n        self.list_widget.setSelectionMode(QListWidget.MultiSelection)\n\n        # Enable drag and drop in the list widget\n        self.list_widget.setDragEnabled(True)\n        self.list_widget.setAcceptDrops(True)\n        self.list_widget.setDropIndicatorShown(True)\n        self.list_widget.setDragDropMode(QAbstractItemView.InternalMove)\n\n        # Connect signals\n        self.list_widget.itemClicked.connect(self.on_item_clicked)\n        self.list_widget.model().rowsMoved.connect(self.on_rows_moved)\n        self.list_widget.keyPressEvent = self.list_key_press_event\n\n        # Add list and buttons to main layout\n        main_layout.addWidget(self.list_widget)\n        # main_layout.addWidget(delete_button)\n\n        # Set main widget\n        self.setWidget(main_widget)\n        self.setFeatures(\n            QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable\n        )\n\n    def clear_layers(self):\n        \"\"\"Clear all layers from the list\"\"\"\n        self.layers.clear()\n        self.update_list()\n\n    def on_rows_moved(self, parent, start, end, destination, row):\n        \"\"\"Handle rows being moved in the list widget via drag and drop\"\"\"\n        # Calculate the source and destination indices\n        source_index = start\n        dest_index = row\n\n        # If moving down, we need to adjust the destination index\n        if dest_index &gt; source_index:\n            dest_index -= 1\n\n        # Reorder the layers accordingly\n        if 0 &lt;= source_index &lt; len(self.layers) and 0 &lt;= dest_index &lt; len(self.layers):\n            # Move the layer in our internal list\n            layer = self.layers.pop(source_index)\n            self.layers.insert(dest_index, layer)\n            layer.order = dest_index\n\n            # Update the canvas with the new layer order\n            self.canvas.layers = self.layers\n            self.canvas.update()\n\n            # Update the UI\n            self.update_list()\n            logger.info(\n                f\"BaseLayer: {layer.layer_name} moved from {source_index} to {dest_index}\"\n            )\n\n    def update_list(self):\n        \"\"\"Update the list widget with current layers\"\"\"\n        # Remember current selection\n        selected_row = self.list_widget.currentRow()\n\n        # Clear the list\n        self.list_widget.clear()\n        selected_layer = None\n\n        if not self.canvas:\n            # No canvas, show dialog and return\n            logger.warning(\"No canvas found\")\n            QDialog.critical(\n                self,\n                \"Error\",\n                \"No canvas found. Please create a canvas first.\",\n                QDialog.StandardButton.Ok,\n            )\n\n        # Add all layers to the list\n        for idx, layer in enumerate(self.layers):\n            if layer.selected:\n                selected_layer = layer\n\n            # Get annotation info\n            ann = layer.annotations[0]\n            thumbnail = layer.get_thumbnail(annotation=ann)\n\n            # Create widget for this layer item\n            widget = QWidget()\n            layout = QHBoxLayout(widget)\n            layout.setContentsMargins(5, 5, 5, 5)\n\n            # Add thumbnail\n            thumbnail_label = QLabel()\n            thumbnail_label.setPixmap(thumbnail)\n            layout.addWidget(thumbnail_label)\n\n            # Add text info\n            text_container = QWidget()\n            text_layout = QVBoxLayout(text_container)\n\n            # Main label\n            main_label = QLabel(ann.label)\n            text_color = \"#666\" if not layer.visible else \"black\"\n            if layer.selected:\n                text_color = \"blue\"\n            main_label.setStyleSheet(f\"font-weight: bold; color: {text_color};\")\n            text_layout.addWidget(main_label)\n\n            # Add secondary info if available\n            secondary_text = []\n            score_text = (\n                f\"{ann.annotator}: {ann.score:.2f}\"\n                if ann.score is not None\n                else ann.annotator\n            )\n            secondary_text.append(score_text)\n            short_path = ann.file_path.stem\n            secondary_text.append(f\"&lt;span style='color:#666;'&gt;{short_path}&lt;/span&gt;\")\n\n            if secondary_text:\n                info_color = \"#888\" if not layer.visible else \"#444\"\n                info_label = QLabel(\"&lt;br&gt;\".join(secondary_text))\n                info_label.setStyleSheet(f\"color: {info_color}; font-size: 10px;\")\n                info_label.setTextFormat(Qt.RichText)\n                text_layout.addWidget(info_label)\n\n            text_layout.addStretch()\n            layout.addWidget(text_container)\n            layout.addStretch()\n\n            # Add control buttons\n            btn_container = QWidget()\n            btn_layout = QHBoxLayout(btn_container)\n\n            # Visibility button\n            vis_btn = QPushButton(\"\ud83d\udc40\" if layer.visible else \"\ud83d\udc41\ufe0f\")\n            vis_btn.setMaximumWidth(self.canvas.config.normal_draw_config.button_width)\n            vis_btn.setCheckable(True)\n            vis_btn.setChecked(layer.visible)\n            vis_btn.setToolTip(\"Visible\" if layer.visible else \"Hidden\")\n\n            # Store layer index for button callbacks\n            vis_btn.setProperty(\"layer_index\", idx)\n            vis_btn.clicked.connect(\n                lambda checked, btn=vis_btn: self.toggle_visibility(\n                    btn.property(\"layer_index\")\n                )\n            )\n            btn_layout.addWidget(vis_btn)\n\n            # Delete button\n            del_btn = QPushButton(\"\ud83d\uddd1\ufe0f\")\n            del_btn.setMaximumWidth(self.canvas.config.normal_draw_config.button_width)\n            del_btn.setToolTip(\"Delete annotation\")\n            del_btn.setProperty(\"layer_index\", idx)\n            del_btn.clicked.connect(\n                lambda checked=False, idx=idx: self.confirm_delete_layer(idx)\n            )\n            btn_layout.addWidget(del_btn)\n\n            # a checkbox to toggle layer annotation export\n            export_checkbox = QCheckBox()\n            export_checkbox.setChecked(layer.allow_annotation_export)\n            export_checkbox.setToolTip(\"Toggle annotation export\")\n            export_checkbox.setProperty(\"layer_index\", idx)\n            export_checkbox.stateChanged.connect(\n                lambda state, idx=idx: self.toggle_annotation_export(idx, state)\n            )\n            btn_layout.addWidget(export_checkbox)\n\n            layout.addWidget(btn_container)\n\n            # Add item to list widget\n            item = QListWidgetItem()\n            item.setSizeHint(widget.sizeHint())\n            self.list_widget.addItem(item)\n            self.list_widget.setItemWidget(item, widget)\n\n        # Restore selection if possible\n        if selected_row &gt;= 0 and selected_row &lt; self.list_widget.count():\n            self.list_widget.setCurrentRow(selected_row)\n\n        # Update layer settings panel\n        if selected_layer:\n            self.layer_settings.set_selected_layer(selected_layer)\n        else:\n            self.layer_settings.set_selected_layer(None)\n        self.update()\n\n    def toggle_annotation_export(self, index, state):\n        \"\"\"Toggle annotation export for a layer by index\"\"\"\n        if 0 &lt;= index &lt; len(self.layers):\n            layer = self.layers[index]\n            layer.allow_annotation_export = not layer.allow_annotation_export\n            logger.info(\n                f\"BaseLayer annotation export toggled: {layer.layer_name}, {layer.allow_annotation_export}\"\n            )\n            self.update_list()\n            layer.update()\n            self.canvas.update()\n\n    def on_item_clicked(self, item):\n        \"\"\"Handle layer selection with:\n        - Left click only: Toggle clicked layer and deselect others\n        - Ctrl+Left click: Toggle clicked layer only (keep others selected)\"\"\"\n        modifiers = QApplication.keyboardModifiers()\n        current_row = self.list_widget.row(item)\n\n        if 0 &lt;= current_row &lt; len(self.layers):\n            current_layer = self.layers[current_row]\n\n            if modifiers &amp; Qt.ControlModifier:\n                # Ctrl+Click: Toggle just this layer's selection\n                current_layer.selected = not current_layer.selected\n                selected_layers = [layer for layer in self.layers if layer.selected]\n            else:\n                # Normal click: Toggle this layer and deselect all others\n                was_selected = current_layer.selected\n                for layer in self.layers:\n                    layer.selected = False\n                current_layer.selected = not was_selected  # Toggle\n                selected_layers = [current_layer] if current_layer.selected else []\n\n            # Update UI\n            self.layersSelected.emit(selected_layers)\n            self.layer_settings.set_selected_layer(\n                selected_layers[0] if selected_layers else None\n            )\n            self.canvas.update()\n            self.update_list()\n\n            logger.info(f\"Selected layers: {[l.layer_name for l in selected_layers]}\")\n\n    def on_layer_selected(self, indices):\n        \"\"\"Select multiple layers by indices\"\"\"\n        selected_layers = []\n        for i, layer in enumerate(self.layers):\n            if i in indices:\n                layer.selected = True\n                selected_layers.append(layer)\n            else:\n                layer.selected = False\n\n        # Emit the selected layers\n        self.layersSelected.emit(selected_layers)\n\n        # Update UI\n        self.layer_settings.set_selected_layer(\n            selected_layers[0] if selected_layers else None\n        )\n        self.canvas.update()\n        self.update_list()\n\n    def confirm_delete_layer(self, index):\n        \"\"\"Show confirmation dialog before deleting a layer\"\"\"\n        if 0 &lt;= index &lt; len(self.layers):\n            msg_box = QMessageBox()\n            msg_box.setIcon(QMessageBox.Question)\n            msg_box.setWindowTitle(\"Confirm Deletion\")\n            msg_box.setText(\"Are you sure you want to delete this layer?\")\n            msg_box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\n            msg_box.setDefaultButton(QMessageBox.No)\n\n            result = msg_box.exec_()\n            if result == QMessageBox.Yes:\n                self.delete_layer(index)\n\n    def list_key_press_event(self, event):\n        \"\"\"Handle key press events in the list widget\"\"\"\n        if event.key() == Qt.Key_Delete:\n            current_row = self.list_widget.currentRow()\n            if current_row &gt;= 0:\n                self.confirm_delete_layer(current_row)\n        else:\n            # Pass other key events to the parent class\n            QListWidget.keyPressEvent(self.list_widget, event)\n\n    def delete_selected_layer(self):\n        \"\"\"Delete the currently selected layer with confirmation\"\"\"\n        current_row = self.list_widget.currentRow()\n        if current_row &gt;= 0:\n            self.confirm_delete_layer(current_row)\n\n    def delete_layer(self, index):\n        \"\"\"Delete a layer by index\"\"\"\n        if 0 &lt;= index &lt; len(self.layers):\n            logger.info(f\"Deleting layer: {self.layers[index].layer_name}\")\n            del self.layers[index]\n            self.update_list()\n            self.canvas.layers = self.layers\n            self.canvas.update()\n            logger.info(f\"BaseLayer deleted: {index}\")\n\n    def toggle_visibility(self, index):\n        \"\"\"Toggle visibility of a layer by index\"\"\"\n        if 0 &lt;= index &lt; len(self.layers):\n            layer = self.layers[index]\n            layer.visible = not layer.visible\n            logger.info(\n                f\"BaseLayer visibility toggled: {layer.layer_name}, {layer.visible}\"\n            )\n            self.update_list()\n            self.canvas.update()\n\n    def add_layer(self, layer: BaseLayer = None):\n        \"\"\"Add a new layer to the list\"\"\"\n        if layer is None:\n            return\n        self.layers.append(layer)\n        self.update_list()\n        self.canvas.layers = self.layers\n        # self.canvas.update()\n\n    def select_layer(self, layer):\n        \"\"\"Select a specific layer\"\"\"\n        logger.info(f\"Selecting layer: {layer.layer_name}\")\n        self.update_list()\n\n    def get_selected_layers(self):\n        \"\"\"Returns list of currently selected BaseLayer objects\"\"\"\n        selected_items = self.list_widget.selectedItems()\n        return [\n            self.layers[self.list_widget.row(item)]\n            for item in selected_items\n            if 0 &lt;= self.list_widget.row(item) &lt; len(self.layers)\n        ]\n\n    def keyPressEvent(self, event):\n        \"\"\"Handle key presses.\"\"\"\n        self.selected_layer = self.canvas.selected_layer\n        if self.selected_layer is None:\n            return\n        if event.key() == Qt.Key_Delete:\n            self.canvas.delete_layer()\n        elif event.key() == Qt.Key_Escape:\n            self.canvas.selected_layer = None\n        elif event.modifiers() &amp; Qt.ControlModifier and event.key() == Qt.Key_C:\n            self.canvas.copy_layer()\n        elif event.modifiers() &amp; Qt.ControlModifier and event.key() == Qt.Key_V:\n            self.canvas.paste_layer()\n        elif event.modifiers() &amp; Qt.ControlModifier and event.key() == Qt.Key_Z:\n            # self.selected_layer.undo()\n            self.messageSignal.emit(\"Undo not implemented yet\")\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.add_layer","title":"<code>add_layer(layer=None)</code>","text":"<p>Add a new layer to the list</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def add_layer(self, layer: BaseLayer = None):\n    \"\"\"Add a new layer to the list\"\"\"\n    if layer is None:\n        return\n    self.layers.append(layer)\n    self.update_list()\n    self.canvas.layers = self.layers\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.clear_layers","title":"<code>clear_layers()</code>","text":"<p>Clear all layers from the list</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def clear_layers(self):\n    \"\"\"Clear all layers from the list\"\"\"\n    self.layers.clear()\n    self.update_list()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.confirm_delete_layer","title":"<code>confirm_delete_layer(index)</code>","text":"<p>Show confirmation dialog before deleting a layer</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def confirm_delete_layer(self, index):\n    \"\"\"Show confirmation dialog before deleting a layer\"\"\"\n    if 0 &lt;= index &lt; len(self.layers):\n        msg_box = QMessageBox()\n        msg_box.setIcon(QMessageBox.Question)\n        msg_box.setWindowTitle(\"Confirm Deletion\")\n        msg_box.setText(\"Are you sure you want to delete this layer?\")\n        msg_box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\n        msg_box.setDefaultButton(QMessageBox.No)\n\n        result = msg_box.exec_()\n        if result == QMessageBox.Yes:\n            self.delete_layer(index)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.delete_layer","title":"<code>delete_layer(index)</code>","text":"<p>Delete a layer by index</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def delete_layer(self, index):\n    \"\"\"Delete a layer by index\"\"\"\n    if 0 &lt;= index &lt; len(self.layers):\n        logger.info(f\"Deleting layer: {self.layers[index].layer_name}\")\n        del self.layers[index]\n        self.update_list()\n        self.canvas.layers = self.layers\n        self.canvas.update()\n        logger.info(f\"BaseLayer deleted: {index}\")\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.delete_selected_layer","title":"<code>delete_selected_layer()</code>","text":"<p>Delete the currently selected layer with confirmation</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def delete_selected_layer(self):\n    \"\"\"Delete the currently selected layer with confirmation\"\"\"\n    current_row = self.list_widget.currentRow()\n    if current_row &gt;= 0:\n        self.confirm_delete_layer(current_row)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.get_selected_layers","title":"<code>get_selected_layers()</code>","text":"<p>Returns list of currently selected BaseLayer objects</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def get_selected_layers(self):\n    \"\"\"Returns list of currently selected BaseLayer objects\"\"\"\n    selected_items = self.list_widget.selectedItems()\n    return [\n        self.layers[self.list_widget.row(item)]\n        for item in selected_items\n        if 0 &lt;= self.list_widget.row(item) &lt; len(self.layers)\n    ]\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.keyPressEvent","title":"<code>keyPressEvent(event)</code>","text":"<p>Handle key presses.</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def keyPressEvent(self, event):\n    \"\"\"Handle key presses.\"\"\"\n    self.selected_layer = self.canvas.selected_layer\n    if self.selected_layer is None:\n        return\n    if event.key() == Qt.Key_Delete:\n        self.canvas.delete_layer()\n    elif event.key() == Qt.Key_Escape:\n        self.canvas.selected_layer = None\n    elif event.modifiers() &amp; Qt.ControlModifier and event.key() == Qt.Key_C:\n        self.canvas.copy_layer()\n    elif event.modifiers() &amp; Qt.ControlModifier and event.key() == Qt.Key_V:\n        self.canvas.paste_layer()\n    elif event.modifiers() &amp; Qt.ControlModifier and event.key() == Qt.Key_Z:\n        # self.selected_layer.undo()\n        self.messageSignal.emit(\"Undo not implemented yet\")\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.list_key_press_event","title":"<code>list_key_press_event(event)</code>","text":"<p>Handle key press events in the list widget</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def list_key_press_event(self, event):\n    \"\"\"Handle key press events in the list widget\"\"\"\n    if event.key() == Qt.Key_Delete:\n        current_row = self.list_widget.currentRow()\n        if current_row &gt;= 0:\n            self.confirm_delete_layer(current_row)\n    else:\n        # Pass other key events to the parent class\n        QListWidget.keyPressEvent(self.list_widget, event)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.on_item_clicked","title":"<code>on_item_clicked(item)</code>","text":"<p>Handle layer selection with: - Left click only: Toggle clicked layer and deselect others - Ctrl+Left click: Toggle clicked layer only (keep others selected)</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def on_item_clicked(self, item):\n    \"\"\"Handle layer selection with:\n    - Left click only: Toggle clicked layer and deselect others\n    - Ctrl+Left click: Toggle clicked layer only (keep others selected)\"\"\"\n    modifiers = QApplication.keyboardModifiers()\n    current_row = self.list_widget.row(item)\n\n    if 0 &lt;= current_row &lt; len(self.layers):\n        current_layer = self.layers[current_row]\n\n        if modifiers &amp; Qt.ControlModifier:\n            # Ctrl+Click: Toggle just this layer's selection\n            current_layer.selected = not current_layer.selected\n            selected_layers = [layer for layer in self.layers if layer.selected]\n        else:\n            # Normal click: Toggle this layer and deselect all others\n            was_selected = current_layer.selected\n            for layer in self.layers:\n                layer.selected = False\n            current_layer.selected = not was_selected  # Toggle\n            selected_layers = [current_layer] if current_layer.selected else []\n\n        # Update UI\n        self.layersSelected.emit(selected_layers)\n        self.layer_settings.set_selected_layer(\n            selected_layers[0] if selected_layers else None\n        )\n        self.canvas.update()\n        self.update_list()\n\n        logger.info(f\"Selected layers: {[l.layer_name for l in selected_layers]}\")\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.on_layer_selected","title":"<code>on_layer_selected(indices)</code>","text":"<p>Select multiple layers by indices</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def on_layer_selected(self, indices):\n    \"\"\"Select multiple layers by indices\"\"\"\n    selected_layers = []\n    for i, layer in enumerate(self.layers):\n        if i in indices:\n            layer.selected = True\n            selected_layers.append(layer)\n        else:\n            layer.selected = False\n\n    # Emit the selected layers\n    self.layersSelected.emit(selected_layers)\n\n    # Update UI\n    self.layer_settings.set_selected_layer(\n        selected_layers[0] if selected_layers else None\n    )\n    self.canvas.update()\n    self.update_list()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.on_rows_moved","title":"<code>on_rows_moved(parent, start, end, destination, row)</code>","text":"<p>Handle rows being moved in the list widget via drag and drop</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def on_rows_moved(self, parent, start, end, destination, row):\n    \"\"\"Handle rows being moved in the list widget via drag and drop\"\"\"\n    # Calculate the source and destination indices\n    source_index = start\n    dest_index = row\n\n    # If moving down, we need to adjust the destination index\n    if dest_index &gt; source_index:\n        dest_index -= 1\n\n    # Reorder the layers accordingly\n    if 0 &lt;= source_index &lt; len(self.layers) and 0 &lt;= dest_index &lt; len(self.layers):\n        # Move the layer in our internal list\n        layer = self.layers.pop(source_index)\n        self.layers.insert(dest_index, layer)\n        layer.order = dest_index\n\n        # Update the canvas with the new layer order\n        self.canvas.layers = self.layers\n        self.canvas.update()\n\n        # Update the UI\n        self.update_list()\n        logger.info(\n            f\"BaseLayer: {layer.layer_name} moved from {source_index} to {dest_index}\"\n        )\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.select_layer","title":"<code>select_layer(layer)</code>","text":"<p>Select a specific layer</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def select_layer(self, layer):\n    \"\"\"Select a specific layer\"\"\"\n    logger.info(f\"Selecting layer: {layer.layer_name}\")\n    self.update_list()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.toggle_annotation_export","title":"<code>toggle_annotation_export(index, state)</code>","text":"<p>Toggle annotation export for a layer by index</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def toggle_annotation_export(self, index, state):\n    \"\"\"Toggle annotation export for a layer by index\"\"\"\n    if 0 &lt;= index &lt; len(self.layers):\n        layer = self.layers[index]\n        layer.allow_annotation_export = not layer.allow_annotation_export\n        logger.info(\n            f\"BaseLayer annotation export toggled: {layer.layer_name}, {layer.allow_annotation_export}\"\n        )\n        self.update_list()\n        layer.update()\n        self.canvas.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.toggle_visibility","title":"<code>toggle_visibility(index)</code>","text":"<p>Toggle visibility of a layer by index</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def toggle_visibility(self, index):\n    \"\"\"Toggle visibility of a layer by index\"\"\"\n    if 0 &lt;= index &lt; len(self.layers):\n        layer = self.layers[index]\n        layer.visible = not layer.visible\n        logger.info(\n            f\"BaseLayer visibility toggled: {layer.layer_name}, {layer.visible}\"\n        )\n        self.update_list()\n        self.canvas.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_list.LayerList.update_list","title":"<code>update_list()</code>","text":"<p>Update the list widget with current layers</p> Source code in <code>imagebaker/list_views/layer_list.py</code> <pre><code>def update_list(self):\n    \"\"\"Update the list widget with current layers\"\"\"\n    # Remember current selection\n    selected_row = self.list_widget.currentRow()\n\n    # Clear the list\n    self.list_widget.clear()\n    selected_layer = None\n\n    if not self.canvas:\n        # No canvas, show dialog and return\n        logger.warning(\"No canvas found\")\n        QDialog.critical(\n            self,\n            \"Error\",\n            \"No canvas found. Please create a canvas first.\",\n            QDialog.StandardButton.Ok,\n        )\n\n    # Add all layers to the list\n    for idx, layer in enumerate(self.layers):\n        if layer.selected:\n            selected_layer = layer\n\n        # Get annotation info\n        ann = layer.annotations[0]\n        thumbnail = layer.get_thumbnail(annotation=ann)\n\n        # Create widget for this layer item\n        widget = QWidget()\n        layout = QHBoxLayout(widget)\n        layout.setContentsMargins(5, 5, 5, 5)\n\n        # Add thumbnail\n        thumbnail_label = QLabel()\n        thumbnail_label.setPixmap(thumbnail)\n        layout.addWidget(thumbnail_label)\n\n        # Add text info\n        text_container = QWidget()\n        text_layout = QVBoxLayout(text_container)\n\n        # Main label\n        main_label = QLabel(ann.label)\n        text_color = \"#666\" if not layer.visible else \"black\"\n        if layer.selected:\n            text_color = \"blue\"\n        main_label.setStyleSheet(f\"font-weight: bold; color: {text_color};\")\n        text_layout.addWidget(main_label)\n\n        # Add secondary info if available\n        secondary_text = []\n        score_text = (\n            f\"{ann.annotator}: {ann.score:.2f}\"\n            if ann.score is not None\n            else ann.annotator\n        )\n        secondary_text.append(score_text)\n        short_path = ann.file_path.stem\n        secondary_text.append(f\"&lt;span style='color:#666;'&gt;{short_path}&lt;/span&gt;\")\n\n        if secondary_text:\n            info_color = \"#888\" if not layer.visible else \"#444\"\n            info_label = QLabel(\"&lt;br&gt;\".join(secondary_text))\n            info_label.setStyleSheet(f\"color: {info_color}; font-size: 10px;\")\n            info_label.setTextFormat(Qt.RichText)\n            text_layout.addWidget(info_label)\n\n        text_layout.addStretch()\n        layout.addWidget(text_container)\n        layout.addStretch()\n\n        # Add control buttons\n        btn_container = QWidget()\n        btn_layout = QHBoxLayout(btn_container)\n\n        # Visibility button\n        vis_btn = QPushButton(\"\ud83d\udc40\" if layer.visible else \"\ud83d\udc41\ufe0f\")\n        vis_btn.setMaximumWidth(self.canvas.config.normal_draw_config.button_width)\n        vis_btn.setCheckable(True)\n        vis_btn.setChecked(layer.visible)\n        vis_btn.setToolTip(\"Visible\" if layer.visible else \"Hidden\")\n\n        # Store layer index for button callbacks\n        vis_btn.setProperty(\"layer_index\", idx)\n        vis_btn.clicked.connect(\n            lambda checked, btn=vis_btn: self.toggle_visibility(\n                btn.property(\"layer_index\")\n            )\n        )\n        btn_layout.addWidget(vis_btn)\n\n        # Delete button\n        del_btn = QPushButton(\"\ud83d\uddd1\ufe0f\")\n        del_btn.setMaximumWidth(self.canvas.config.normal_draw_config.button_width)\n        del_btn.setToolTip(\"Delete annotation\")\n        del_btn.setProperty(\"layer_index\", idx)\n        del_btn.clicked.connect(\n            lambda checked=False, idx=idx: self.confirm_delete_layer(idx)\n        )\n        btn_layout.addWidget(del_btn)\n\n        # a checkbox to toggle layer annotation export\n        export_checkbox = QCheckBox()\n        export_checkbox.setChecked(layer.allow_annotation_export)\n        export_checkbox.setToolTip(\"Toggle annotation export\")\n        export_checkbox.setProperty(\"layer_index\", idx)\n        export_checkbox.stateChanged.connect(\n            lambda state, idx=idx: self.toggle_annotation_export(idx, state)\n        )\n        btn_layout.addWidget(export_checkbox)\n\n        layout.addWidget(btn_container)\n\n        # Add item to list widget\n        item = QListWidgetItem()\n        item.setSizeHint(widget.sizeHint())\n        self.list_widget.addItem(item)\n        self.list_widget.setItemWidget(item, widget)\n\n    # Restore selection if possible\n    if selected_row &gt;= 0 and selected_row &lt; self.list_widget.count():\n        self.list_widget.setCurrentRow(selected_row)\n\n    # Update layer settings panel\n    if selected_layer:\n        self.layer_settings.set_selected_layer(selected_layer)\n    else:\n        self.layer_settings.set_selected_layer(None)\n    self.update()\n</code></pre>"},{"location":"api-reference/#layer-settings","title":"Layer Settings","text":"<p>               Bases: <code>QDockWidget</code></p> Source code in <code>imagebaker/list_views/layer_settings.py</code> <pre><code>class LayerSettings(QDockWidget):\n    layerState = Signal(LayerState)\n    messageSignal = Signal(str)\n\n    def __init__(\n        self,\n        parent=None,\n        max_xpos=1000,\n        max_ypos=1000,\n        max_scale=100,\n        max_edge_width=10,\n    ):\n        super().__init__(\"BaseLayer Settings\", parent)\n        self.selected_layer: BaseLayer = None\n\n        self._disable_updates = False\n        self.last_updated_time = 0\n        self.max_xpos = max_xpos\n        self.max_ypos = max_ypos\n        self.max_scale = max_scale\n        self.max_edge_width = max_edge_width\n        self.init_ui()\n        self.setFeatures(\n            QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable\n        )\n        self.update_sliders()\n\n    def init_ui(self):\n        \"\"\"Initialize the UI elements.\"\"\"\n        logger.info(\"Initializing LayerSettings\")\n        self.widget = QWidget()\n        self.setWidget(self.widget)\n        self.main_layout = QVBoxLayout(self.widget)\n        self.main_layout.setContentsMargins(10, 10, 10, 10)  # Add some padding\n        self.main_layout.setSpacing(10)\n\n        # BaseLayer layer_name label\n        self.layer_name_label = QLabel(\"No BaseLayer Selected\")\n        self.layer_name_label.setAlignment(Qt.AlignCenter)\n        self.layer_name_label.setStyleSheet(\"font-weight: bold; font-size: 14px;\")\n        self.main_layout.addWidget(self.layer_name_label)\n\n        # Opacity slider\n        self.opacity_slider = self.create_slider(\"Opacity:\", 0, 255, 255, 1)\n        self.main_layout.addWidget(self.opacity_slider[\"widget\"])\n        self.x_slider = self.create_slider(\"X:\", -self.max_xpos, self.max_xpos, 0, 1)\n        self.main_layout.addWidget(self.x_slider[\"widget\"])\n        self.y_slider = self.create_slider(\"Y:\", -self.max_ypos, self.max_ypos, 0, 1)\n        self.main_layout.addWidget(self.y_slider[\"widget\"])\n        self.scale_x_slider = self.create_slider(\n            \"Scale X:\", -self.max_scale, self.max_scale, 100, 100\n        )  # 1-500 becomes 0.01-5.0\n        self.main_layout.addWidget(self.scale_x_slider[\"widget\"])\n        self.scale_y_slider = self.create_slider(\n            \"Scale Y:\", -self.max_scale, self.max_scale, 100, 100\n        )\n        self.main_layout.addWidget(self.scale_y_slider[\"widget\"])\n        self.rotation_slider = self.create_slider(\"Rotation:\", 0, 360, 0, 1)\n        self.main_layout.addWidget(self.rotation_slider[\"widget\"])\n        self.edge_opacity_slider = self.create_slider(\"Edge Opacity:\", 0, 255, 255, 1)\n        self.main_layout.addWidget(self.edge_opacity_slider[\"widget\"])\n        self.edge_width_slider = self.create_slider(\n            \"Edge Width:\", 0, self.max_edge_width, 5, 1\n        )\n        self.main_layout.addWidget(self.edge_width_slider[\"widget\"])\n\n        # Add stretch to push content to the top\n        self.main_layout.addStretch()\n\n        # Ensure the dock widget resizes properly\n        self.setMinimumWidth(250)  # Minimum width for usability\n        self.widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n\n    def create_slider(self, label, min_val, max_val, default, scale_factor=1):\n        \"\"\"Create a slider with a label and value display.\"\"\"\n        container = QWidget()\n        layout = QHBoxLayout(container)\n        layout.setContentsMargins(0, 0, 0, 0)  # Remove inner margins\n\n        # Label\n        lbl = QLabel(label)\n        lbl.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\n        # Slider\n        slider = QSlider(Qt.Horizontal)\n        slider.setRange(min_val, max_val)\n        slider.setValue(default)\n        slider.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n\n        # Value label\n        value_lbl = QLabel(f\"{default / scale_factor:.1f}\")\n        value_lbl.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\n        # Connect slider to value label (still updates during drag)\n        slider.valueChanged.connect(\n            lambda v: value_lbl.setText(f\"{v / scale_factor:.1f}\")\n        )\n\n        # Only update layer on slider release\n        slider.sliderReleased.connect(self.on_slider_released)\n\n        # Add widgets to layout\n        layout.addWidget(lbl)\n        layout.addWidget(slider)\n        layout.addWidget(value_lbl)\n\n        return {\n            \"widget\": container,\n            \"slider\": slider,\n            \"label\": value_lbl,\n            \"scale_factor\": scale_factor,\n        }\n\n    def on_slider_released(self):\n        \"\"\"Update layer only when slider is released\"\"\"\n        if self._disable_updates or not self.selected_layer:\n            return\n\n        sender = self.sender()  # Get which slider was released\n        value = sender.value()\n\n        try:\n            self._disable_updates = True\n            if sender == self.opacity_slider[\"slider\"]:\n                self.selected_layer.opacity = value\n            elif sender == self.x_slider[\"slider\"]:\n                self.selected_layer.position.setX(value / self.x_slider[\"scale_factor\"])\n            elif sender == self.y_slider[\"slider\"]:\n                self.selected_layer.position.setY(value / self.y_slider[\"scale_factor\"])\n            elif sender == self.scale_x_slider[\"slider\"]:\n                self.selected_layer.scale_x = value / 100.0\n            elif sender == self.scale_y_slider[\"slider\"]:\n                self.selected_layer.scale_y = value / 100.0\n            elif sender == self.rotation_slider[\"slider\"]:\n                self.selected_layer.rotation = value\n            elif sender == self.edge_opacity_slider[\"slider\"]:\n                self.selected_layer.edge_opacity = value\n                self.selected_layer._apply_edge_opacity()\n            elif sender == self.edge_width_slider[\"slider\"]:\n                self.selected_layer.edge_width = value\n                self.selected_layer._apply_edge_opacity()\n\n            self.selected_layer.update()  # Trigger a repaint\n\n        finally:\n            self._disable_updates = False\n\n    def emit_bake_settings(self):\n        \"\"\"Emit the bake settings signal.\"\"\"\n        bake_settings = LayerState(\n            layer_id=self.selected_layer.id,\n            order=self.selected_layer.order,\n            layer_name=self.selected_layer.layer_name,\n            position=self.selected_layer.position,\n            rotation=self.selected_layer.rotation,\n            scale_x=self.selected_layer.scale_x,\n            scale_y=self.selected_layer.scale_y,\n            opacity=self.selected_layer.opacity,\n            edge_opacity=self.selected_layer.edge_opacity,\n            edge_width=self.selected_layer.edge_width,\n            visible=self.selected_layer.visible,\n        )\n        logger.info(f\"Storing state {bake_settings}\")\n        self.messageSignal.emit(f\"Stored state for {bake_settings.layer_name}\")\n        self.layerState.emit(bake_settings)\n\n    def set_selected_layer(self, layer):\n        \"\"\"Set the currently selected layer.\"\"\"\n        self.selected_layer = layer\n        self.update_sliders()\n\n    def update_sliders(self):\n        \"\"\"Update slider values based on the selected layer.\"\"\"\n        self.widget.setEnabled(False)\n        if self._disable_updates or not self.selected_layer:\n            return\n\n        try:\n            self._disable_updates = True\n\n            if self.selected_layer.selected:\n                self.widget.setEnabled(True)\n                self.layer_name_label.setText(\n                    f\"BaseLayer: {self.selected_layer.layer_name}\"\n                )\n                new_max_xpos = self.selected_layer.config.max_xpos\n                new_max_ypos = self.selected_layer.config.max_ypos\n\n                if new_max_xpos - abs(self.selected_layer.position.x()) &lt; 50:\n                    new_max_xpos = abs(self.selected_layer.position.x()) + 50\n                if new_max_ypos - abs(self.selected_layer.position.y()) &lt; 50:\n                    new_max_ypos = abs(self.selected_layer.position.y()) + 50\n\n                # Update slider ranges\n                self.x_slider[\"slider\"].setRange(\n                    -new_max_xpos,\n                    new_max_xpos,\n                )\n                self.y_slider[\"slider\"].setRange(\n                    -new_max_ypos,\n                    new_max_ypos,\n                )\n\n                # Update slider values\n                self.opacity_slider[\"slider\"].setValue(\n                    int(self.selected_layer.opacity)  # Scale back to 0-255\n                )\n                self.x_slider[\"slider\"].setValue(int(self.selected_layer.position.x()))\n                self.y_slider[\"slider\"].setValue(int(self.selected_layer.position.y()))\n                self.scale_x_slider[\"slider\"].setValue(\n                    int(self.selected_layer.scale_x * 100)\n                )\n                self.scale_y_slider[\"slider\"].setValue(\n                    int(self.selected_layer.scale_y * 100)\n                )\n                self.rotation_slider[\"slider\"].setValue(\n                    int(self.selected_layer.rotation)\n                )\n                self.edge_opacity_slider[\"slider\"].setValue(\n                    int(self.selected_layer.edge_opacity)\n                )\n                self.edge_width_slider[\"slider\"].setValue(\n                    int(self.selected_layer.edge_width)\n                )\n            else:\n                self.widget.setEnabled(False)\n                self.layer_name_label.setText(\"No BaseLayer\")\n        finally:\n            self._disable_updates = False\n        self.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_settings.LayerSettings.create_slider","title":"<code>create_slider(label, min_val, max_val, default, scale_factor=1)</code>","text":"<p>Create a slider with a label and value display.</p> Source code in <code>imagebaker/list_views/layer_settings.py</code> <pre><code>def create_slider(self, label, min_val, max_val, default, scale_factor=1):\n    \"\"\"Create a slider with a label and value display.\"\"\"\n    container = QWidget()\n    layout = QHBoxLayout(container)\n    layout.setContentsMargins(0, 0, 0, 0)  # Remove inner margins\n\n    # Label\n    lbl = QLabel(label)\n    lbl.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\n    # Slider\n    slider = QSlider(Qt.Horizontal)\n    slider.setRange(min_val, max_val)\n    slider.setValue(default)\n    slider.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)\n\n    # Value label\n    value_lbl = QLabel(f\"{default / scale_factor:.1f}\")\n    value_lbl.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\n    # Connect slider to value label (still updates during drag)\n    slider.valueChanged.connect(\n        lambda v: value_lbl.setText(f\"{v / scale_factor:.1f}\")\n    )\n\n    # Only update layer on slider release\n    slider.sliderReleased.connect(self.on_slider_released)\n\n    # Add widgets to layout\n    layout.addWidget(lbl)\n    layout.addWidget(slider)\n    layout.addWidget(value_lbl)\n\n    return {\n        \"widget\": container,\n        \"slider\": slider,\n        \"label\": value_lbl,\n        \"scale_factor\": scale_factor,\n    }\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_settings.LayerSettings.emit_bake_settings","title":"<code>emit_bake_settings()</code>","text":"<p>Emit the bake settings signal.</p> Source code in <code>imagebaker/list_views/layer_settings.py</code> <pre><code>def emit_bake_settings(self):\n    \"\"\"Emit the bake settings signal.\"\"\"\n    bake_settings = LayerState(\n        layer_id=self.selected_layer.id,\n        order=self.selected_layer.order,\n        layer_name=self.selected_layer.layer_name,\n        position=self.selected_layer.position,\n        rotation=self.selected_layer.rotation,\n        scale_x=self.selected_layer.scale_x,\n        scale_y=self.selected_layer.scale_y,\n        opacity=self.selected_layer.opacity,\n        edge_opacity=self.selected_layer.edge_opacity,\n        edge_width=self.selected_layer.edge_width,\n        visible=self.selected_layer.visible,\n    )\n    logger.info(f\"Storing state {bake_settings}\")\n    self.messageSignal.emit(f\"Stored state for {bake_settings.layer_name}\")\n    self.layerState.emit(bake_settings)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_settings.LayerSettings.init_ui","title":"<code>init_ui()</code>","text":"<p>Initialize the UI elements.</p> Source code in <code>imagebaker/list_views/layer_settings.py</code> <pre><code>def init_ui(self):\n    \"\"\"Initialize the UI elements.\"\"\"\n    logger.info(\"Initializing LayerSettings\")\n    self.widget = QWidget()\n    self.setWidget(self.widget)\n    self.main_layout = QVBoxLayout(self.widget)\n    self.main_layout.setContentsMargins(10, 10, 10, 10)  # Add some padding\n    self.main_layout.setSpacing(10)\n\n    # BaseLayer layer_name label\n    self.layer_name_label = QLabel(\"No BaseLayer Selected\")\n    self.layer_name_label.setAlignment(Qt.AlignCenter)\n    self.layer_name_label.setStyleSheet(\"font-weight: bold; font-size: 14px;\")\n    self.main_layout.addWidget(self.layer_name_label)\n\n    # Opacity slider\n    self.opacity_slider = self.create_slider(\"Opacity:\", 0, 255, 255, 1)\n    self.main_layout.addWidget(self.opacity_slider[\"widget\"])\n    self.x_slider = self.create_slider(\"X:\", -self.max_xpos, self.max_xpos, 0, 1)\n    self.main_layout.addWidget(self.x_slider[\"widget\"])\n    self.y_slider = self.create_slider(\"Y:\", -self.max_ypos, self.max_ypos, 0, 1)\n    self.main_layout.addWidget(self.y_slider[\"widget\"])\n    self.scale_x_slider = self.create_slider(\n        \"Scale X:\", -self.max_scale, self.max_scale, 100, 100\n    )  # 1-500 becomes 0.01-5.0\n    self.main_layout.addWidget(self.scale_x_slider[\"widget\"])\n    self.scale_y_slider = self.create_slider(\n        \"Scale Y:\", -self.max_scale, self.max_scale, 100, 100\n    )\n    self.main_layout.addWidget(self.scale_y_slider[\"widget\"])\n    self.rotation_slider = self.create_slider(\"Rotation:\", 0, 360, 0, 1)\n    self.main_layout.addWidget(self.rotation_slider[\"widget\"])\n    self.edge_opacity_slider = self.create_slider(\"Edge Opacity:\", 0, 255, 255, 1)\n    self.main_layout.addWidget(self.edge_opacity_slider[\"widget\"])\n    self.edge_width_slider = self.create_slider(\n        \"Edge Width:\", 0, self.max_edge_width, 5, 1\n    )\n    self.main_layout.addWidget(self.edge_width_slider[\"widget\"])\n\n    # Add stretch to push content to the top\n    self.main_layout.addStretch()\n\n    # Ensure the dock widget resizes properly\n    self.setMinimumWidth(250)  # Minimum width for usability\n    self.widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_settings.LayerSettings.on_slider_released","title":"<code>on_slider_released()</code>","text":"<p>Update layer only when slider is released</p> Source code in <code>imagebaker/list_views/layer_settings.py</code> <pre><code>def on_slider_released(self):\n    \"\"\"Update layer only when slider is released\"\"\"\n    if self._disable_updates or not self.selected_layer:\n        return\n\n    sender = self.sender()  # Get which slider was released\n    value = sender.value()\n\n    try:\n        self._disable_updates = True\n        if sender == self.opacity_slider[\"slider\"]:\n            self.selected_layer.opacity = value\n        elif sender == self.x_slider[\"slider\"]:\n            self.selected_layer.position.setX(value / self.x_slider[\"scale_factor\"])\n        elif sender == self.y_slider[\"slider\"]:\n            self.selected_layer.position.setY(value / self.y_slider[\"scale_factor\"])\n        elif sender == self.scale_x_slider[\"slider\"]:\n            self.selected_layer.scale_x = value / 100.0\n        elif sender == self.scale_y_slider[\"slider\"]:\n            self.selected_layer.scale_y = value / 100.0\n        elif sender == self.rotation_slider[\"slider\"]:\n            self.selected_layer.rotation = value\n        elif sender == self.edge_opacity_slider[\"slider\"]:\n            self.selected_layer.edge_opacity = value\n            self.selected_layer._apply_edge_opacity()\n        elif sender == self.edge_width_slider[\"slider\"]:\n            self.selected_layer.edge_width = value\n            self.selected_layer._apply_edge_opacity()\n\n        self.selected_layer.update()  # Trigger a repaint\n\n    finally:\n        self._disable_updates = False\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_settings.LayerSettings.set_selected_layer","title":"<code>set_selected_layer(layer)</code>","text":"<p>Set the currently selected layer.</p> Source code in <code>imagebaker/list_views/layer_settings.py</code> <pre><code>def set_selected_layer(self, layer):\n    \"\"\"Set the currently selected layer.\"\"\"\n    self.selected_layer = layer\n    self.update_sliders()\n</code></pre>"},{"location":"api-reference/#imagebaker.list_views.layer_settings.LayerSettings.update_sliders","title":"<code>update_sliders()</code>","text":"<p>Update slider values based on the selected layer.</p> Source code in <code>imagebaker/list_views/layer_settings.py</code> <pre><code>def update_sliders(self):\n    \"\"\"Update slider values based on the selected layer.\"\"\"\n    self.widget.setEnabled(False)\n    if self._disable_updates or not self.selected_layer:\n        return\n\n    try:\n        self._disable_updates = True\n\n        if self.selected_layer.selected:\n            self.widget.setEnabled(True)\n            self.layer_name_label.setText(\n                f\"BaseLayer: {self.selected_layer.layer_name}\"\n            )\n            new_max_xpos = self.selected_layer.config.max_xpos\n            new_max_ypos = self.selected_layer.config.max_ypos\n\n            if new_max_xpos - abs(self.selected_layer.position.x()) &lt; 50:\n                new_max_xpos = abs(self.selected_layer.position.x()) + 50\n            if new_max_ypos - abs(self.selected_layer.position.y()) &lt; 50:\n                new_max_ypos = abs(self.selected_layer.position.y()) + 50\n\n            # Update slider ranges\n            self.x_slider[\"slider\"].setRange(\n                -new_max_xpos,\n                new_max_xpos,\n            )\n            self.y_slider[\"slider\"].setRange(\n                -new_max_ypos,\n                new_max_ypos,\n            )\n\n            # Update slider values\n            self.opacity_slider[\"slider\"].setValue(\n                int(self.selected_layer.opacity)  # Scale back to 0-255\n            )\n            self.x_slider[\"slider\"].setValue(int(self.selected_layer.position.x()))\n            self.y_slider[\"slider\"].setValue(int(self.selected_layer.position.y()))\n            self.scale_x_slider[\"slider\"].setValue(\n                int(self.selected_layer.scale_x * 100)\n            )\n            self.scale_y_slider[\"slider\"].setValue(\n                int(self.selected_layer.scale_y * 100)\n            )\n            self.rotation_slider[\"slider\"].setValue(\n                int(self.selected_layer.rotation)\n            )\n            self.edge_opacity_slider[\"slider\"].setValue(\n                int(self.selected_layer.edge_opacity)\n            )\n            self.edge_width_slider[\"slider\"].setValue(\n                int(self.selected_layer.edge_width)\n            )\n        else:\n            self.widget.setEnabled(False)\n            self.layer_name_label.setText(\"No BaseLayer\")\n    finally:\n        self._disable_updates = False\n    self.update()\n</code></pre>"},{"location":"api-reference/#layers","title":"Layers","text":""},{"location":"api-reference/#base-layer","title":"Base Layer","text":"<p>               Bases: <code>QWidget</code></p> Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>class BaseLayer(QWidget):\n    messageSignal = Signal(str)\n    zoomChanged = Signal(float)\n    mouseMoved = Signal(QPointF)\n    annotationCleared = Signal()\n    layerRemoved = Signal(int)\n    layersChanged = Signal()\n    layerSignal = Signal(object)\n\n    def __init__(self, parent: QWidget, config: LayerConfig | CanvasConfig):\n        \"\"\"\n        BaseLayer is an abstract class that represents a single layer in the canvas.\n        It provides functionality for managing layer properties, handling user interactions,\n        and rendering the layer's content. This class is designed to be extended by\n        subclasses that implement specific layer behaviors.\n\n        Attributes:\n            id (int): Unique identifier for the layer.\n            layer_state (LayerState): The current state of the layer, including properties\n                like position, scale, rotation, and visibility.\n            previous_state (LayerState): The previous state of the layer, used for undo operations.\n            layers (list[BaseLayer]): A list of child layers associated with this layer.\n            annotations (list[Annotation]): A list of annotations associated with the layer.\n            selected_annotation (Optional[Annotation]): The currently selected annotation.\n            current_annotation (Optional[Annotation]): The annotation currently being created or edited.\n            copied_annotation (Optional[Annotation]): A copied annotation for pasting.\n            image (QPixmap): The image associated with the layer.\n            scale (float): The current scale of the layer.\n            pan_offset (QPointF): The current pan offset of the layer.\n            mouse_mode (MouseMode): The current mouse interaction mode (e.g., DRAW, PAN, IDLE).\n            states (dict[int, list[LayerState]]): A dictionary of saved states for the layer,\n                indexed by step.\n            current_step (int): The current step in the layer's state history.\n            drawing_color (QColor): The color used for drawing operations.\n            brush_size (int): The size of the brush used for drawing operations.\n            config (LayerConfig | CanvasConfig): Configuration settings for the layer.\n            file_path (Path): The file path associated with the layer's image.\n            visible (bool): Whether the layer is visible.\n            selected (bool): Whether the layer is selected.\n            opacity (float): The opacity of the layer (0.0 to 1.0).\n            transform_origin (QPointF): The origin point for transformations (e.g., rotation, scaling).\n            playing (bool): Whether the layer is currently in a \"playing\" state (e.g., animation).\n            allow_annotation_export (bool): Whether annotations can be exported for this layer.\n\n        Signals:\n            messageSignal (str): Emitted when a message needs to be displayed.\n            zoomChanged (float): Emitted when the zoom level changes.\n            mouseMoved (QPointF): Emitted when the mouse moves over the layer.\n            annotationCleared (): Emitted when annotations are cleared.\n            layerRemoved (int): Emitted when a layer is removed.\n            layersChanged (): Emitted when the layer list changes.\n            layerSignal (object): Emitted with a layer-related signal.\n\n        Methods:\n            save_current_state(steps: int = 1):\n                Save the current state of the layer, including intermediate states\n                calculated between the previous and current states.\n\n            set_image(image_path: Path | QPixmap | QImage):\n                Set the image for the layer from a file path, QPixmap, or QImage.\n\n            get_layer(id: str) -&gt; \"BaseLayer\":\n                Retrieve a child layer by its ID.\n\n            reset_view():\n                Reset the view of the layer, including scale and offset.\n\n            clear_annotations():\n                Clear all annotations associated with the layer.\n\n            update_cursor():\n                Update the cursor based on the current mouse mode.\n\n            undo():\n                Undo the last change to the layer's state.\n\n            set_mode(mode: MouseMode):\n                Set the mouse interaction mode for the layer.\n\n            widget_to_image_pos(pos: QPointF) -&gt; QPointF:\n                Convert a widget position to an image position.\n\n            get_thumbnail(annotation: Annotation = None) -&gt; QPixmap:\n                Generate a thumbnail for the layer or a specific annotation.\n\n            copy() -&gt; \"BaseLayer\":\n                Create a copy of the layer, including its properties and annotations.\n\n            paintEvent(event):\n                Handle the paint event for the layer.\n\n            paint_layer(painter: QPainter):\n                Abstract method to paint the layer's content. Must be implemented by subclasses.\n\n            handle_mouse_press(event: QMouseEvent):\n                Abstract method to handle mouse press events. Must be implemented by subclasses.\n\n            handle_mouse_move(event: QMouseEvent):\n                Abstract method to handle mouse move events. Must be implemented by subclasses.\n\n            handle_mouse_release(event: QMouseEvent):\n                Abstract method to handle mouse release events. Must be implemented by subclasses.\n\n            handle_wheel(event: QWheelEvent):\n                Abstract method to handle wheel events. Must be implemented by subclasses.\n\n            handle_key_press(event: QKeyEvent):\n                Abstract method to handle key press events. Must be implemented by subclasses.\n\n            handle_key_release(event: QKeyEvent):\n                Abstract method to handle key release events. Must be implemented by subclasses.\n\n        Notes:\n            - This class is designed to be extended by subclasses that implement specific\n            layer behaviors (e.g., drawing, annotation, image manipulation).\n            - The `paint_layer` method must be implemented by subclasses to define how\n            the layer's content is rendered.\n\n        \"\"\"\n        super().__init__(parent)\n        self.id = id(self)\n        self.layer_state = LayerState(layer_id=self.id)\n        self._previous_state = None\n        self.thumbnails = {}\n        self.label_rects = []\n        self._last_state = None\n        self.config = config\n        self.parent_obj = parent\n        self.mouse_mode = MouseMode.IDLE\n        self.file_path: Path = Path(\"Runtime\")\n        self.layersChanged.connect(self.update)\n\n        self.drag_start: QPointF = None\n        self.drag_offset: QPointF = None\n        self.offset: QPointF = QPointF(0, 0)\n        self.pan_start: QPointF = None\n        self.pan_offset: QPointF = None\n        self._image = QPixmap()\n        self._original_image = QPixmap()\n        self.annotations: list[Annotation] = []\n        self.current_annotation: Optional[Annotation] = None\n        self.copied_annotation: Optional[Annotation] = None\n        self.selected_annotation: Optional[Annotation] = None\n\n        self.layers: list[BaseLayer] = []\n        self.layer_masks = []\n        self._back_buffer = QPixmap()\n        self.current_label: str = None\n        self.current_color: QColor = QColor(255, 255, 255)\n\n        self.scale = 1.0\n        self.pan_offset = QPointF(0, 0)\n        self.last_pan_point = None\n        self._dragging_layer = None\n        self._drag_offset = QPointF(0, 0)\n        self._current_hover = None\n        self._active_handle = None\n        self._transform_start = None\n        self._is_panning = False\n        self.offset = QPointF(0, 0)\n        self.copied_layer: BaseLayer = None\n        self.selected_layer: BaseLayer = None\n        self.mouse_mode = MouseMode.IDLE\n        self.prev_mouse_mode = MouseMode.IDLE\n        self.states: dict[str, list[LayerState]] = dict()\n\n        self.states: dict[int, list[LayerState]] = dict()\n        self.previous_state = None\n        self.current_step = 0\n        self.drawing_color = QColor(Qt.red)  # Default drawing color\n        self.brush_size = 5  # Default brush size\n\n        if isinstance(config, LayerConfig):\n            self.current_label = self.config.predefined_labels[0].name\n            self.current_color = self.config.predefined_labels[0].color\n\n        self.setMouseTracking(True)\n        self.setFocusPolicy(Qt.StrongFocus)\n\n    def get_layer(self, id: str) -&gt; \"BaseLayer\":\n        \"\"\"\n        Get a child layer by its ID.\n\n        Args:\n            id (str): The ID of the layer to retrieve.\n\n        Returns:\n            Child of BaseLayer: The child layer with the specified ID, or None if not found\n        \"\"\"\n        for layer in self.layers:\n            if layer.layer_id == id:\n                return layer\n        return None\n\n    def save_current_state(self, steps: int = 1):\n        \"\"\"\n        Save the current state of the layer, including intermediate states\n        calculated between the previous and current states.\n\n        Args:\n            steps (int): The number of intermediate steps to calculate between\n\n        Returns:\n            None\n        \"\"\"\n        curr_states = {}\n        mode = self.mouse_mode\n\n        for layer in self.layers:\n            # Calculate intermediate states between previous_state and current_state\n            intermediate_states = calculate_intermediate_states(\n                layer.previous_state, layer.layer_state.copy(), steps\n            )\n            is_selected = layer.selected\n\n            for step, state in enumerate(intermediate_states):\n                step += self.current_step\n\n                logger.info(f\"Saving state {step} for layer {layer.layer_id}\")\n                state.selected = False\n                if step not in curr_states:\n                    curr_states[step] = []\n\n                # Deep copy the drawing states to avoid unintended modifications\n                state.drawing_states = [\n                    DrawingState(\n                        position=d.position,\n                        color=d.color,\n                        size=d.size,\n                    )\n                    for d in layer.layer_state.drawing_states\n                ]\n                curr_states[step].append(state)\n\n            # Update the layer's previous_state to the current state\n            layer.previous_state = layer.layer_state.copy()\n            layer.selected = is_selected\n\n        # Save the calculated states in self.states\n        for step, states in curr_states.items():\n            self.states[step] = states\n            self.current_step = step\n\n        # Save the current layer's state\n        self.previous_state = self.layer_state.copy()\n        self.layer_state.drawing_states = [\n            DrawingState(\n                position=d.position,\n                color=d.color,\n                size=d.size,\n            )\n            for d in self.layer_state.drawing_states\n        ]\n\n        # Emit a message signal indicating the state has been saved\n        self.messageSignal.emit(f\"Saved state {self.current_step}\")\n        self.mouse_mode = mode\n\n        self.update()\n\n    def minimumSizeHint(self):\n        \"\"\"Return the minimum size hint for the widget.\"\"\"\n        return QSize(100, 100)\n\n    def widget_to_image_pos(self, pos: QPointF) -&gt; QPointF:\n        \"\"\"\n        Convert a widget position to an image position.\n        \"\"\"\n        return QPointF(\n            (pos.x() - self.offset.x()) / self.scale,\n            (pos.y() - self.offset.y()) / self.scale,\n        )\n\n    def update_cursor(self):\n        \"\"\"\n        Update the cursor based on the current mouse mode.\n        \"\"\"\n        if MouseMode.POINT == self.mouse_mode:\n            self.setCursor(CursorDef.POINT_CURSOR)\n        elif MouseMode.RECTANGLE == self.mouse_mode:\n            self.setCursor(CursorDef.RECTANGLE_CURSOR)\n        elif MouseMode.POLYGON == self.mouse_mode:\n            self.setCursor(CursorDef.POLYGON_CURSOR)\n        elif MouseMode.PAN == self.mouse_mode:\n            self.setCursor(CursorDef.PAN_CURSOR)\n        elif MouseMode.IDLE == self.mouse_mode:\n            self.setCursor(CursorDef.IDLE_CURSOR)\n        elif MouseMode.RESIZE == self.mouse_mode:\n            self.setCursor(CursorDef.RECTANGLE_CURSOR)\n        elif MouseMode.RESIZE_HEIGHT == self.mouse_mode:\n            self.setCursor(CursorDef.TRANSFORM_UPDOWN)\n        elif MouseMode.RESIZE_WIDTH == self.mouse_mode:\n            self.setCursor(CursorDef.TRANSFORM_LEFTRIGHT)\n        elif MouseMode.GRAB == self.mouse_mode:\n            self.setCursor(CursorDef.GRAB_CURSOR)\n        elif self.mouse_mode == MouseMode.DRAW:\n            # Create a custom cursor for drawing (circle representing brush size)\n            self.setCursor(self._create_custom_cursor(self.drawing_color, \"circle\"))\n\n        elif self.mouse_mode == MouseMode.ERASE:\n            # Create a custom cursor for erasing (square representing eraser size)\n            self.setCursor(self._create_custom_cursor(Qt.white, \"square\"))\n\n        else:\n            # Reset to default cursor\n            self.setCursor(Qt.ArrowCursor)\n\n    def _create_custom_cursor(self, color: QColor, shape: str) -&gt; QCursor:\n        \"\"\"Create a custom cursor with the given color and shape.\"\"\"\n        pixmap = QPixmap(self.brush_size * 2, self.brush_size * 2)\n        pixmap.fill(Qt.transparent)\n        painter = QPainter(pixmap)\n        painter.setRenderHints(QPainter.Antialiasing)\n        painter.setPen(QPen(Qt.black, 1))  # Border color for the cursor\n        painter.setBrush(color)\n\n        if shape == \"circle\":\n            painter.drawEllipse(\n                pixmap.rect().center(), self.brush_size, self.brush_size\n            )\n        elif shape == \"square\":\n            painter.drawRect(pixmap.rect().adjusted(1, 1, -1, -1))\n\n        painter.end()\n        return QCursor(pixmap)\n\n    def set_image(self, image_path: Path | QPixmap | QImage):\n        \"\"\"\n        Set the image for the layer from a file path, QPixmap, or QImage.\n        \"\"\"\n        if isinstance(image_path, Path):\n            self.file_path = image_path\n\n            if image_path.exists():\n                self.image.load(str(image_path))\n                self.reset_view()\n                self.update()\n        elif isinstance(image_path, QPixmap):\n            self.image = image_path\n            self.reset_view()\n            self.update()\n        elif isinstance(image_path, QImage):\n            self.image = QPixmap.fromImage(image_path)\n            self.reset_view()\n            self.update()\n\n        self._original_image = self.image.copy()  # Store a copy of the original image\n        self.original_size = QSizeF(self.image.size())  # Store original size\n\n    @property\n    def image(self):\n        \"\"\"\n        Get the current image of the canvas layer.\n\n        Returns:\n            QPixmap: The current image of the canvas layer.\n        \"\"\"\n        return self._image\n\n    @image.setter\n    def image(self, value: QPixmap):\n        \"\"\"\n        Set the image of the canvas layer.\n\n        Args:\n            value (QPixmap): The new image for the canvas layer.\n        \"\"\"\n        self._image = value\n\n    def _apply_edge_opacity(self):\n        \"\"\"\n        Apply edge opacity to the image. This function modifies the edges of the image\n        to have reduced opacity based on the configuration.\n        \"\"\"\n        logger.debug(\"Applying edge opacity to the image.\")\n        edge_width = self.edge_width\n        edge_opacity = self.edge_opacity\n\n        # Convert QPixmap to QImage for pixel manipulation\n        image = self._original_image.toImage()\n        image = image.convertToFormat(\n            QImage.Format_ARGB32\n        )  # Ensure format supports alpha\n\n        width = image.width()\n        height = image.height()\n        annotation = self.annotations[0] if self.annotations else None\n        if annotation is None:\n            return\n\n        if annotation.rectangle:\n            for x in range(width):\n                for y in range(height):\n                    color = image.pixelColor(x, y)\n                    if color.alpha() != 0:  # If the pixel is not fully transparent\n                        # Calculate horizontal and vertical distances to the edges\n                        horizontal_distance = min(x, width - x - 1)\n                        vertical_distance = min(y, height - y - 1)\n\n                        # If the pixel is within the edge region\n                        if (\n                            horizontal_distance &lt; edge_width\n                            or vertical_distance &lt; edge_width\n                        ):\n                            distance_to_edge = min(\n                                horizontal_distance, vertical_distance\n                            )\n                            # Calculate the new alpha based on the distance to the edge\n                            factor = (edge_width - distance_to_edge) / edge_width\n                            new_alpha = int(\n                                color.alpha()\n                                * ((1 - factor) + (factor * (edge_opacity / 255.0)))\n                            )\n                            color.setAlpha(new_alpha)\n                            image.setPixelColor(x, y, color)\n\n        elif annotation.polygon:\n            # Extract alpha channel and find contours\n            alpha_image = image.convertToFormat(QImage.Format_Alpha8)\n            bytes_per_line = (\n                alpha_image.bytesPerLine()\n            )  # Get the stride (bytes per line)\n            alpha_data = alpha_image.bits().tobytes()\n\n            # Extract only the valid data (remove padding)\n            alpha_array = np.frombuffer(alpha_data, dtype=np.uint8).reshape(\n                (alpha_image.height(), bytes_per_line)\n            )[\n                :, : alpha_image.width()\n            ]  # Remove padding to match the actual width\n\n            # Use OpenCV to find contours\n            contours, _ = cv2.findContours(\n                alpha_array, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE\n            )\n\n            # Iterate over each pixel and apply edge opacity\n            for x in range(width):\n                for y in range(height):\n                    color = image.pixelColor(x, y)\n                    if color.alpha() != 0:  # If the pixel is not fully transparent\n                        # Calculate distance to the nearest contour\n                        distance_to_edge = cv2.pointPolygonTest(\n                            contours[0], (x, y), True\n                        )  # True for distance calculation\n\n                        # If the pixel is within the edge region\n                        if 0 &lt;= distance_to_edge &lt; edge_width:\n                            # Calculate the new alpha based on the distance to the edge\n                            factor = (edge_width - distance_to_edge) / edge_width\n                            new_alpha = int(\n                                color.alpha()\n                                * ((1 - factor) + (factor * (edge_opacity / 255.0)))\n                            )\n                            color.setAlpha(new_alpha)\n                            image.setPixelColor(x, y, color)\n\n        # Convert the modified QImage back to QPixmap\n        self.image = QPixmap.fromImage(image)\n\n    def get_thumbnail(self, annotation: Annotation = None):\n        \"\"\"\n        Generate a thumbnail for the layer or a specific annotation.\n        \"\"\"\n        image = QPixmap(*self.config.normal_draw_config.thumbnail_size)\n        image.fill(Qt.transparent)\n\n        if annotation:\n            if annotation.rectangle:\n                image = self.image.copy(annotation.rectangle.toRect())\n            elif annotation.polygon:\n                image = self.image.copy(annotation.polygon.boundingRect().toRect())\n            elif annotation.points:\n                # Create a small thumbnail around the point\n                thumbnail_size = 100\n                thumbnail = QPixmap(thumbnail_size, thumbnail_size)\n                thumbnail.fill(Qt.transparent)\n                painter = QPainter(thumbnail)\n                painter.setRenderHint(QPainter.Antialiasing)\n                painter.setBrush(annotation.color)\n                painter.setPen(Qt.NoPen)\n                painter.drawEllipse(thumbnail.rect().center() + QPoint(-5, -5), 10, 10)\n                painter.end()\n                image = thumbnail\n        else:\n            if self.image:\n                image = self.image.copy(\n                    0, 0, *self.config.normal_draw_config.thumbnail_size\n                )\n            elif len(self.layers) &gt; 0:\n                image = self.layers[0].get_thumbnail()\n            else:\n                image = QPixmap(*self.config.normal_draw_config.thumbnail_size)\n                image.fill(Qt.transparent)\n\n        return image.scaled(*self.config.normal_draw_config.thumbnail_size)\n\n    def copy(self):\n        \"\"\"\n        Create a copy of the layer, including its properties and annotations.\n        Should be overridden by subclasses to copy additional properties.\n        \"\"\"\n        layer = self.__class__(self.parent_obj, self.config)\n        layer.set_image(self.image)\n        layer.annotations = [ann.copy() for ann in self.annotations]\n        layer.layers = [layer.copy() for layer in self.layers]\n        layer.layer_name = self.layer_name\n        layer.position = self.position\n        layer.rotation = self.rotation\n        layer.scale = self.scale\n        layer.scale_x = self.scale_x\n        layer.scale_y = self.scale_y\n        layer.opacity = self.opacity\n        layer.visible = self.visible\n        layer.selected = False\n        layer.is_annotable = self.is_annotable\n        return layer\n\n    def set_mode(self, mode: MouseMode):\n        \"\"\"\n        Set the mouse interaction mode for the layer.\n        \"\"\"\n        # Preserve current annotation when changing modes\n        if mode == self.mouse_mode:\n            return\n\n        # Only reset if switching to a different annotation mode\n        if mode not in [MouseMode.POLYGON, MouseMode.RECTANGLE, MouseMode.POINT]:\n            self.current_annotation = None\n\n        self.mouse_mode = mode\n        logger.debug(f\"Layer {self.layer_id}: Mode set to {mode}\")\n        self.update()\n\n    def mouseDoubleClickEvent(self, event: QMouseEvent):\n        # return super().mouseDoubleClickEvent(event)\n        pos = event.pos()\n        self.handle_mouse_double_click(event, pos)\n        self.update()\n        super().mouseDoubleClickEvent(event)\n\n    def mousePressEvent(self, event):\n        self.handle_mouse_press(event)\n\n        self.update()\n        super().mousePressEvent(event)\n\n    def mouseMoveEvent(self, event: QMouseEvent):\n\n        self.handle_mouse_move(event)\n        self.update()\n        super().mouseMoveEvent(event)\n\n    def mouseReleaseEvent(self, event: QMouseEvent):\n\n        self.handle_mouse_release(event)\n        self.update()\n        super().mouseReleaseEvent(event)\n\n    def wheelEvent(self, event):\n        self.handle_wheel(event)\n        self.update()\n        super().wheelEvent(event)\n\n    def keyPressEvent(self, event: QKeyEvent):\n        self.handle_key_press(event)\n        self.update()\n        super().keyPressEvent(event)\n\n    def keyReleaseEvent(self, event):\n        if self.is_annotable:\n            self.handle_key_release(event)\n        else:\n            self.handle_key_release(event)\n        self.update()\n\n    def handle_mouse_double_click(self, event, pos):\n        raise NotImplementedError\n\n    def handle_mouse_press(self, event):\n        \"\"\"\n        Handle mouse press events for selecting layers, initiating transformations,\n        or starting drawing/erasing operations.\n\n        Args:\n            event (QMouseEvent): The mouse press event.\n        \"\"\"\n        raise NotImplementedError\n\n    def handle_mouse_move(self, event):\n        \"\"\"\n        Handle mouse move events for panning, drawing, erasing, or transforming layers.\n\n        Args:\n            event (QMouseEvent): The mouse move event.\n        \"\"\"\n        raise NotImplementedError\n\n    def handle_mouse_release(self, event):\n        \"\"\"\n        Handle mouse release events, such as resetting the active handle or stopping\n        drawing/erasing operations.\n\n        Args:\n            event (QMouseEvent): The mouse release event.\n        \"\"\"\n        raise NotImplementedError\n\n    def handle_wheel(self, event):\n        \"\"\"\n        Handle mouse wheel events for adjusting the brush size or zooming the canvas.\n\n        Args:\n            event (QWheelEvent): The wheel event.\n        \"\"\"\n        raise NotImplementedError\n\n    def handle_key_press(self, event):\n        raise NotImplementedError\n\n    def handle_key_release(self, event):\n        raise NotImplementedError\n\n    def reset_view(self):\n        self.scale = 1.0\n        self.offset = QPointF(0, 0)\n\n    def clear_annotations(self):\n        self.annotations.clear()\n        self.selected_annotation = None\n        self.current_annotation = None\n        self.annotationCleared.emit()\n        self.update()\n\n    def paintEvent(self, event):\n        self.paint_event()\n\n    def paint_event(self):\n        painter = QPainter(self)\n\n        painter.setRenderHints(QPainter.Antialiasing | QPainter.SmoothPixmapTransform)\n\n        painter.fillRect(\n            self.rect(),\n            QColor(\n                self.config.normal_draw_config.background_color.red(),\n                self.config.normal_draw_config.background_color.green(),\n                self.config.normal_draw_config.background_color.blue(),\n            ),\n        )\n        self.paint_layer(painter)\n\n    def paint_layer(self, painter: QPainter):\n        raise NotImplementedError\n\n    def __del__(self):\n        logger.debug(f\"Layer {self.layer_id}: {self.layer_name} deleted.\")\n\n    # override update to store last state\n    def update(self):\n        self._last_state = self.layer_state\n        self.update_cursor()\n        super().update()\n\n    def undo(self):\n        if self._last_state is not None:\n            self.layer_state = self._last_state\n            self.update()\n\n    # Layer ID Property\n    @property\n    def layer_id(self) -&gt; int:\n        return self.layer_state.layer_id\n\n    @layer_id.setter\n    def layer_id(self, value: int):\n        self.layer_state.layer_id = value\n\n    @property\n    def is_annotable(self) -&gt; bool:\n        return self.layer_state.is_annotable\n\n    @is_annotable.setter\n    def is_annotable(self, value: bool):\n        self.layer_state.is_annotable = value\n\n    # Layer Name Property\n    @property\n    def layer_name(self) -&gt; str:\n        return self.layer_state.layer_name\n\n    @layer_name.setter\n    def layer_name(self, value: str):\n        self.layer_state.layer_name = value\n\n    # Position Property\n    @property\n    def position(self) -&gt; QPointF:\n        return self.layer_state.position\n\n    @position.setter\n    def position(self, value: QPointF):\n        self.layer_state.position = value\n\n    # Rotation Property\n    @property\n    def rotation(self) -&gt; float:\n        return self.layer_state.rotation\n\n    @rotation.setter\n    def rotation(self, value: float):\n        self.layer_state.rotation = value\n\n    # Scale Property\n    @property\n    def scale(self) -&gt; float:\n        return self.layer_state.scale\n\n    @scale.setter\n    def scale(self, value: float):\n        self.layer_state.scale = value\n\n    # Scale X Property\n    @property\n    def scale_x(self) -&gt; float:\n        return self.layer_state.scale_x\n\n    @scale_x.setter\n    def scale_x(self, value: float):\n        self.layer_state.scale_x = value\n\n    # Scale Y Property\n    @property\n    def scale_y(self) -&gt; float:\n        return self.layer_state.scale_y\n\n    @scale_y.setter\n    def scale_y(self, value: float):\n        self.layer_state.scale_y = value\n\n    # Transform Origin Property\n    @property\n    def transform_origin(self) -&gt; QPointF:\n        return self.layer_state.transform_origin\n\n    @transform_origin.setter\n    def transform_origin(self, value: QPointF):\n        self.layer_state.transform_origin = value\n\n    # Order Property\n    @property\n    def order(self) -&gt; int:\n        return self.layer_state.order\n\n    @order.setter\n    def order(self, value: int):\n        self.layer_state.order = value\n\n    # Visibility Property\n    @property\n    def visible(self) -&gt; bool:\n        return self.layer_state.visible\n\n    @visible.setter\n    def visible(self, value: bool):\n        self.layer_state.visible = value\n\n    # Annotation Export Property\n    @property\n    def allow_annotation_export(self) -&gt; bool:\n        return self.layer_state.allow_annotation_export\n\n    @allow_annotation_export.setter\n    def allow_annotation_export(self, value: bool):\n        self.layer_state.allow_annotation_export = value\n\n    @property\n    def playing(self) -&gt; bool:\n        return self.layer_state.playing\n\n    @playing.setter\n    def playing(self, value: bool):\n        self.layer_state.playing = value\n\n    @property\n    def selected(self) -&gt; bool:\n        return self.layer_state.selected\n\n    @selected.setter\n    def selected(self, value: bool):\n        self.layer_state.selected = value\n\n    @property\n    def opacity(self) -&gt; float:\n        return self.layer_state.opacity\n\n    @opacity.setter\n    def opacity(self, value: float):\n        self.layer_state.opacity = value\n\n    @property\n    def status(self) -&gt; str:\n        return self.layer_state.status\n\n    @status.setter\n    def status(self, value: str):\n        self.layer_state.status = value\n\n    @property\n    def drawing_states(self) -&gt; list[DrawingState]:\n        return self.layer_state.drawing_states\n\n    @drawing_states.setter\n    def drawing_states(self, value: list[DrawingState]):\n        self.layer_state.drawing_states = value\n\n    @property\n    def edge_opacity(self) -&gt; int:\n        return self.layer_state.edge_opacity\n\n    @edge_opacity.setter\n    def edge_opacity(self, value: int):\n        self.layer_state.edge_opacity = value\n\n    @property\n    def edge_width(self) -&gt; int:\n        return self.layer_state.edge_width\n\n    @edge_width.setter\n    def edge_width(self, value: int):\n        self.layer_state.edge_width = value\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.image","title":"<code>image</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current image of the canvas layer.</p> <p>Returns:</p> Name Type Description <code>QPixmap</code> <p>The current image of the canvas layer.</p>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.copy","title":"<code>copy()</code>","text":"<p>Create a copy of the layer, including its properties and annotations. Should be overridden by subclasses to copy additional properties.</p> Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Create a copy of the layer, including its properties and annotations.\n    Should be overridden by subclasses to copy additional properties.\n    \"\"\"\n    layer = self.__class__(self.parent_obj, self.config)\n    layer.set_image(self.image)\n    layer.annotations = [ann.copy() for ann in self.annotations]\n    layer.layers = [layer.copy() for layer in self.layers]\n    layer.layer_name = self.layer_name\n    layer.position = self.position\n    layer.rotation = self.rotation\n    layer.scale = self.scale\n    layer.scale_x = self.scale_x\n    layer.scale_y = self.scale_y\n    layer.opacity = self.opacity\n    layer.visible = self.visible\n    layer.selected = False\n    layer.is_annotable = self.is_annotable\n    return layer\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.get_layer","title":"<code>get_layer(id)</code>","text":"<p>Get a child layer by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the layer to retrieve.</p> required <p>Returns:</p> Type Description <code>BaseLayer</code> <p>Child of BaseLayer: The child layer with the specified ID, or None if not found</p> Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def get_layer(self, id: str) -&gt; \"BaseLayer\":\n    \"\"\"\n    Get a child layer by its ID.\n\n    Args:\n        id (str): The ID of the layer to retrieve.\n\n    Returns:\n        Child of BaseLayer: The child layer with the specified ID, or None if not found\n    \"\"\"\n    for layer in self.layers:\n        if layer.layer_id == id:\n            return layer\n    return None\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.get_thumbnail","title":"<code>get_thumbnail(annotation=None)</code>","text":"<p>Generate a thumbnail for the layer or a specific annotation.</p> Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def get_thumbnail(self, annotation: Annotation = None):\n    \"\"\"\n    Generate a thumbnail for the layer or a specific annotation.\n    \"\"\"\n    image = QPixmap(*self.config.normal_draw_config.thumbnail_size)\n    image.fill(Qt.transparent)\n\n    if annotation:\n        if annotation.rectangle:\n            image = self.image.copy(annotation.rectangle.toRect())\n        elif annotation.polygon:\n            image = self.image.copy(annotation.polygon.boundingRect().toRect())\n        elif annotation.points:\n            # Create a small thumbnail around the point\n            thumbnail_size = 100\n            thumbnail = QPixmap(thumbnail_size, thumbnail_size)\n            thumbnail.fill(Qt.transparent)\n            painter = QPainter(thumbnail)\n            painter.setRenderHint(QPainter.Antialiasing)\n            painter.setBrush(annotation.color)\n            painter.setPen(Qt.NoPen)\n            painter.drawEllipse(thumbnail.rect().center() + QPoint(-5, -5), 10, 10)\n            painter.end()\n            image = thumbnail\n    else:\n        if self.image:\n            image = self.image.copy(\n                0, 0, *self.config.normal_draw_config.thumbnail_size\n            )\n        elif len(self.layers) &gt; 0:\n            image = self.layers[0].get_thumbnail()\n        else:\n            image = QPixmap(*self.config.normal_draw_config.thumbnail_size)\n            image.fill(Qt.transparent)\n\n    return image.scaled(*self.config.normal_draw_config.thumbnail_size)\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.handle_mouse_move","title":"<code>handle_mouse_move(event)</code>","text":"<p>Handle mouse move events for panning, drawing, erasing, or transforming layers.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QMouseEvent</code> <p>The mouse move event.</p> required Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def handle_mouse_move(self, event):\n    \"\"\"\n    Handle mouse move events for panning, drawing, erasing, or transforming layers.\n\n    Args:\n        event (QMouseEvent): The mouse move event.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.handle_mouse_press","title":"<code>handle_mouse_press(event)</code>","text":"<p>Handle mouse press events for selecting layers, initiating transformations, or starting drawing/erasing operations.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QMouseEvent</code> <p>The mouse press event.</p> required Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def handle_mouse_press(self, event):\n    \"\"\"\n    Handle mouse press events for selecting layers, initiating transformations,\n    or starting drawing/erasing operations.\n\n    Args:\n        event (QMouseEvent): The mouse press event.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.handle_mouse_release","title":"<code>handle_mouse_release(event)</code>","text":"<p>Handle mouse release events, such as resetting the active handle or stopping drawing/erasing operations.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QMouseEvent</code> <p>The mouse release event.</p> required Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def handle_mouse_release(self, event):\n    \"\"\"\n    Handle mouse release events, such as resetting the active handle or stopping\n    drawing/erasing operations.\n\n    Args:\n        event (QMouseEvent): The mouse release event.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.handle_wheel","title":"<code>handle_wheel(event)</code>","text":"<p>Handle mouse wheel events for adjusting the brush size or zooming the canvas.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QWheelEvent</code> <p>The wheel event.</p> required Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def handle_wheel(self, event):\n    \"\"\"\n    Handle mouse wheel events for adjusting the brush size or zooming the canvas.\n\n    Args:\n        event (QWheelEvent): The wheel event.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.minimumSizeHint","title":"<code>minimumSizeHint()</code>","text":"<p>Return the minimum size hint for the widget.</p> Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def minimumSizeHint(self):\n    \"\"\"Return the minimum size hint for the widget.\"\"\"\n    return QSize(100, 100)\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.save_current_state","title":"<code>save_current_state(steps=1)</code>","text":"<p>Save the current state of the layer, including intermediate states calculated between the previous and current states.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>int</code> <p>The number of intermediate steps to calculate between</p> <code>1</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def save_current_state(self, steps: int = 1):\n    \"\"\"\n    Save the current state of the layer, including intermediate states\n    calculated between the previous and current states.\n\n    Args:\n        steps (int): The number of intermediate steps to calculate between\n\n    Returns:\n        None\n    \"\"\"\n    curr_states = {}\n    mode = self.mouse_mode\n\n    for layer in self.layers:\n        # Calculate intermediate states between previous_state and current_state\n        intermediate_states = calculate_intermediate_states(\n            layer.previous_state, layer.layer_state.copy(), steps\n        )\n        is_selected = layer.selected\n\n        for step, state in enumerate(intermediate_states):\n            step += self.current_step\n\n            logger.info(f\"Saving state {step} for layer {layer.layer_id}\")\n            state.selected = False\n            if step not in curr_states:\n                curr_states[step] = []\n\n            # Deep copy the drawing states to avoid unintended modifications\n            state.drawing_states = [\n                DrawingState(\n                    position=d.position,\n                    color=d.color,\n                    size=d.size,\n                )\n                for d in layer.layer_state.drawing_states\n            ]\n            curr_states[step].append(state)\n\n        # Update the layer's previous_state to the current state\n        layer.previous_state = layer.layer_state.copy()\n        layer.selected = is_selected\n\n    # Save the calculated states in self.states\n    for step, states in curr_states.items():\n        self.states[step] = states\n        self.current_step = step\n\n    # Save the current layer's state\n    self.previous_state = self.layer_state.copy()\n    self.layer_state.drawing_states = [\n        DrawingState(\n            position=d.position,\n            color=d.color,\n            size=d.size,\n        )\n        for d in self.layer_state.drawing_states\n    ]\n\n    # Emit a message signal indicating the state has been saved\n    self.messageSignal.emit(f\"Saved state {self.current_step}\")\n    self.mouse_mode = mode\n\n    self.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.set_image","title":"<code>set_image(image_path)</code>","text":"<p>Set the image for the layer from a file path, QPixmap, or QImage.</p> Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def set_image(self, image_path: Path | QPixmap | QImage):\n    \"\"\"\n    Set the image for the layer from a file path, QPixmap, or QImage.\n    \"\"\"\n    if isinstance(image_path, Path):\n        self.file_path = image_path\n\n        if image_path.exists():\n            self.image.load(str(image_path))\n            self.reset_view()\n            self.update()\n    elif isinstance(image_path, QPixmap):\n        self.image = image_path\n        self.reset_view()\n        self.update()\n    elif isinstance(image_path, QImage):\n        self.image = QPixmap.fromImage(image_path)\n        self.reset_view()\n        self.update()\n\n    self._original_image = self.image.copy()  # Store a copy of the original image\n    self.original_size = QSizeF(self.image.size())  # Store original size\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.set_mode","title":"<code>set_mode(mode)</code>","text":"<p>Set the mouse interaction mode for the layer.</p> Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def set_mode(self, mode: MouseMode):\n    \"\"\"\n    Set the mouse interaction mode for the layer.\n    \"\"\"\n    # Preserve current annotation when changing modes\n    if mode == self.mouse_mode:\n        return\n\n    # Only reset if switching to a different annotation mode\n    if mode not in [MouseMode.POLYGON, MouseMode.RECTANGLE, MouseMode.POINT]:\n        self.current_annotation = None\n\n    self.mouse_mode = mode\n    logger.debug(f\"Layer {self.layer_id}: Mode set to {mode}\")\n    self.update()\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.update_cursor","title":"<code>update_cursor()</code>","text":"<p>Update the cursor based on the current mouse mode.</p> Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def update_cursor(self):\n    \"\"\"\n    Update the cursor based on the current mouse mode.\n    \"\"\"\n    if MouseMode.POINT == self.mouse_mode:\n        self.setCursor(CursorDef.POINT_CURSOR)\n    elif MouseMode.RECTANGLE == self.mouse_mode:\n        self.setCursor(CursorDef.RECTANGLE_CURSOR)\n    elif MouseMode.POLYGON == self.mouse_mode:\n        self.setCursor(CursorDef.POLYGON_CURSOR)\n    elif MouseMode.PAN == self.mouse_mode:\n        self.setCursor(CursorDef.PAN_CURSOR)\n    elif MouseMode.IDLE == self.mouse_mode:\n        self.setCursor(CursorDef.IDLE_CURSOR)\n    elif MouseMode.RESIZE == self.mouse_mode:\n        self.setCursor(CursorDef.RECTANGLE_CURSOR)\n    elif MouseMode.RESIZE_HEIGHT == self.mouse_mode:\n        self.setCursor(CursorDef.TRANSFORM_UPDOWN)\n    elif MouseMode.RESIZE_WIDTH == self.mouse_mode:\n        self.setCursor(CursorDef.TRANSFORM_LEFTRIGHT)\n    elif MouseMode.GRAB == self.mouse_mode:\n        self.setCursor(CursorDef.GRAB_CURSOR)\n    elif self.mouse_mode == MouseMode.DRAW:\n        # Create a custom cursor for drawing (circle representing brush size)\n        self.setCursor(self._create_custom_cursor(self.drawing_color, \"circle\"))\n\n    elif self.mouse_mode == MouseMode.ERASE:\n        # Create a custom cursor for erasing (square representing eraser size)\n        self.setCursor(self._create_custom_cursor(Qt.white, \"square\"))\n\n    else:\n        # Reset to default cursor\n        self.setCursor(Qt.ArrowCursor)\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.base_layer.BaseLayer.widget_to_image_pos","title":"<code>widget_to_image_pos(pos)</code>","text":"<p>Convert a widget position to an image position.</p> Source code in <code>imagebaker/layers/base_layer.py</code> <pre><code>def widget_to_image_pos(self, pos: QPointF) -&gt; QPointF:\n    \"\"\"\n    Convert a widget position to an image position.\n    \"\"\"\n    return QPointF(\n        (pos.x() - self.offset.x()) / self.scale,\n        (pos.y() - self.offset.y()) / self.scale,\n    )\n</code></pre>"},{"location":"api-reference/#canvas-layer","title":"Canvas Layer","text":"<p>               Bases: <code>BaseLayer</code></p> Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>class CanvasLayer(BaseLayer):\n    layersChanged = Signal()\n    layerSelected = Signal(BaseLayer)\n    annotationAdded = Signal(Annotation)\n    annotationUpdated = Signal(Annotation)\n    bakingResult = Signal(BakingResult)\n    thumbnailsAvailable = Signal(int)\n\n    def __init__(self, parent=None, config=CanvasConfig()):\n        \"\"\"\n        Initialize the CanvasLayer with a parent widget and configuration.\n\n        Args:\n            parent (QWidget, optional): The parent widget for this layer. Defaults to None.\n            config (CanvasConfig): Configuration settings for the canvas layer.\n        \"\"\"\n        super().__init__(parent, config)\n        self.is_annotable = False\n        self.last_pan_point = None\n        self.state_thumbnail = dict()\n\n        self._last_draw_point = None  # Track the last point for smooth drawing\n\n    def init_ui(self):\n        \"\"\"\n        Initialize the user interface for the canvas layer, including size policies\n        and storing the original size of the layer.\n        \"\"\"\n        logger.info(f\"Initializing Layer UI of {self.layer_name}\")\n        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n        self.original_size = QSizeF(self.image.size())  # Store original size\n\n    def handle_key_release(self, event: QKeyEvent):\n        \"\"\"\n        Handle key release events, such as resetting the mouse mode when the Control key is released.\n\n        Args:\n            event (QKeyEvent): The key release event.\n        \"\"\"\n        if event.key() == Qt.Key_Control:\n            if self.mouse_mode not in [MouseMode.DRAW, MouseMode.ERASE]:\n                self.mouse_mode = MouseMode.IDLE\n\n    def _update_back_buffer(self):\n        \"\"\"\n        Update the back buffer for the canvas layer by rendering all visible layers\n        with their transformations and opacity settings.\n        \"\"\"\n        # Initialize the back buffer\n        self._back_buffer = QPixmap(self.size())\n        self._back_buffer.fill(Qt.GlobalColor.transparent)\n\n        # Initialize the layer masks dictionary if it doesn't exist\n        if not hasattr(self, \"layer_masks\"):\n            self.layer_masks = {}\n\n        painter = QPainter(self._back_buffer)\n        try:\n            painter.setRenderHints(\n                QPainter.RenderHint.Antialiasing\n                | QPainter.RenderHint.SmoothPixmapTransform\n            )\n\n            for layer in self.layers:\n                if layer.visible and not layer.image.isNull():\n                    # Save the painter state\n                    painter.save()\n\n                    # Apply layer transformations\n                    painter.translate(layer.position)\n                    painter.rotate(layer.rotation)\n                    painter.scale(layer.scale, layer.scale)\n\n                    # Draw the layer onto the back buffer\n                    painter.setOpacity(layer.opacity)\n                    painter.drawPixmap(QPoint(0, 0), layer.image)\n\n                    # Restore the painter state\n                    painter.restore()\n        finally:\n            painter.end()\n\n        self.image = self._back_buffer\n\n    ## Helper functions ##\n    def handle_key_press(self, event: QKeyEvent):\n\n        # Handle Delete key\n        if event.key() == Qt.Key_Delete:\n            self._delete_layer()\n            return  # Important: return after handling\n\n        # Handle Ctrl key\n        if event.key() == Qt.Key_Control:\n            if self.mouse_mode not in [MouseMode.DRAW, MouseMode.ERASE]:\n                self.mouse_mode = MouseMode.PAN\n\n            return  # Important: return after handling\n\n        # Handle Ctrl+C\n        if event.modifiers() &amp; Qt.ControlModifier and event.key() == Qt.Key_C:\n            self._copy_layer()\n            return  # Important: return after handling\n\n        # Handle Ctrl+V\n        if event.modifiers() &amp; Qt.ControlModifier and event.key() == Qt.Key_V:\n            self._paste_layer()\n            return  # Important: return after handling\n\n    def paint_layer(self, painter: QPainter):\n        \"\"\"\n        Paint the canvas layer, including all visible layers, their transformations,\n        and any drawing states or selection indicators.\n\n        Args:\n            painter (QPainter): The painter object used for rendering.\n        \"\"\"\n        painter.translate(self.pan_offset)\n        painter.scale(self.scale, self.scale)\n        for layer in self.layers:\n            if layer.visible and not layer.image.isNull():\n                painter.save()\n                painter.translate(layer.position)\n                painter.rotate(layer.rotation)\n                painter.scale(layer.scale_x, layer.scale_y)\n\n                # painter.drawPixmap(0, 0, layer.image)\n                # painter.setOpacity(layer.opacity / 255)\n                # Create a new pixmap with adjusted opacity\n                pixmap_with_alpha = QPixmap(layer.image.size())\n                pixmap_with_alpha.fill(Qt.transparent)  # Ensure transparency\n\n                # Use QPainter to apply opacity to the pixmap\n                temp_painter = QPainter(pixmap_with_alpha)\n                opacity = layer.opacity / 255.0\n                temp_painter.setOpacity(opacity)  # Scale opacity to 0.0-1.0\n                temp_painter.drawPixmap(0, 0, layer.image)\n\n                temp_painter.end()\n\n                # Draw the modified pixmap\n                painter.drawPixmap(0, 0, pixmap_with_alpha)\n\n                if layer.selected:\n                    painter.setPen(\n                        QPen(\n                            self.config.selected_draw_config.color,\n                            self.config.selected_draw_config.line_width,\n                        )\n                    )\n                    painter.setBrush(\n                        QBrush(\n                            QColor(\n                                self.config.selected_draw_config.color.red(),\n                                self.config.selected_draw_config.color.green(),\n                                self.config.selected_draw_config.color.blue(),\n                                self.config.selected_draw_config.brush_alpha,\n                            )\n                        )\n                    )\n                    painter.drawRect(QRectF(QPointF(0, 0), layer.original_size))\n                painter.restore()\n\n                if layer.selected:\n                    self._draw_transform_handles(painter, layer)\n                if layer.layer_state.drawing_states:\n                    painter.save()\n                    painter.translate(layer.position)\n                    painter.rotate(layer.rotation)\n                    painter.scale(layer.scale_x, layer.scale_y)\n\n                    for state in layer.layer_state.drawing_states:\n                        painter.setRenderHints(QPainter.Antialiasing)\n                        painter.setPen(\n                            QPen(\n                                state.color,\n                                state.size,\n                                Qt.SolidLine,\n                                Qt.RoundCap,\n                                Qt.RoundJoin,\n                            )\n                        )\n                        # Draw the point after applying transformations\n                        painter.drawPoint(state.position)\n\n                    painter.restore()\n        if self.layer_state.drawing_states:\n            painter.save()\n            painter.translate(self.position)\n            painter.rotate(self.rotation)\n            painter.scale(self.scale_x, self.scale_y)\n\n            for state in self.layer_state.drawing_states:\n                painter.setRenderHints(QPainter.Antialiasing)\n                painter.setPen(\n                    QPen(\n                        state.color,\n                        state.size,\n                        Qt.SolidLine,\n                        Qt.RoundCap,\n                        Qt.RoundJoin,\n                    )\n                )\n                painter.drawPoint(state.position)\n\n            painter.restore()\n        painter.end()\n\n    def _draw_transform_handles(self, painter, layer):\n        \"\"\"\n        Draw rotation and scaling handles for the selected layer.\n\n        Args:\n            painter (QPainter): The painter object used for rendering.\n            layer (BaseLayer): The layer for which the handles are drawn.\n        \"\"\"\n        # Create transform including both scales\n        transform = QTransform()\n        transform.translate(layer.position.x(), layer.position.y())\n        transform.rotate(layer.rotation)\n        transform.scale(layer.scale_x, layer.scale_y)\n\n        # Get transformed rect\n        rect = transform.mapRect(QRectF(QPointF(0, 0), layer.original_size))\n\n        # Adjust handle positions to stay on edges\n        handle_size = 10 / self.scale\n        rotation_pos = rect.center()\n\n        # Scale handles (directly on corners/edges)\n        corners = [\n            rect.topLeft(),\n            rect.topRight(),\n            rect.bottomLeft(),\n            rect.bottomRight(),\n        ]\n        edges = [\n            QPointF(rect.center().x(), rect.top()),\n            QPointF(rect.center().x(), rect.bottom()),\n            QPointF(rect.left(), rect.center().y()),\n            QPointF(rect.right(), rect.center().y()),\n        ]\n\n        # Draw rotation handle at the center and fill it\n        painter.setPen(\n            QPen(\n                self.config.selected_draw_config.handle_color,\n                self.config.selected_draw_config.handle_width / self.scale,\n            )\n        )\n        painter.setBrush(self.config.selected_draw_config.handle_color)\n        painter.drawEllipse(\n            rotation_pos,\n            self.config.selected_draw_config.handle_point_size * 1.1 / self.scale,\n            self.config.selected_draw_config.handle_point_size * 1.1 / self.scale,\n        )\n        # now draw rotation symbol\n        painter.setPen(\n            QPen(\n                self.config.selected_draw_config.handle_color,\n                self.config.selected_draw_config.handle_width / self.scale,\n            )\n        )\n        painter.drawLine(\n            rotation_pos,\n            rotation_pos + QPointF(0, -handle_size),\n        )\n        painter.drawLine(\n            rotation_pos,\n            rotation_pos + QPointF(0, handle_size),\n        )\n        painter.drawLine(\n            rotation_pos,\n            rotation_pos + QPointF(-handle_size, 0),\n        )\n        painter.drawLine(\n            rotation_pos,\n            rotation_pos + QPointF(handle_size, 0),\n        )\n\n        # Draw scale handles\n        handle_color = self.config.selected_draw_config.handle_color\n        painter.setPen(\n            QPen(\n                handle_color, self.config.selected_draw_config.handle_width / self.scale\n            )\n        )\n        painter.setBrush(self.config.selected_draw_config.handle_color)\n        for corner in corners:\n            painter.drawEllipse(\n                corner,\n                self.config.selected_draw_config.handle_point_size / self.scale,\n                self.config.selected_draw_config.handle_point_size / self.scale,\n            )\n        for edge in edges:\n            # draw small circles on the edges\n            painter.drawEllipse(\n                edge,\n                self.config.selected_draw_config.handle_edge_size / self.scale,\n                self.config.selected_draw_config.handle_edge_size / self.scale,\n            )\n            # draw sides\n            painter.drawLine(\n                edge + QPointF(-handle_size, 0),\n                edge + QPointF(handle_size, 0),\n            )\n            painter.drawLine(\n                edge + QPointF(0, -handle_size),\n                edge + QPointF(0, handle_size),\n            )\n\n    def _add_drawing_state(self, pos: QPointF):\n        \"\"\"\n        Add a new drawing state to the selected layer or the canvas layer itself,\n        based on the current mouse mode (DRAW or ERASE).\n\n        Args:\n            pos (QPointF): The position where the drawing state is added.\n        \"\"\"\n        \"\"\"Add a new drawing state.\"\"\"\n        self.selected_layer = self._get_selected_layer()\n        layer = self.selected_layer if self.selected_layer else self\n\n        # Convert the position to be relative to the layer\n        relative_pos = pos - layer.position\n\n        if self.mouse_mode == MouseMode.ERASE:\n            # Remove drawing states within the eraser's area\n            layer.layer_state.drawing_states = [\n                state\n                for state in layer.layer_state.drawing_states\n                if (state.position - relative_pos).manhattanLength() &gt; self.brush_size\n            ]\n        elif self.mouse_mode == MouseMode.DRAW:\n            # Add a new drawing state only if the position has changed\n            # if self._last_draw_point is None or self._last_draw_point != relative_pos:\n            drawing_state = DrawingState(\n                position=relative_pos,  # Store relative position\n                color=self.drawing_color,\n                size=self.brush_size,\n            )\n            layer.layer_state.drawing_states.append(drawing_state)\n            self._last_draw_point = relative_pos  # Update the last draw point\n            # logger.debug(f\"Added drawing state at position: {relative_pos}\")\n\n        self.update()  # Refresh the canvas to show the new drawing\n\n    def handle_wheel(self, event: QWheelEvent):\n        if self.mouse_mode == MouseMode.DRAW or self.mouse_mode == MouseMode.ERASE:\n            # Adjust the brush size using the mouse wheel\n            delta = event.angleDelta().y() / 120  # Each step is 120 units\n            self.brush_size = max(\n                1, self.brush_size + int(delta)\n            )  # Ensure size is &gt;= 1\n            self.messageSignal.emit(f\"Brush size: {self.brush_size}\")\n            self.update()  # Refresh the canvas to show the updated brush cursor\n            return\n        if event.modifiers() &amp; Qt.ControlModifier:\n            # Get mouse position in widget coordinates\n            mouse_pos = event.position()\n\n            # Calculate zoom factor\n            zoom_factor = 1.25 if event.angleDelta().y() &gt; 0 else 0.8\n            old_scale = self.scale\n            new_scale = max(0.1, min(old_scale * zoom_factor, 10.0))\n\n            # Calculate the image point under the cursor before zooming\n            before_zoom_img_pos = (mouse_pos - self.pan_offset) / old_scale\n\n            # Update scale\n            self.scale = new_scale\n\n            # Calculate the new position of the same image point after zooming\n            after_zoom_widget_pos = before_zoom_img_pos * new_scale + self.pan_offset\n\n            # Adjust pan offset to keep the image point under the cursor fixed\n            self.pan_offset += mouse_pos - after_zoom_widget_pos\n\n            # Update mouse mode based on zoom direction\n            self.mouse_mode = (\n                MouseMode.ZOOM_IN if event.angleDelta().y() &gt; 0 else MouseMode.ZOOM_OUT\n            )\n\n            self.zoomChanged.emit(self.scale)\n            self.update()\n\n    def handle_mouse_release(self, event: QMouseEvent):\n\n        if event.button() == Qt.LeftButton:\n            self._active_handle = None\n            self._dragging_layer = None\n\n            # Reset drawing state\n            if self.mouse_mode in [MouseMode.DRAW, MouseMode.ERASE]:\n                self._last_draw_point = None\n                self.update()  # Refresh the canvas to show the updated brush cursor\n\n    def handle_mouse_move(self, event: QMouseEvent):\n        pos = (event.position() - self.pan_offset) / self.scale\n        # logger.info(f\"Drawing states: {self.layer_state.drawing_states}\")\n\n        # Update cursor position for the brush\n        self._cursor_position = event.position()\n\n        if event.buttons() &amp; Qt.LeftButton:\n            # Handle drawing or erasing\n            if self.mouse_mode in [MouseMode.DRAW, MouseMode.ERASE]:\n                self._add_drawing_state(pos)\n                # self._last_draw_point = pos\n                return\n\n        if self.mouse_mode == MouseMode.PAN:\n            if (\n                event.modifiers() &amp; Qt.ControlModifier\n                and event.buttons() &amp; Qt.LeftButton\n            ):\n                if self.last_pan_point:\n                    delta = event.position() - self.last_pan_point\n                    self.pan_offset += delta\n                    self.last_pan_point = event.position()\n                    self.update()\n                    return\n            else:\n                self.last_pan_point = None\n                self.mouse_mode = MouseMode.IDLE\n\n        if self._active_handle:\n            handle_type, layer = self._active_handle\n            start = self._drag_start\n            if \"rotate\" in handle_type:\n                start = self._drag_start\n                center = start[\"center\"]\n\n                # Calculate rotation delta from the initial angle\n                current_vector = pos - center\n                current_angle = math.atan2(current_vector.y(), current_vector.x())\n                angle_delta = math.degrees(current_angle - start[\"initial_angle\"])\n\n                new_transform = QTransform()\n                new_transform.translate(center.x(), center.y())\n                new_transform.rotate(angle_delta)\n                new_transform.translate(-center.x(), -center.y())\n\n                new_position = new_transform.map(start[\"position\"])\n\n                # Update the layer using the original reference data\n                layer.rotation = (start[\"rotation\"] + angle_delta) % 360\n                layer.position = new_position\n\n                logger.info(\n                    f\"Rotating layer {layer.layer_name} around center to {layer.rotation:.2f} degrees\"\n                )\n                self.messageSignal.emit(\n                    f\"Rotating layer {layer.layer_name} to {layer.rotation:.2f} degrees\"\n                )\n                layer.selected = True\n                self.layersChanged.emit()\n\n                return\n            elif \"scale\" in handle_type:\n                # Improved scaling logic\n                handle_index = int(handle_type.split(\"_\")[-1])\n                original_size = layer.original_size\n                delta = pos - start[\"pos\"]\n\n                # Calculate new scale factors\n                new_scale_x = layer.scale_x\n                new_scale_y = layer.scale_y\n\n                # Calculate position offset (for handles that move the layer)\n                pos_offset = QPointF(0, 0)\n\n                # Handle all 8 scale handles\n                if handle_index in [0]:  # Top-left\n                    new_scale_x = start[\"scale_x\"] - delta.x() / original_size.width()\n                    new_scale_y = start[\"scale_y\"] - delta.y() / original_size.height()\n                    pos_offset = delta\n                    self.setCursor(CursorDef.TRANSFORM_ALL)\n\n                elif handle_index in [1]:  # Top-right\n                    new_scale_x = start[\"scale_x\"] + delta.x() / original_size.width()\n                    new_scale_y = start[\"scale_y\"] - delta.y() / original_size.height()\n                    pos_offset = QPointF(0, delta.y())\n                    self.mouse_mode = MouseMode.RESIZE\n                elif handle_index in [2]:  # Bottom-left\n                    new_scale_x = start[\"scale_x\"] - delta.x() / original_size.width()\n                    new_scale_y = start[\"scale_y\"] + delta.y() / original_size.height()\n                    pos_offset = QPointF(delta.x(), 0)\n                    self.mouse_mode = MouseMode.RESIZE\n                elif handle_index in [3]:  # Bottom-right\n                    new_scale_x = start[\"scale_x\"] + delta.x() / original_size.width()\n                    new_scale_y = start[\"scale_y\"] + delta.y() / original_size.height()\n                    self.mouse_mode = MouseMode.RESIZE\n                elif handle_index in [4]:  # Top-center\n                    new_scale_y = start[\"scale_y\"] - delta.y() / original_size.height()\n                    pos_offset = QPointF(0, delta.y())\n                    self.mouse_mode = MouseMode.RESIZE_HEIGHT\n                elif handle_index in [5]:  # Bottom-center\n                    new_scale_y = start[\"scale_y\"] + delta.y() / original_size.height()\n                    self.mouse_mode = MouseMode.RESIZE_HEIGHT\n                elif handle_index in [6]:  # Left-center\n                    new_scale_x = start[\"scale_x\"] - delta.x() / original_size.width()\n                    self.mouse_mode = MouseMode.RESIZE_WIDTH\n                    pos_offset = QPointF(delta.x(), 0)\n                elif handle_index in [7]:  # Right-center\n                    new_scale_x = start[\"scale_x\"] + delta.x() / original_size.width()\n                    self.mouse_mode = MouseMode.RESIZE_WIDTH\n\n                # Apply scale limits\n                new_scale_x = max(0.1, min(new_scale_x, 5.0))\n                new_scale_y = max(0.1, min(new_scale_y, 5.0))\n\n                # Update layer properties\n                layer.scale_x = new_scale_x\n                layer.scale_y = new_scale_y\n\n                # Adjust position for handles that move the layer\n                if handle_index in [0, 1, 2, 4, 6]:\n                    layer.position = start[\"position\"] + pos_offset\n\n                logger.info(\n                    f\"Scaling layer {layer.layer_name} to {layer.scale_x:.2f}, {layer.scale_y:.2f}\"\n                )\n                self.messageSignal.emit(\n                    f\"Scaling layer {layer.layer_name} to {layer.scale_x:.2f}, {layer.scale_y:.2f}\"\n                )\n\n                self.layersChanged.emit()\n            self.update()\n        elif self._dragging_layer:\n            self._dragging_layer.position = pos - self._drag_offset\n            self._dragging_layer.selected = True\n            self._dragging_layer.update()\n            # set all other layers to not selected\n            for layer in self.layers:\n                if layer != self._dragging_layer:\n                    layer.selected = False\n\n            self.layersChanged.emit()\n            self.update()\n\n    def handle_mouse_press(self, event: QMouseEvent):\n        if event.button() == Qt.LeftButton:\n            pos = (event.position() - self.pan_offset) / self.scale\n            if self.mouse_mode in [MouseMode.DRAW, MouseMode.ERASE]:\n                logger.info(f\"Drawing mode: {self.mouse_mode} at position: {pos}\")\n                # Add a drawing state immediately on mouse press\n                self._last_draw_point = pos\n                self._add_drawing_state(pos)  # Add the drawing state here\n                return\n            if event.modifiers() &amp; Qt.ControlModifier:\n                self.mouse_mode = MouseMode.PAN\n                self.last_pan_point = event.position()\n                return\n            # Check handles first\n            for layer in reversed(self.layers):\n                if layer.selected and layer.visible:\n                    # Compute visual center (ignoring rotation for the pivot)\n                    handle_size = 10 / self.scale\n                    transform = QTransform()\n                    transform.translate(layer.position.x(), layer.position.y())\n                    transform.rotate(layer.rotation)  # now includes rotation!\n                    transform.scale(layer.scale_x, layer.scale_y)\n                    visual_rect = transform.mapRect(\n                        QRectF(QPointF(0, 0), layer.original_size)\n                    )\n                    visual_center = visual_rect.center()\n\n                    handle_size = 10 / self.scale\n                    if QLineF(pos, visual_center).length() &lt; handle_size:\n                        vec = pos - visual_center\n                        initial_angle = math.atan2(vec.y(), vec.x())\n                        self._active_handle = (\"rotate\", layer)\n                        self._drag_start = {\n                            \"pos\": pos,\n                            \"rotation\": layer.rotation,\n                            \"center\": visual_center,\n                            \"initial_angle\": initial_angle,\n                            \"position\": layer.position,  # Store the initial position\n                        }\n                        return\n\n                    # Check scale handles (using fully transformed rect)\n                    full_transform = QTransform()\n                    full_transform.translate(layer.position.x(), layer.position.y())\n                    full_transform.rotate(layer.rotation)\n                    full_transform.scale(layer.scale_x, layer.scale_y)\n                    full_rect = full_transform.mapRect(\n                        QRectF(QPointF(0, 0), layer.original_size)\n                    )\n                    full_center = full_rect.center()\n\n                    scale_handles = [\n                        full_rect.topLeft(),\n                        full_rect.topRight(),\n                        full_rect.bottomLeft(),\n                        full_rect.bottomRight(),\n                        QPointF(full_center.x(), full_rect.top()),\n                        QPointF(full_center.x(), full_rect.bottom()),\n                        QPointF(full_rect.left(), full_center.y()),\n                        QPointF(full_rect.right(), full_center.y()),\n                    ]\n                    for i, handle_pos in enumerate(scale_handles):\n                        if QLineF(pos, handle_pos).length() &lt; handle_size:\n                            self._active_handle = (f\"scale_{i}\", layer)\n                            self._drag_start = {\n                                \"pos\": pos,\n                                \"scale_x\": layer.scale_x,\n                                \"scale_y\": layer.scale_y,\n                                \"position\": layer.position,\n                            }\n                            return\n\n            # Check layer selection\n            for layer in reversed(self.layers):\n                if layer.visible:\n                    transform = QTransform()\n                    transform.translate(layer.position.x(), layer.position.y())\n                    transform.rotate(layer.rotation)\n                    transform.scale(layer.scale_x, layer.scale_y)\n                    rect = transform.mapRect(QRectF(QPointF(0, 0), layer.original_size))\n\n                    if rect.contains(pos):\n                        self._dragging_layer = layer\n                        self._drag_offset = pos - layer.position\n                        layer.selected = True\n                        # then set all other layers to not selected\n                        for other_layer in self.layers:\n                            if other_layer != layer:\n                                other_layer.selected = False\n                        layer.update()\n                        self.layersChanged.emit()\n\n                        break\n        # if right click, deselect all layers\n        elif event.button() == Qt.RightButton:\n            for layer in self.layers:\n                layer.selected = False\n            self.mouse_mode = MouseMode.IDLE\n            self.layersChanged.emit()\n            self.update()\n\n    def handle_mouse_double_click(self, event: QMouseEvent, pos: QPoint):\n        # was just trying to select/deselect layers with double click\n        # if left double click\n        # if event.button() == Qt.LeftButton:\n        #     # did we click on a layer?\n        #     pos = (event.position() - self.pan_offset) / self.scale\n        #     selected_layer = None\n        #     # Find clicked layer\n        #     for layer in reversed(self.layers):\n        #         if layer.visible:\n        #             # Create transform including scale\n        #             transform = QTransform()\n        #             transform.translate(layer.position.x(), layer.position.y())\n        #             transform.rotate(layer.rotation)\n        #             transform.scale(layer.scale_x, layer.scale_y)\n        #             rect = transform.mapRect(QRectF(QPointF(0, 0), layer.original_size))\n        #             if rect.contains(pos):\n        #                 selected_layer = layer\n        #                 break\n\n        #     if selected_layer:\n        #         # toggle selection\n        #         selected_layer.selected = not selected_layer.selected\n        #         # make all other layers unselected\n        #         for layer in self.layers:\n        #             if layer != selected_layer:\n        #                 layer.selected = False\n        #     else:\n        #         # we clicked on the background\n        #         # make all layers unselected\n        #         for layer in self.layers:\n        #             layer.selected = False\n        self.update()\n\n    def _get_selected_layer(self):\n        for layer in self.layers:\n            if layer.selected:\n                return layer\n        return None\n\n    def add_layer(self, layer: BaseLayer, index=-1):\n        \"\"\"\n        This function adds a new layer to the canvas layer.\n\n        Args:\n            layer (BaseLayer): The layer to add.\n            index (int, optional): The index at which to add the layer. Defaults to -1.\n\n        Raises:\n            ValueError: If the layer is not a BaseLayer instance\n        \"\"\"\n        layer.layer_name = f\"{len(self.layers) + 1}_\" + layer.layer_name\n        if index &gt;= 0:\n            self.layers.append(layer)\n        else:\n            self.layers.insert(0, layer)\n\n        self._update_back_buffer()\n        self.update()\n        self.messageSignal.emit(f\"Added layer {layer.layer_name}\")\n\n    def clear_layers(self):\n        \"\"\"\n        Clear all layers from the canvas layer.\n        \"\"\"\n        self.layers.clear()\n        self._update_back_buffer()\n        self.update()\n        self.messageSignal.emit(\"Cleared all layers\")\n\n    def _copy_layer(self):\n        \"\"\"\n        Copy the selected layer to the clipboard.\n        \"\"\"\n        self.selected_layer = self._get_selected_layer()\n        if self.selected_layer:\n            self.copied_layer = self.selected_layer.copy()\n            self.messageSignal.emit(f\"Copied layer {self.selected_layer.layer_name}.\")\n        else:\n            self.messageSignal.emit(\"No layer selected to copy.\")\n\n    def _paste_layer(self):\n        \"\"\"\n        Paste the copied layer to the canvas layer.\n        \"\"\"\n        if self.copied_layer:\n            new_layer = self.copied_layer.copy()\n            new_layer.position += QPointF(10, 10)\n            self.add_layer(new_layer, index=0)\n            self.update()\n            self.layerSelected.emit(new_layer)\n            self.messageSignal.emit(f\"Pasted layer {new_layer.layer_name}.\")\n        else:\n            self.messageSignal.emit(\"No layer copied to paste.\")\n\n    def _delete_layer(self):\n        self.selected_layer = self._get_selected_layer()\n        # now handled from bakertab\n        # if self.selected_layer:\n        #     remaining_layers = []\n        #     removed = False\n        #     for layer in self.layers:\n        #         if layer.selected:\n        #             removed = True\n        #             self.messageSignal.emit(f\"Deleted {layer.layer_name} layer.\")\n        #         else:\n        #             remaining_layers.append(layer)\n\n        #     if removed:\n        #         self.layers = remaining_layers\n        #         self._update_back_buffer()\n        #         self.layerRemoved.emit(self.selected_layer)\n        #         self.update()\n\n    def export_current_state(self, export_to_annotation_tab=False):\n        \"\"\"\n        Export the current state of the canvas layer to an image file or annotation tab.\n\n        Args:\n            export_to_annotation_tab (bool, optional): Whether to export the image to the annotation tab. Defaults to False.\n\n        Raises:\n            ValueError: If the layer is not a BaseLayer instance\n        \"\"\"\n        if not self.layers:\n            QMessageBox.warning(\n                self,\n                \"Operation Not Possible\",\n                \"No layers are available to export. Please add layers before exporting.\",\n                QMessageBox.Ok,\n            )\n            return\n        filename = self.config.filename_format.format(\n            project_name=self.config.project_name,\n            timestamp=datetime.now().strftime(\"%Y%m%d_%H%M%S\"),\n        )\n        filename = self.config.export_folder / f\"{filename}.png\"\n        logger.info(f\"Exporting baked image to {filename}\")\n        self.states = {0: [layer.layer_state for layer in self.layers]}\n\n        self.loading_dialog = QProgressDialog(\n            \"Baking Please wait...\", \"Cancel\", 0, 0, self.parentWidget()\n        )\n\n        self.loading_dialog.setWindowTitle(\"Please Wait\")\n        self.loading_dialog.setWindowModality(Qt.WindowModal)\n        self.loading_dialog.setCancelButton(None)  # Remove cancel button if not needed\n        self.loading_dialog.show()\n\n        # Force UI update\n        QApplication.processEvents()\n\n        # Setup worker thread\n        self.worker_thread = QThread()\n        self.worker = BakerWorker(\n            layers=self.layers,\n            states=self.states,\n            filename=filename,\n        )\n        self.worker.moveToThread(self.worker_thread)\n\n        # Connect signals\n        self.worker_thread.started.connect(self.worker.process)\n        self.worker.finished.connect(\n            lambda results, export_to_annotation_tab=export_to_annotation_tab: self.handle_baker_results(\n                results, export_to_annotation_tab=export_to_annotation_tab\n            )\n        )\n        self.worker.finished.connect(self.worker_thread.quit)\n        self.worker.error.connect(self.handle_baker_error)\n\n        # Cleanup connections\n        self.worker.finished.connect(self.worker.deleteLater)\n        self.worker_thread.finished.connect(self.worker_thread.deleteLater)\n        self.worker_thread.finished.connect(self.loading_dialog.close)\n\n        # Start processing\n        self.worker_thread.start()\n\n    def handle_baker_error(self, error_msg):\n        \"\"\"\n        To handle any errors that occur during the baking process.\n        \"\"\"\n        self.loading_dialog.close()\n        QMessageBox.critical(\n            self.parentWidget(), \"Error\", f\"Processing failed: {error_msg}\"\n        )\n\n    def predict_state(self):\n        \"\"\"\n        To send the current state to the prediction tab.\n        \"\"\"\n        self.export_current_state(export_to_annotation_tab=True)\n\n    def seek_state(self, step):\n        \"\"\"Seek to a specific state using the timeline slider.\"\"\"\n        self.messageSignal.emit(f\"Seeking to step {step}\")\n        logger.info(f\"Seeking to step {step}\")\n\n        # Get the states for the selected step\n        if step in self.states:\n            states = self.states[step]\n            for state in states:\n                layer = self.get_layer(state.layer_id)\n                if layer:\n                    # Update the layer's state\n                    update_opacities = False\n                    logger.debug(\n                        f\"Updating layer {layer.layer_name} with state: {state}\"\n                    )\n\n                    if (\n                        layer.edge_width != state.edge_width\n                        or layer.edge_opacity != state.edge_opacity\n                    ):\n                        update_opacities = True\n                    layer.layer_state = state\n                    if update_opacities:\n                        layer._apply_edge_opacity()\n                    layer.update()\n\n    def play_states(self):\n        \"\"\"Play all the states stored in self.states.\"\"\"\n        if len(self.states) == 0:\n            logger.warning(\"No states to play\")\n            self.messageSignal.emit(\"No states to play\")\n            return\n\n        for step, states in sorted(\n            self.states.items()\n        ):  # Ensure states are played in order\n            self.messageSignal.emit(f\"Playing step {step}\")\n            logger.info(f\"Playing step {step}\")\n\n            # Update the slider position\n            self.parentWidget().timeline_slider.setValue(step)\n            # Clear the current drawing states\n\n            for state in states:\n                # Get the layer corresponding to the state\n                layer = self.get_layer(state.layer_id)\n                if layer:\n                    # Update the layer's state\n                    update_opacities = False\n                    logger.debug(\n                        f\"Updating layer {layer.layer_name} with state: {state}\"\n                    )\n\n                    if (\n                        layer.edge_width != state.edge_width\n                        or layer.edge_opacity != state.edge_opacity\n                    ):\n                        update_opacities = True\n                    layer.layer_state = state\n                    if update_opacities:\n                        layer._apply_edge_opacity()\n                    layer.update()\n\n            # Update the UI to reflect the changes\n            self.update()  # Update the current widget\n\n            QApplication.processEvents()  # Process pending events to refresh the UI\n\n            # Wait for the next frame\n            QThread.msleep(int(1000 / self.config.fps))  # Convert FPS to milliseconds\n\n        logger.info(\"Finished playing states\")\n        self.messageSignal.emit(\"Finished playing states\")\n\n    def export_baked_states(self, export_to_annotation_tab=False):\n        \"\"\"Export all the states stored in self.states.\"\"\"\n        if len(self.states) == 0:\n            msg = \"No states to export. Creating a single image.\"\n            logger.warning(msg)\n            self.messageSignal.emit(msg)\n            self.states = {0: [layer.layer_state for layer in self.layers]}\n\n        filename = self.config.filename_format.format(\n            project_name=self.config.project_name,\n            timestamp=datetime.now().strftime(\"%Y%m%d_%H%M%S\"),\n        )\n        filename = self.config.export_folder / f\"{filename}.png\"\n\n        self.loading_dialog = QProgressDialog(\n            \"Exporting states, please wait...\", \"Cancel\", 0, 0, self.parentWidget()\n        )\n        self.loading_dialog.setWindowTitle(\"Please Wait\")\n        self.loading_dialog.setWindowModality(Qt.WindowModal)\n        self.loading_dialog.setCancelButton(None)\n        self.loading_dialog.show()\n\n        QApplication.processEvents()\n\n        # Setup worker thread\n        self.worker_thread = QThread()\n        self.worker = BakerWorker(\n            states=self.states, layers=self.layers, filename=filename\n        )\n        self.worker.moveToThread(self.worker_thread)\n\n        # Connect signals\n        self.worker_thread.started.connect(self.worker.process)\n        self.worker.finished.connect(\n            lambda results, export_to_annotation_tab=export_to_annotation_tab: self.handle_baker_results(\n                results, export_to_annotation_tab\n            )\n        )  # Handle multiple results\n        self.worker.finished.connect(self.worker_thread.quit)\n        self.worker.error.connect(self.handle_baker_error)\n\n        # Cleanup connections\n        self.worker.finished.connect(self.worker.deleteLater)\n        self.worker_thread.finished.connect(self.worker_thread.deleteLater)\n        self.worker_thread.finished.connect(self.loading_dialog.close)\n\n        # Start processing\n        self.worker_thread.start()\n\n    def handle_baker_results(\n        self,\n        baking_results: list[BakingResult],\n        export_to_annotation_tab=False,\n    ):\n        logger.info(\"Baking completed.\")\n        for baking_result in baking_results:\n\n            filename, image = baking_result.filename, baking_result.image\n            masks = baking_result.masks\n            mask_names = baking_result.mask_names\n            annotations = baking_result.annotations\n\n            if not export_to_annotation_tab:\n                image.save(str(filename))\n                logger.info(f\"Saved annotated image to annotated_{filename}\")\n\n                if self.config.is_debug:\n                    if self.config.write_masks:\n                        for i, mask in enumerate(masks):\n                            mask_name = mask_names[i]\n                            write_to = filename.parent / f\"{mask_name}_{filename.name}\"\n\n                            cv2.imwrite(write_to, mask)\n\n                            logger.info(f\"Saved mask for {mask_name}\")\n                    logger.info(f\"Saved baked image to {filename}\")\n                    if self.config.write_annotations:\n                        image = qpixmap_to_numpy(image.copy())\n                        image = cv2.cvtColor(image, cv2.COLOR_RGBA2BGRA)\n                        drawn = draw_annotations(image, annotations)\n                        write_to = filename.parent / f\"annotated_{filename.name}\"\n\n                        cv2.imwrite(str(write_to), drawn)\n\n                        logger.info(f\"Saved annotated image to annotated_{filename}\")\n\n                Annotation.save_as_json(\n                    annotations, f\"{filename.parent/filename.stem}.json\"\n                )\n                logger.info(f\"Saved annotations to {filename}.json\")\n            else:\n                self.bakingResult.emit(baking_result)\n\n    def export_states_to_predict(self):\n        self.export_baked_states(export_to_annotation_tab=True)\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.canvas_layer.CanvasLayer.add_layer","title":"<code>add_layer(layer, index=-1)</code>","text":"<p>This function adds a new layer to the canvas layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>BaseLayer</code> <p>The layer to add.</p> required <code>index</code> <code>int</code> <p>The index at which to add the layer. Defaults to -1.</p> <code>-1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the layer is not a BaseLayer instance</p> Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>def add_layer(self, layer: BaseLayer, index=-1):\n    \"\"\"\n    This function adds a new layer to the canvas layer.\n\n    Args:\n        layer (BaseLayer): The layer to add.\n        index (int, optional): The index at which to add the layer. Defaults to -1.\n\n    Raises:\n        ValueError: If the layer is not a BaseLayer instance\n    \"\"\"\n    layer.layer_name = f\"{len(self.layers) + 1}_\" + layer.layer_name\n    if index &gt;= 0:\n        self.layers.append(layer)\n    else:\n        self.layers.insert(0, layer)\n\n    self._update_back_buffer()\n    self.update()\n    self.messageSignal.emit(f\"Added layer {layer.layer_name}\")\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.canvas_layer.CanvasLayer.clear_layers","title":"<code>clear_layers()</code>","text":"<p>Clear all layers from the canvas layer.</p> Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>def clear_layers(self):\n    \"\"\"\n    Clear all layers from the canvas layer.\n    \"\"\"\n    self.layers.clear()\n    self._update_back_buffer()\n    self.update()\n    self.messageSignal.emit(\"Cleared all layers\")\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.canvas_layer.CanvasLayer.export_baked_states","title":"<code>export_baked_states(export_to_annotation_tab=False)</code>","text":"<p>Export all the states stored in self.states.</p> Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>def export_baked_states(self, export_to_annotation_tab=False):\n    \"\"\"Export all the states stored in self.states.\"\"\"\n    if len(self.states) == 0:\n        msg = \"No states to export. Creating a single image.\"\n        logger.warning(msg)\n        self.messageSignal.emit(msg)\n        self.states = {0: [layer.layer_state for layer in self.layers]}\n\n    filename = self.config.filename_format.format(\n        project_name=self.config.project_name,\n        timestamp=datetime.now().strftime(\"%Y%m%d_%H%M%S\"),\n    )\n    filename = self.config.export_folder / f\"{filename}.png\"\n\n    self.loading_dialog = QProgressDialog(\n        \"Exporting states, please wait...\", \"Cancel\", 0, 0, self.parentWidget()\n    )\n    self.loading_dialog.setWindowTitle(\"Please Wait\")\n    self.loading_dialog.setWindowModality(Qt.WindowModal)\n    self.loading_dialog.setCancelButton(None)\n    self.loading_dialog.show()\n\n    QApplication.processEvents()\n\n    # Setup worker thread\n    self.worker_thread = QThread()\n    self.worker = BakerWorker(\n        states=self.states, layers=self.layers, filename=filename\n    )\n    self.worker.moveToThread(self.worker_thread)\n\n    # Connect signals\n    self.worker_thread.started.connect(self.worker.process)\n    self.worker.finished.connect(\n        lambda results, export_to_annotation_tab=export_to_annotation_tab: self.handle_baker_results(\n            results, export_to_annotation_tab\n        )\n    )  # Handle multiple results\n    self.worker.finished.connect(self.worker_thread.quit)\n    self.worker.error.connect(self.handle_baker_error)\n\n    # Cleanup connections\n    self.worker.finished.connect(self.worker.deleteLater)\n    self.worker_thread.finished.connect(self.worker_thread.deleteLater)\n    self.worker_thread.finished.connect(self.loading_dialog.close)\n\n    # Start processing\n    self.worker_thread.start()\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.canvas_layer.CanvasLayer.export_current_state","title":"<code>export_current_state(export_to_annotation_tab=False)</code>","text":"<p>Export the current state of the canvas layer to an image file or annotation tab.</p> <p>Parameters:</p> Name Type Description Default <code>export_to_annotation_tab</code> <code>bool</code> <p>Whether to export the image to the annotation tab. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the layer is not a BaseLayer instance</p> Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>def export_current_state(self, export_to_annotation_tab=False):\n    \"\"\"\n    Export the current state of the canvas layer to an image file or annotation tab.\n\n    Args:\n        export_to_annotation_tab (bool, optional): Whether to export the image to the annotation tab. Defaults to False.\n\n    Raises:\n        ValueError: If the layer is not a BaseLayer instance\n    \"\"\"\n    if not self.layers:\n        QMessageBox.warning(\n            self,\n            \"Operation Not Possible\",\n            \"No layers are available to export. Please add layers before exporting.\",\n            QMessageBox.Ok,\n        )\n        return\n    filename = self.config.filename_format.format(\n        project_name=self.config.project_name,\n        timestamp=datetime.now().strftime(\"%Y%m%d_%H%M%S\"),\n    )\n    filename = self.config.export_folder / f\"{filename}.png\"\n    logger.info(f\"Exporting baked image to {filename}\")\n    self.states = {0: [layer.layer_state for layer in self.layers]}\n\n    self.loading_dialog = QProgressDialog(\n        \"Baking Please wait...\", \"Cancel\", 0, 0, self.parentWidget()\n    )\n\n    self.loading_dialog.setWindowTitle(\"Please Wait\")\n    self.loading_dialog.setWindowModality(Qt.WindowModal)\n    self.loading_dialog.setCancelButton(None)  # Remove cancel button if not needed\n    self.loading_dialog.show()\n\n    # Force UI update\n    QApplication.processEvents()\n\n    # Setup worker thread\n    self.worker_thread = QThread()\n    self.worker = BakerWorker(\n        layers=self.layers,\n        states=self.states,\n        filename=filename,\n    )\n    self.worker.moveToThread(self.worker_thread)\n\n    # Connect signals\n    self.worker_thread.started.connect(self.worker.process)\n    self.worker.finished.connect(\n        lambda results, export_to_annotation_tab=export_to_annotation_tab: self.handle_baker_results(\n            results, export_to_annotation_tab=export_to_annotation_tab\n        )\n    )\n    self.worker.finished.connect(self.worker_thread.quit)\n    self.worker.error.connect(self.handle_baker_error)\n\n    # Cleanup connections\n    self.worker.finished.connect(self.worker.deleteLater)\n    self.worker_thread.finished.connect(self.worker_thread.deleteLater)\n    self.worker_thread.finished.connect(self.loading_dialog.close)\n\n    # Start processing\n    self.worker_thread.start()\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.canvas_layer.CanvasLayer.handle_baker_error","title":"<code>handle_baker_error(error_msg)</code>","text":"<p>To handle any errors that occur during the baking process.</p> Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>def handle_baker_error(self, error_msg):\n    \"\"\"\n    To handle any errors that occur during the baking process.\n    \"\"\"\n    self.loading_dialog.close()\n    QMessageBox.critical(\n        self.parentWidget(), \"Error\", f\"Processing failed: {error_msg}\"\n    )\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.canvas_layer.CanvasLayer.handle_key_release","title":"<code>handle_key_release(event)</code>","text":"<p>Handle key release events, such as resetting the mouse mode when the Control key is released.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QKeyEvent</code> <p>The key release event.</p> required Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>def handle_key_release(self, event: QKeyEvent):\n    \"\"\"\n    Handle key release events, such as resetting the mouse mode when the Control key is released.\n\n    Args:\n        event (QKeyEvent): The key release event.\n    \"\"\"\n    if event.key() == Qt.Key_Control:\n        if self.mouse_mode not in [MouseMode.DRAW, MouseMode.ERASE]:\n            self.mouse_mode = MouseMode.IDLE\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.canvas_layer.CanvasLayer.init_ui","title":"<code>init_ui()</code>","text":"<p>Initialize the user interface for the canvas layer, including size policies and storing the original size of the layer.</p> Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>def init_ui(self):\n    \"\"\"\n    Initialize the user interface for the canvas layer, including size policies\n    and storing the original size of the layer.\n    \"\"\"\n    logger.info(f\"Initializing Layer UI of {self.layer_name}\")\n    self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n    self.original_size = QSizeF(self.image.size())  # Store original size\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.canvas_layer.CanvasLayer.paint_layer","title":"<code>paint_layer(painter)</code>","text":"<p>Paint the canvas layer, including all visible layers, their transformations, and any drawing states or selection indicators.</p> <p>Parameters:</p> Name Type Description Default <code>painter</code> <code>QPainter</code> <p>The painter object used for rendering.</p> required Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>def paint_layer(self, painter: QPainter):\n    \"\"\"\n    Paint the canvas layer, including all visible layers, their transformations,\n    and any drawing states or selection indicators.\n\n    Args:\n        painter (QPainter): The painter object used for rendering.\n    \"\"\"\n    painter.translate(self.pan_offset)\n    painter.scale(self.scale, self.scale)\n    for layer in self.layers:\n        if layer.visible and not layer.image.isNull():\n            painter.save()\n            painter.translate(layer.position)\n            painter.rotate(layer.rotation)\n            painter.scale(layer.scale_x, layer.scale_y)\n\n            # painter.drawPixmap(0, 0, layer.image)\n            # painter.setOpacity(layer.opacity / 255)\n            # Create a new pixmap with adjusted opacity\n            pixmap_with_alpha = QPixmap(layer.image.size())\n            pixmap_with_alpha.fill(Qt.transparent)  # Ensure transparency\n\n            # Use QPainter to apply opacity to the pixmap\n            temp_painter = QPainter(pixmap_with_alpha)\n            opacity = layer.opacity / 255.0\n            temp_painter.setOpacity(opacity)  # Scale opacity to 0.0-1.0\n            temp_painter.drawPixmap(0, 0, layer.image)\n\n            temp_painter.end()\n\n            # Draw the modified pixmap\n            painter.drawPixmap(0, 0, pixmap_with_alpha)\n\n            if layer.selected:\n                painter.setPen(\n                    QPen(\n                        self.config.selected_draw_config.color,\n                        self.config.selected_draw_config.line_width,\n                    )\n                )\n                painter.setBrush(\n                    QBrush(\n                        QColor(\n                            self.config.selected_draw_config.color.red(),\n                            self.config.selected_draw_config.color.green(),\n                            self.config.selected_draw_config.color.blue(),\n                            self.config.selected_draw_config.brush_alpha,\n                        )\n                    )\n                )\n                painter.drawRect(QRectF(QPointF(0, 0), layer.original_size))\n            painter.restore()\n\n            if layer.selected:\n                self._draw_transform_handles(painter, layer)\n            if layer.layer_state.drawing_states:\n                painter.save()\n                painter.translate(layer.position)\n                painter.rotate(layer.rotation)\n                painter.scale(layer.scale_x, layer.scale_y)\n\n                for state in layer.layer_state.drawing_states:\n                    painter.setRenderHints(QPainter.Antialiasing)\n                    painter.setPen(\n                        QPen(\n                            state.color,\n                            state.size,\n                            Qt.SolidLine,\n                            Qt.RoundCap,\n                            Qt.RoundJoin,\n                        )\n                    )\n                    # Draw the point after applying transformations\n                    painter.drawPoint(state.position)\n\n                painter.restore()\n    if self.layer_state.drawing_states:\n        painter.save()\n        painter.translate(self.position)\n        painter.rotate(self.rotation)\n        painter.scale(self.scale_x, self.scale_y)\n\n        for state in self.layer_state.drawing_states:\n            painter.setRenderHints(QPainter.Antialiasing)\n            painter.setPen(\n                QPen(\n                    state.color,\n                    state.size,\n                    Qt.SolidLine,\n                    Qt.RoundCap,\n                    Qt.RoundJoin,\n                )\n            )\n            painter.drawPoint(state.position)\n\n        painter.restore()\n    painter.end()\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.canvas_layer.CanvasLayer.play_states","title":"<code>play_states()</code>","text":"<p>Play all the states stored in self.states.</p> Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>def play_states(self):\n    \"\"\"Play all the states stored in self.states.\"\"\"\n    if len(self.states) == 0:\n        logger.warning(\"No states to play\")\n        self.messageSignal.emit(\"No states to play\")\n        return\n\n    for step, states in sorted(\n        self.states.items()\n    ):  # Ensure states are played in order\n        self.messageSignal.emit(f\"Playing step {step}\")\n        logger.info(f\"Playing step {step}\")\n\n        # Update the slider position\n        self.parentWidget().timeline_slider.setValue(step)\n        # Clear the current drawing states\n\n        for state in states:\n            # Get the layer corresponding to the state\n            layer = self.get_layer(state.layer_id)\n            if layer:\n                # Update the layer's state\n                update_opacities = False\n                logger.debug(\n                    f\"Updating layer {layer.layer_name} with state: {state}\"\n                )\n\n                if (\n                    layer.edge_width != state.edge_width\n                    or layer.edge_opacity != state.edge_opacity\n                ):\n                    update_opacities = True\n                layer.layer_state = state\n                if update_opacities:\n                    layer._apply_edge_opacity()\n                layer.update()\n\n        # Update the UI to reflect the changes\n        self.update()  # Update the current widget\n\n        QApplication.processEvents()  # Process pending events to refresh the UI\n\n        # Wait for the next frame\n        QThread.msleep(int(1000 / self.config.fps))  # Convert FPS to milliseconds\n\n    logger.info(\"Finished playing states\")\n    self.messageSignal.emit(\"Finished playing states\")\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.canvas_layer.CanvasLayer.predict_state","title":"<code>predict_state()</code>","text":"<p>To send the current state to the prediction tab.</p> Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>def predict_state(self):\n    \"\"\"\n    To send the current state to the prediction tab.\n    \"\"\"\n    self.export_current_state(export_to_annotation_tab=True)\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.canvas_layer.CanvasLayer.seek_state","title":"<code>seek_state(step)</code>","text":"<p>Seek to a specific state using the timeline slider.</p> Source code in <code>imagebaker/layers/canvas_layer.py</code> <pre><code>def seek_state(self, step):\n    \"\"\"Seek to a specific state using the timeline slider.\"\"\"\n    self.messageSignal.emit(f\"Seeking to step {step}\")\n    logger.info(f\"Seeking to step {step}\")\n\n    # Get the states for the selected step\n    if step in self.states:\n        states = self.states[step]\n        for state in states:\n            layer = self.get_layer(state.layer_id)\n            if layer:\n                # Update the layer's state\n                update_opacities = False\n                logger.debug(\n                    f\"Updating layer {layer.layer_name} with state: {state}\"\n                )\n\n                if (\n                    layer.edge_width != state.edge_width\n                    or layer.edge_opacity != state.edge_opacity\n                ):\n                    update_opacities = True\n                layer.layer_state = state\n                if update_opacities:\n                    layer._apply_edge_opacity()\n                layer.update()\n</code></pre>"},{"location":"api-reference/#annotable-layer","title":"Annotable Layer","text":"<p>               Bases: <code>BaseLayer</code></p> Source code in <code>imagebaker/layers/annotable_layer.py</code> <pre><code>class AnnotableLayer(BaseLayer):\n    annotationAdded = Signal(Annotation)\n    annotationRemoved = Signal()\n    annotationUpdated = Signal(Annotation)\n    annotationCleared = Signal()\n    annotationMoved = Signal()\n    layersChanged = Signal()\n    labelUpdated = Signal(tuple)\n\n    def __init__(self, parent, config: LayerConfig, canvas_config: CanvasConfig):\n        super().__init__(parent, config)\n        self.canvas_config = canvas_config\n\n        self.image = QPixmap()\n        self.mouse_mode = MouseMode.POINT\n\n        self.label_rects = []\n        self.file_path: Path = Path(\"Runtime\")\n        self.layers: list[BaseLayer] = []\n        self.is_annotable = True\n        self.handle_zoom: float = 1\n\n    def init_ui(self):\n        logger.info(f\"Initializing Layer UI of {self.layer_name}\")\n        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\n\n    def clear_annotations(self):\n        self.annotations.clear()\n        self.selected_annotation = None\n        self.current_annotation = None\n        self.annotationCleared.emit()\n        self.update()\n\n    def handle_key_press(self, event: QKeyEvent):\n        # Handle Ctrl key for panning\n        if event.key() == Qt.Key_Control:\n            if (\n                self.mouse_mode != MouseMode.POLYGON\n            ):  # Only activate pan mode when not drawing polygons\n\n                self.mouse_mode = MouseMode.PAN\n\n        # Handle Ctrl+C for copy\n        if event.modifiers() &amp; Qt.ControlModifier and event.key() == Qt.Key_C:\n            self._copy_annotation()\n\n        # Handle Ctrl+V for paste\n        if event.modifiers() &amp; Qt.ControlModifier and event.key() == Qt.Key_V:\n            self._paste_annotation()\n\n    def handle_key_release(self, event):\n        if event.key() == Qt.Key_Control:\n            if self.mouse_mode == MouseMode.PAN:\n                self.mouse_mode = MouseMode.IDLE\n\n    def apply_opacity(self):\n        \"\"\"Apply opacity to the QPixmap image.\"\"\"\n        if self.image and self.opacity &lt; 255:\n            # Create a new transparent pixmap with the same size\n            transparent_pixmap = QPixmap(self.image.size())\n            transparent_pixmap.fill(Qt.transparent)\n\n            # Create a painter to draw on the new pixmap\n            painter = QPainter(transparent_pixmap)\n            try:\n                # Set the opacity\n                painter.setOpacity(self.opacity / 255.0)\n\n                # Draw the original image onto the new pixmap\n                painter.drawPixmap(0, 0, self.image)\n            finally:\n                # Ensure the painter is properly ended\n                painter.end()\n\n            # Replace the original image with the transparent version\n            self.image = transparent_pixmap\n\n    def paint_layer(self, painter: QPainter):\n        with QPainter(self) as painter:\n            painter.fillRect(\n                self.rect(),\n                self.config.normal_draw_config.background_color,\n            )\n            painter.setRenderHints(\n                QPainter.Antialiasing | QPainter.SmoothPixmapTransform\n            )\n\n            if not self.image.isNull():\n                painter.save()\n                painter.translate(self.offset)\n                painter.scale(self.scale, self.scale)\n                painter.drawPixmap(0, 0, self.image)\n\n                # Draw all annotations\n                for annotation in self.annotations:\n                    self.draw_annotation(painter, annotation)\n\n                # Draw current annotation\n                if self.current_annotation:\n                    self.draw_annotation(painter, self.current_annotation, is_temp=True)\n\n                painter.restore()\n\n    def draw_annotation(self, painter, annotation: Annotation, is_temp=False):\n        \"\"\"\n        Draw annotation on the image.\n        \"\"\"\n        if not annotation.visible:\n            return\n        painter.save()\n        base_color = annotation.color\n        pen_color = QColor(\n            base_color.red(),\n            base_color.green(),\n            base_color.blue(),\n            self.config.normal_draw_config.pen_alpha,\n        )\n        brush_color = QColor(\n            base_color.red(),\n            base_color.green(),\n            base_color.blue(),\n            self.config.normal_draw_config.brush_alpha,\n        )\n\n        pen = QPen(pen_color, self.config.normal_draw_config.line_width / self.scale)\n        brush = QBrush(brush_color, Qt.DiagCrossPattern)\n\n        if annotation.selected:\n            painter.setPen(\n                QPen(\n                    self.config.selected_draw_config.color,\n                    self.config.selected_draw_config.line_width / self.scale,\n                )\n            )\n            painter.setBrush(\n                QBrush(\n                    QColor(\n                        self.config.selected_draw_config.color.red(),\n                        self.config.selected_draw_config.color.green(),\n                        self.config.selected_draw_config.color.blue(),\n                        self.config.selected_draw_config.brush_alpha,\n                    )\n                )\n            )\n            if annotation.rectangle:\n                painter.drawRect(annotation.rectangle)\n            elif annotation.polygon:\n                painter.drawPolygon(annotation.polygon)\n            elif annotation.points:\n                painter.drawEllipse(\n                    annotation.points[0],\n                    self.config.selected_draw_config.ellipse_size / self.scale,\n                    self.config.selected_draw_config.ellipse_size / self.scale,\n                )\n\n        if is_temp:\n            pen.setStyle(Qt.DashLine)\n            brush.setStyle(Qt.Dense4Pattern)\n\n        painter.setPen(pen)\n        painter.setBrush(brush)\n\n        # Draw main shape\n        if annotation.points:\n            for point in annotation.points:\n                painter.drawEllipse(\n                    point,\n                    self.config.normal_draw_config.point_size / self.scale,\n                    self.config.normal_draw_config.point_size / self.scale,\n                )\n        elif annotation.rectangle:\n            painter.drawRect(annotation.rectangle)\n        elif annotation.polygon:\n            if len(annotation.polygon) &gt; 1:\n                if annotation.is_complete:\n                    painter.drawPolygon(annotation.polygon)\n                else:\n                    painter.drawPolyline(annotation.polygon)\n\n        # Draw control points\n        if annotation.rectangle:\n            rect = annotation.rectangle\n            corners = [\n                rect.topLeft(),\n                rect.topRight(),\n                rect.bottomLeft(),\n                rect.bottomRight(),\n            ]\n            painter.save()\n            painter.setPen(\n                QPen(\n                    Qt.black,\n                    self.config.normal_draw_config.control_point_size / self.scale,\n                )\n            )\n            painter.setBrush(QBrush(Qt.white))\n            for corner in corners:\n                painter.drawEllipse(\n                    corner,\n                    self.config.normal_draw_config.point_size / self.scale,\n                    self.config.normal_draw_config.point_size / self.scale,\n                )\n            painter.restore()\n\n        if annotation.polygon and len(annotation.polygon) &gt; 0:\n            painter.save()\n            painter.setPen(\n                QPen(\n                    Qt.white,\n                    self.config.normal_draw_config.control_point_size / self.scale,\n                )\n            )\n            painter.setBrush(QBrush(Qt.darkGray))\n            for point in annotation.polygon:\n                painter.drawEllipse(\n                    point,\n                    self.config.normal_draw_config.point_size / self.scale,\n                    self.config.normal_draw_config.point_size / self.scale,\n                )\n            painter.restore()\n\n        # Draw labels\n        if annotation.is_complete and annotation.label:\n            painter.save()\n            label_pos = self.get_label_position(annotation)\n            text = annotation.label\n\n            # Convert to widget coordinates\n            widget_pos = QPointF(\n                label_pos.x() * self.scale + self.offset.x(),\n                label_pos.y() * self.scale + self.offset.y(),\n            )\n\n            if annotation.points:\n                widget_pos += QPointF(10, 10)\n\n            # Set up font\n            font = painter.font()\n            font.setPixelSize(\n                self.config.normal_draw_config.label_font_size * self.scale\n            )  # Fixed screen size\n            painter.setFont(font)\n\n            # Calculate text size\n            metrics = painter.fontMetrics()\n            text_width = metrics.horizontalAdvance(text)\n            text_height = metrics.height()\n\n            # Draw background\n            bg_rect = QRectF(\n                widget_pos.x() - text_width / 2 - 2,\n                widget_pos.y() - text_height / 2 - 2,\n                text_width + 4,\n                text_height + 4,\n            )\n            painter.resetTransform()\n            painter.setBrush(self.config.normal_draw_config.label_font_background_color)\n            painter.setPen(Qt.NoPen)\n            painter.drawRect(bg_rect)\n\n            # Draw text\n            painter.setPen(Qt.white)\n            painter.drawText(bg_rect, Qt.AlignCenter, text)\n            painter.restore()\n            self.label_rects.append((bg_rect, annotation))\n\n        painter.restore()\n\n        # Draw transformation handles for selected annotations\n        if annotation.selected and annotation.is_complete:\n            painter.save()\n            handle_color = self.config.selected_draw_config.handle_color\n            painter.setPen(\n                QPen(\n                    handle_color,\n                    self.config.selected_draw_config.handle_width / self.scale,\n                )\n            )\n            painter.setBrush(QBrush(handle_color))\n\n            if annotation.rectangle:\n                rect = annotation.rectangle\n                # Draw corner handles\n                for corner in [\n                    rect.topLeft(),\n                    rect.topRight(),\n                    rect.bottomLeft(),\n                    rect.bottomRight(),\n                ]:\n                    painter.drawEllipse(\n                        corner,\n                        self.config.selected_draw_config.handle_point_size / self.scale,\n                        self.config.selected_draw_config.handle_point_size / self.scale,\n                    )\n                # Draw edge handles\n                for edge in [\n                    QPointF(rect.center().x(), rect.top()),\n                    QPointF(rect.center().x(), rect.bottom()),\n                    QPointF(rect.left(), rect.center().y()),\n                    QPointF(rect.right(), rect.center().y()),\n                ]:\n                    painter.drawEllipse(\n                        edge,\n                        self.config.selected_draw_config.handle_edge_size / self.scale,\n                        self.config.selected_draw_config.handle_edge_size / self.scale,\n                    )\n\n            elif annotation.polygon:\n                # Draw vertex handles\n                for point in annotation.polygon:\n                    painter.drawEllipse(\n                        point,\n                        self.config.selected_draw_config.handle_point_size / self.scale,\n                        self.config.selected_draw_config.handle_point_size / self.scale,\n                    )\n\n            painter.restore()\n\n    def get_label_position(self, annotation: Annotation):\n        if annotation.points:\n            return annotation.points[0]\n        if annotation.rectangle:\n            return annotation.rectangle.center()\n        if annotation.polygon:\n            return annotation.polygon.boundingRect().center()\n        return QPointF()\n\n    def handle_wheel(self, event: QWheelEvent):\n        if event.modifiers() &amp; Qt.ControlModifier:\n            # Get mouse position before zoom\n            old_pos = self.widget_to_image_pos(event.position())\n\n            # Calculate zoom factor\n            zoom_factor = (\n                self.config.zoom_in_factor\n                if event.angleDelta().y() &gt; 0\n                else self.config.zoom_out_factor\n            )\n            new_scale = max(0.1, min(self.scale * zoom_factor, 10.0))\n\n            # Calculate position shift to keep cursor over same image point\n            self.offset += old_pos * self.scale - old_pos * new_scale\n            self.scale = new_scale\n\n            # is wheel going forward or backward\n            if event.angleDelta().y() &gt; 0:\n                self.mouse_mode = MouseMode.ZOOM_IN\n            else:\n                self.mouse_mode = MouseMode.ZOOM_OUT\n\n            self.zoomChanged.emit(self.scale)\n\n    def handle_mouse_release(self, event: QMouseEvent):\n        if event.button() == Qt.LeftButton:\n            if self.mouse_mode == MouseMode.RECTANGLE and self.current_annotation:\n                self.finalize_annotation()\n            elif self.mouse_mode == MouseMode.POLYGON and self.current_annotation:\n                pass\n            elif self.mouse_mode in [\n                MouseMode.PAN,\n                MouseMode.ZOOM_IN,\n                MouseMode.ZOOM_OUT,\n            ]:\n                self.mouse_mode = MouseMode.IDLE\n\n        # Clean up transformation state\n        if hasattr(self, \"selected_annotation\"):\n            self.selected_annotation = None\n        if hasattr(self, \"active_handle\"):\n            del self.active_handle\n        if hasattr(self, \"active_point_index\"):\n            del self.active_point_index\n        if hasattr(self, \"initial_rect\"):\n            del self.initial_rect\n        if hasattr(self, \"initial_polygon\"):\n            del self.initial_polygon\n\n        self.pan_start = None\n        self.drag_start = None\n\n    def handle_mouse_move(self, event: QMouseEvent):\n        # logger.info(f\"Mouse move event: {event.position()} with {self.mouse_mode}\")\n        img_pos = self.widget_to_image_pos(event.position())\n        clamped_pos = QPointF(\n            max(0, min(self.image.width(), img_pos.x())),\n            max(0, min(self.image.height(), img_pos.y())),\n        )\n        self.mouseMoved.emit(img_pos)\n        self.messageSignal.emit(f\"X: {img_pos.x()}, Y: {img_pos.y()}\")\n\n        # if we are not clicking\n        if not event.buttons():\n            annotation, handle = self.find_annotation_and_handle_at(img_pos)\n            if annotation and handle and self.mouse_mode == MouseMode.IDLE:\n                if \"point_\" in handle or handle in [\n                    \"top_left\",\n                    \"top_right\",\n                    \"bottom_left\",\n                    \"bottom_right\",\n                ]:\n                    self.mouse_mode = MouseMode.RESIZE\n                elif \"center\" in handle:\n                    if \"top\" in handle or \"bottom\" in handle:\n                        self.mouse_mode = MouseMode.RESIZE_HEIGHT\n                    else:\n                        self.mouse_mode = MouseMode.RESIZE_WIDTH\n                elif handle == \"move\":\n                    self.mouse_mode = MouseMode.GRAB\n\n            elif not handle and self.mouse_mode in [\n                MouseMode.RESIZE,\n                MouseMode.RESIZE_HEIGHT,\n                MouseMode.RESIZE_WIDTH,\n                MouseMode.GRAB,\n            ]:\n                self.mouse_mode = MouseMode.IDLE\n                # self.mouse_mode = MouseMode.IDLE\n                pass\n            self.update_cursor()\n        else:\n            if (\n                event.buttons() &amp; Qt.LeftButton\n                and self.selected_annotation\n                and self.active_handle\n            ):\n                if self.active_handle == \"move\":\n                    self.setCursor(CursorDef.GRABBING_CURSOR)\n                    new_pos = img_pos - self.drag_offset\n                    self.move_annotation(self.selected_annotation, new_pos)\n                elif self.selected_annotation.rectangle:\n                    rect = QRectF(self.initial_rect)\n\n                    if \"top\" in self.active_handle:\n                        rect.setTop(img_pos.y())\n                    if \"bottom\" in self.active_handle:\n                        rect.setBottom(img_pos.y())\n                    if \"left\" in self.active_handle:\n                        rect.setLeft(img_pos.x())\n                    if \"right\" in self.active_handle:\n                        rect.setRight(img_pos.x())\n\n                    self.selected_annotation.rectangle = rect.normalized()\n                elif self.selected_annotation.polygon and hasattr(\n                    self, \"active_point_index\"\n                ):\n                    self.selected_annotation.polygon[self.active_point_index] = (\n                        clamped_pos\n                    )\n                elif self.selected_annotation.points:\n                    self.selected_annotation.points[0] = clamped_pos\n                self.annotationMoved.emit()\n                self.annotationUpdated.emit(self.selected_annotation)\n                self.update()\n                return\n\n            if self.mouse_mode == MouseMode.PAN and event.buttons() &amp; Qt.LeftButton:\n                if self.pan_start:\n                    delta = event.position() - self.pan_start\n                    self.offset += delta\n                    self.pan_start = event.position()\n                    self.update()\n            elif self.mouse_mode == MouseMode.RECTANGLE and self.drag_start:\n                self.current_annotation.rectangle = QRectF(\n                    self.drag_start, clamped_pos\n                ).normalized()\n                self.update()\n            elif self.mouse_mode == MouseMode.POLYGON and self.current_annotation:\n                if self.current_annotation.polygon:\n                    temp_points = QPolygonF(self.current_annotation.polygon)\n                    if temp_points:\n                        temp_points[-1] = clamped_pos\n                        self.current_annotation.polygon = temp_points\n                        self.update()\n\n    def move_annotation(self, annotation, new_pos: QPointF):\n        delta = new_pos - self.get_annotation_position(annotation)\n\n        if annotation.rectangle:\n            annotation.rectangle.translate(delta)\n        elif annotation.polygon:\n            annotation.polygon.translate(delta)\n        elif annotation.points:\n            annotation.points = [p + delta for p in annotation.points]\n\n    def handle_mouse_press(self, event: QMouseEvent):\n        # logger.info(f\"Mouse press event: {event.position()} with {self.mouse_mode}\")\n        img_pos = self.widget_to_image_pos(event.position())\n        clamped_pos = QPointF(\n            max(0, min(self.image.width(), img_pos.x())),\n            max(0, min(self.image.height(), img_pos.y())),\n        )\n\n        # If right-clicked\n        if event.button() == Qt.RightButton:\n            # If polygon drawing, remove the last point\n            if self.current_annotation and self.mouse_mode == MouseMode.POLYGON:\n                if len(self.current_annotation.polygon) &gt; 0:\n                    self.current_annotation.polygon = QPolygonF(\n                        [p for p in self.current_annotation.polygon][:-1]\n                    )\n\n                # If the polygon is now empty, reset to idle mode\n                if len(self.current_annotation.polygon) == 0:\n                    self.current_annotation = None\n                    self.mouse_mode = MouseMode.IDLE\n\n            # If not drawing a polygon, go to idle mode\n            if not self.current_annotation:\n                self.mouse_mode = MouseMode.IDLE\n                for ann in self.annotations:\n                    ann.selected = False\n                    self.annotationUpdated.emit(ann)\n            self.update()\n\n        # If left-clicked\n        if event.button() == Qt.LeftButton:\n            self.selected_annotation, self.active_handle = (\n                self.find_annotation_and_handle_at(img_pos)\n            )\n            # Handle dragging later on\n            if self.selected_annotation:\n                self.drag_offset = img_pos - self.get_annotation_position(\n                    self.selected_annotation\n                )\n                self.selected_annotation.selected = True\n\n                # Make all other annotations unselected\n                for ann in self.annotations:\n                    if ann != self.selected_annotation:\n                        ann.selected = False\n                    self.annotationUpdated.emit(ann)\n\n                if self.selected_annotation.rectangle:\n                    self.initial_rect = QRectF(self.selected_annotation.rectangle)\n                elif self.selected_annotation.polygon:\n                    self.initial_polygon = QPolygonF(self.selected_annotation.polygon)\n                    if \"point_\" in self.active_handle:\n                        self.active_point_index = int(self.active_handle.split(\"_\")[1])\n                elif self.selected_annotation.points:\n                    self.active_point_index = 0\n\n            # If pan mode\n            if self.mouse_mode == MouseMode.PAN:\n                self.pan_start = event.position()\n                return\n\n            # If drawing mode\n            if self.mouse_mode == MouseMode.POINT:\n                self.current_annotation = Annotation(\n                    label=self.current_label,\n                    annotation_id=len(self.annotations),\n                    points=[clamped_pos],\n                )\n                self.finalize_annotation()\n            elif self.mouse_mode == MouseMode.RECTANGLE:\n                # The incomplete annotation\n                self.current_annotation = Annotation(\n                    file_path=self.file_path,\n                    annotation_id=len(self.annotations),\n                    label=\"Incomplete\",\n                    color=self.current_color,\n                    rectangle=QRectF(clamped_pos, clamped_pos),\n                )\n                self.drag_start = clamped_pos\n            elif self.mouse_mode == MouseMode.POLYGON:\n                # If not double-click\n                if not self.current_annotation:\n                    # if this point is equal to the last point of the previous polygon, then ignore it\n                    if len(self.annotations) &gt; 0:\n                        last_polygon = self.annotations[-1].polygon\n                        if last_polygon:\n                            last_point = last_polygon[-1]\n                            if last_point== clamped_pos:\n                                logger.info(\"Ignoring point, same as last polygon point\")\n                                return\n\n                    self.current_annotation = Annotation(\n                        file_path=self.file_path,\n                        annotation_id=len(self.annotations),\n                        label=\"Incomplete\",\n                        color=self.current_color,\n                        polygon=QPolygonF([clamped_pos]),\n                    )\n                else:\n                    logger.info(f\"Adding point to polygon: {clamped_pos}\")\n                    # Add point to polygon\n                    self.current_annotation.polygon.append(clamped_pos)\n\n            self.update()\n\n    def get_annotation_position(self, annotation: Annotation):\n        if annotation.rectangle:\n            return annotation.rectangle.center()\n        elif annotation.polygon:\n            return annotation.polygon.boundingRect().center()\n        elif annotation.points:\n            return annotation.points[0]\n        return QPointF()\n\n    def find_annotation_and_handle_at(self, pos: QPointF, margin=10.0):\n        \"\"\"Find annotation and specific handle at given position\"\"\"\n        for annotation in reversed(self.annotations):\n            if not annotation.visible or not annotation.is_complete:\n                continue\n\n            # Check rectangle handles\n            if annotation.rectangle:\n                rect = annotation.rectangle\n                handles = {\n                    \"top_left\": rect.topLeft(),\n                    \"top_right\": rect.topRight(),\n                    \"bottom_left\": rect.bottomLeft(),\n                    \"bottom_right\": rect.bottomRight(),\n                    \"top_center\": QPointF(rect.center().x(), rect.top()),\n                    \"bottom_center\": QPointF(rect.center().x(), rect.bottom()),\n                    \"left_center\": QPointF(rect.left(), rect.center().y()),\n                    \"right_center\": QPointF(rect.right(), rect.center().y()),\n                }\n\n                for handle_name, handle_pos in handles.items():\n                    if (handle_pos - pos).manhattanLength() &lt; margin:\n                        return annotation, handle_name\n\n                if rect.contains(pos):\n                    return annotation, \"move\"\n\n            # Check polygon points\n            elif annotation.polygon:\n                for i, point in enumerate(annotation.polygon):\n                    if (point - pos).manhattanLength() &lt; margin:\n                        return annotation, f\"point_{i}\"\n\n                if annotation.polygon.containsPoint(pos, Qt.OddEvenFill):\n                    return annotation, \"move\"\n\n            # Check points\n            elif annotation.points:\n                if (annotation.points[0] - pos).manhattanLength() &lt; margin:\n                    return annotation, \"point_0\"\n\n        return None, None\n\n    def handle_mouse_double_click(self, event: QMouseEvent, pos: QPoint):\n        pos = event.position()\n        for rect, annotation in self.label_rects:\n            if rect.contains(pos):\n                self.edit_annotation_label(annotation)\n                break\n        # if left double click\n        if event.button() == Qt.LeftButton:\n            img_pos = self.widget_to_image_pos(event.position())\n\n            self.selected_annotation, self.active_handle = (\n                self.find_annotation_and_handle_at(img_pos)\n            )\n\n            if self.selected_annotation:\n                if self.selected_annotation.polygon and self.active_handle:\n                    if \"point_\" in self.active_handle:\n                        index = int(self.active_handle.split(\"_\")[1])\n                        # Remove the point at the clicked index\n                        polygon = self.selected_annotation.polygon\n                        polygon = QPolygonF(\n                            [p for i, p in enumerate(polygon) if i != index]\n                        )\n\n                        self.selected_annotation.polygon = polygon\n                        self.annotationUpdated.emit(self.selected_annotation)\n                        self.update()\n                        logger.info(f\"Removed point at index {index}\")\n                        return\n\n                # Check if an edge was double-clicked\n                polygon = self.selected_annotation.polygon\n                if polygon:\n                    for i in range(len(polygon)):\n                        start_point = polygon[i]\n                        end_point = polygon[\n                            (i + 1) % len(polygon)\n                        ]  # Wrap around to the first point\n\n                        # Calculate the vector along the edge and the vector from the start point to the clicked position\n                        line_vector = end_point - start_point\n                        point_vector = img_pos - start_point\n\n                        # Calculate the length of the edge\n                        line_length_squared = (\n                            line_vector.x() ** 2 + line_vector.y() ** 2\n                        )\n                        if line_length_squared == 0:\n                            continue  # Avoid division by zero for degenerate edges\n\n                        # Project the point onto the line (normalized)\n                        projection = (\n                            point_vector.x() * line_vector.x()\n                            + point_vector.y() * line_vector.y()\n                        ) / line_length_squared\n\n                        # Clamp the projection to the range [0, 1] to ensure it lies on the segment\n                        projection = max(0, min(1, projection))\n\n                        # Calculate the projection point on the edge\n                        projection_point = start_point + projection * line_vector\n\n                        # Calculate the perpendicular distance from the clicked position to the edge\n                        perpendicular_distance = (\n                            img_pos - projection_point\n                        ).manhattanLength()\n\n                        # Check if the perpendicular distance is within the margin\n                        if perpendicular_distance &lt; 10:  # Margin of 10\n                            # Insert a new point at the projection point\n                            polygon.insert(i + 1, projection_point)\n                            self.annotationUpdated.emit(self.selected_annotation)\n                            self.update()\n                            return\n\n            # if drawing a polygon, close the polygon\n            if (\n                self.current_annotation\n                and self.mouse_mode == MouseMode.POLYGON\n                and len(self.current_annotation.polygon) &gt;= 3\n            ):\n                self.current_annotation.is_complete = True\n\n                self.finalize_annotation()\n                self.current_annotation = None\n\n                return\n\n            # did we click on an annotation?\n            # annotation = self.find_annotation_at(self.widget_to_image_pos(pos))\n            # if annotation:\n            #     # toggle selection\n            #     annotation.selected = not annotation.selected\n\n            #     # make all other annotations unselected\n            #     for ann in self.annotations:\n            #         if ann != annotation:\n            #             ann.selected = False\n            # else:\n            #     # we clicked on the background\n            #     # make all annotations unselected\n            #     for ann in self.annotations:\n            #         ann.selected = False\n            # update the view\n            for ann in self.annotations:\n                self.annotationUpdated.emit(ann)\n            self.update()\n\n    def find_annotation_at(self, pos: QPointF):\n        for ann in reversed(self.annotations):\n            if ann.rectangle and ann.rectangle.contains(pos):\n                return ann\n            elif ann.polygon and ann.polygon.containsPoint(pos, Qt.OddEvenFill):\n                return ann\n            elif ann.points:\n                for p in ann.points:\n                    if QLineF(pos, p).length() &lt; 5:\n                        return ann\n        return None\n\n    def edit_annotation_label(self, annotation: Annotation):\n        new_label, ok = QInputDialog.getText(\n            self, \"Edit Label\", \"Enter new label:\", text=annotation.label\n        )\n        if ok and new_label:\n            self.labelUpdated.emit((annotation.label, new_label))\n            annotation.label = new_label\n            self.annotationUpdated.emit(annotation)  # Emit signal\n            self.update()\n\n    def finalize_annotation(self):\n        if self.current_label:\n            # Use predefined label\n            self.current_annotation.annotation_id = len(self.annotations)\n            self.current_annotation.label = self.current_label\n            self.current_annotation.color = self.current_color\n            self.current_annotation.is_complete = True\n            self.annotations.append(self.current_annotation)\n\n            self.thumbnails[self.current_annotation.annotation_id] = self.get_thumbnail(\n                self.current_annotation\n            )\n            self.annotationAdded.emit(self.current_annotation)\n        else:\n            # Show custom label dialog\n            label, ok = QInputDialog.getText(self, \"Label\", \"Enter label name:\")\n            if ok:\n                if self.current_annotation:\n                    self.current_annotation.annotation_id = len(self.annotations)\n                    self.current_annotation.label = label or \"Unlabeled\"\n                    self.current_annotation.is_complete = True\n                    self.annotations.append(self.current_annotation)\n                    self.thumbnails[self.current_annotation.annotation_id] = (\n                        self.get_thumbnail(self.current_annotation)\n                    )\n                    self.annotationAdded.emit(self.current_annotation)\n                    self.current_annotation.annotation_id = len(self.annotations)\n        self.current_annotation = None\n        self.update()\n\n    # in update, update cursor\n\n    def _copy_annotation(self):\n        self.selected_annotation = self._get_selected_annotation()\n        if self.selected_annotation:\n            self.copied_annotation = self.selected_annotation\n            self.messageSignal.emit(\n                f\"Copied annotation: {self.selected_annotation.label}\"\n            )\n            self.mouse_mode = MouseMode.IDLE\n        else:\n            self.messageSignal.emit(\"No annotation selected to copy.\")\n\n    def _paste_annotation(self):\n        if self.copied_annotation:\n            new_annotation = self.copied_annotation.copy()\n            new_annotation.annotation_id = len(self.annotations)\n            self.annotations.append(new_annotation)\n            self.annotationAdded.emit(new_annotation)\n            self.thumbnails[new_annotation.annotation_id] = self.get_thumbnail(\n                new_annotation\n            )\n            self.messageSignal.emit(f\"Annotation {new_annotation.label} pasted\")\n            self.update()\n        else:\n            self.messageSignal.emit(\"No annotation copied to paste.\")\n\n    def _get_selected_annotation(self):\n        for annotation in self.annotations:\n            if annotation.selected:\n                return annotation\n\n    def layerify_annotation(self, annotations: list[Annotation]):\n        annotations = [ann for ann in annotations if ann.visible]\n\n        if len(annotations) == 0:\n            QMessageBox.information(\n                self.parentWidget(), \"Info\", \"No visible annotations to layerify\"\n            )\n            return\n        # Create and configure loading dialog\n        self.loading_dialog = QProgressDialog(\n            \"Processing annotation...\",\n            \"Cancel\",  # Optional cancel button\n            0,\n            0,\n            self.parentWidget(),\n        )\n        self.loading_dialog.setWindowTitle(\"Please Wait\")\n        self.loading_dialog.setWindowModality(Qt.WindowModal)\n        # self.loading_dialog.setCancelButton()\n        self.loading_dialog.show()\n\n        # Force UI update\n        QApplication.processEvents()\n\n        # Setup worker thread\n        self.worker_thread = QThread()\n        self.worker = LayerifyWorker(self.image, annotations, self.config)\n        self.worker.moveToThread(self.worker_thread)\n\n        # Connect signals\n        self.worker_thread.started.connect(self.worker.process)\n        self.worker.finished.connect(self.handle_layerify_result)\n        self.worker.finished.connect(self.worker_thread.quit)\n        self.worker.error.connect(self.handle_layerify_error)\n\n        # Cleanup connections\n        self.worker.finished.connect(self.worker.deleteLater)\n        self.worker_thread.finished.connect(self.worker_thread.deleteLater)\n        self.worker_thread.finished.connect(self.loading_dialog.close)\n\n        # Start processing\n        self.worker_thread.start()\n\n    def handle_layerify_result(self, annotation: Annotation, cropped_image: QPixmap):\n        # Create new canvas with results\n        new_layer = CanvasLayer(parent=self.parent_obj, config=self.canvas_config)\n        # get top left corner of the annotation\n\n        new_layer.set_image(cropped_image)\n        new_layer.annotations = [annotation]\n        new_layer.layer_name = (\n            f\"{annotation.label} {annotation.annotation_id} {annotation.annotator}\"\n        )\n\n        new_layer._apply_edge_opacity()\n        new_layer.update()\n        self.messageSignal.emit(f\"Layerified: {new_layer.layer_name}\")\n        logger.info(f\"Num annotations: {len(self.annotations)}\")\n\n        self.layerSignal.emit(new_layer)\n\n    def handle_layerify_error(self, error_msg: str):\n        self.loading_dialog.close()\n        QMessageBox.critical(\n            self.parentWidget(), \"Error\", f\"Processing failed: {error_msg}\"\n        )\n\n    @property\n    def selected_annotation_index(self):\n        for idx, annotation in enumerate(self.annotations):\n            if annotation.selected:\n                return idx\n        return -1\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.annotable_layer.AnnotableLayer.apply_opacity","title":"<code>apply_opacity()</code>","text":"<p>Apply opacity to the QPixmap image.</p> Source code in <code>imagebaker/layers/annotable_layer.py</code> <pre><code>def apply_opacity(self):\n    \"\"\"Apply opacity to the QPixmap image.\"\"\"\n    if self.image and self.opacity &lt; 255:\n        # Create a new transparent pixmap with the same size\n        transparent_pixmap = QPixmap(self.image.size())\n        transparent_pixmap.fill(Qt.transparent)\n\n        # Create a painter to draw on the new pixmap\n        painter = QPainter(transparent_pixmap)\n        try:\n            # Set the opacity\n            painter.setOpacity(self.opacity / 255.0)\n\n            # Draw the original image onto the new pixmap\n            painter.drawPixmap(0, 0, self.image)\n        finally:\n            # Ensure the painter is properly ended\n            painter.end()\n\n        # Replace the original image with the transparent version\n        self.image = transparent_pixmap\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.annotable_layer.AnnotableLayer.draw_annotation","title":"<code>draw_annotation(painter, annotation, is_temp=False)</code>","text":"<p>Draw annotation on the image.</p> Source code in <code>imagebaker/layers/annotable_layer.py</code> <pre><code>def draw_annotation(self, painter, annotation: Annotation, is_temp=False):\n    \"\"\"\n    Draw annotation on the image.\n    \"\"\"\n    if not annotation.visible:\n        return\n    painter.save()\n    base_color = annotation.color\n    pen_color = QColor(\n        base_color.red(),\n        base_color.green(),\n        base_color.blue(),\n        self.config.normal_draw_config.pen_alpha,\n    )\n    brush_color = QColor(\n        base_color.red(),\n        base_color.green(),\n        base_color.blue(),\n        self.config.normal_draw_config.brush_alpha,\n    )\n\n    pen = QPen(pen_color, self.config.normal_draw_config.line_width / self.scale)\n    brush = QBrush(brush_color, Qt.DiagCrossPattern)\n\n    if annotation.selected:\n        painter.setPen(\n            QPen(\n                self.config.selected_draw_config.color,\n                self.config.selected_draw_config.line_width / self.scale,\n            )\n        )\n        painter.setBrush(\n            QBrush(\n                QColor(\n                    self.config.selected_draw_config.color.red(),\n                    self.config.selected_draw_config.color.green(),\n                    self.config.selected_draw_config.color.blue(),\n                    self.config.selected_draw_config.brush_alpha,\n                )\n            )\n        )\n        if annotation.rectangle:\n            painter.drawRect(annotation.rectangle)\n        elif annotation.polygon:\n            painter.drawPolygon(annotation.polygon)\n        elif annotation.points:\n            painter.drawEllipse(\n                annotation.points[0],\n                self.config.selected_draw_config.ellipse_size / self.scale,\n                self.config.selected_draw_config.ellipse_size / self.scale,\n            )\n\n    if is_temp:\n        pen.setStyle(Qt.DashLine)\n        brush.setStyle(Qt.Dense4Pattern)\n\n    painter.setPen(pen)\n    painter.setBrush(brush)\n\n    # Draw main shape\n    if annotation.points:\n        for point in annotation.points:\n            painter.drawEllipse(\n                point,\n                self.config.normal_draw_config.point_size / self.scale,\n                self.config.normal_draw_config.point_size / self.scale,\n            )\n    elif annotation.rectangle:\n        painter.drawRect(annotation.rectangle)\n    elif annotation.polygon:\n        if len(annotation.polygon) &gt; 1:\n            if annotation.is_complete:\n                painter.drawPolygon(annotation.polygon)\n            else:\n                painter.drawPolyline(annotation.polygon)\n\n    # Draw control points\n    if annotation.rectangle:\n        rect = annotation.rectangle\n        corners = [\n            rect.topLeft(),\n            rect.topRight(),\n            rect.bottomLeft(),\n            rect.bottomRight(),\n        ]\n        painter.save()\n        painter.setPen(\n            QPen(\n                Qt.black,\n                self.config.normal_draw_config.control_point_size / self.scale,\n            )\n        )\n        painter.setBrush(QBrush(Qt.white))\n        for corner in corners:\n            painter.drawEllipse(\n                corner,\n                self.config.normal_draw_config.point_size / self.scale,\n                self.config.normal_draw_config.point_size / self.scale,\n            )\n        painter.restore()\n\n    if annotation.polygon and len(annotation.polygon) &gt; 0:\n        painter.save()\n        painter.setPen(\n            QPen(\n                Qt.white,\n                self.config.normal_draw_config.control_point_size / self.scale,\n            )\n        )\n        painter.setBrush(QBrush(Qt.darkGray))\n        for point in annotation.polygon:\n            painter.drawEllipse(\n                point,\n                self.config.normal_draw_config.point_size / self.scale,\n                self.config.normal_draw_config.point_size / self.scale,\n            )\n        painter.restore()\n\n    # Draw labels\n    if annotation.is_complete and annotation.label:\n        painter.save()\n        label_pos = self.get_label_position(annotation)\n        text = annotation.label\n\n        # Convert to widget coordinates\n        widget_pos = QPointF(\n            label_pos.x() * self.scale + self.offset.x(),\n            label_pos.y() * self.scale + self.offset.y(),\n        )\n\n        if annotation.points:\n            widget_pos += QPointF(10, 10)\n\n        # Set up font\n        font = painter.font()\n        font.setPixelSize(\n            self.config.normal_draw_config.label_font_size * self.scale\n        )  # Fixed screen size\n        painter.setFont(font)\n\n        # Calculate text size\n        metrics = painter.fontMetrics()\n        text_width = metrics.horizontalAdvance(text)\n        text_height = metrics.height()\n\n        # Draw background\n        bg_rect = QRectF(\n            widget_pos.x() - text_width / 2 - 2,\n            widget_pos.y() - text_height / 2 - 2,\n            text_width + 4,\n            text_height + 4,\n        )\n        painter.resetTransform()\n        painter.setBrush(self.config.normal_draw_config.label_font_background_color)\n        painter.setPen(Qt.NoPen)\n        painter.drawRect(bg_rect)\n\n        # Draw text\n        painter.setPen(Qt.white)\n        painter.drawText(bg_rect, Qt.AlignCenter, text)\n        painter.restore()\n        self.label_rects.append((bg_rect, annotation))\n\n    painter.restore()\n\n    # Draw transformation handles for selected annotations\n    if annotation.selected and annotation.is_complete:\n        painter.save()\n        handle_color = self.config.selected_draw_config.handle_color\n        painter.setPen(\n            QPen(\n                handle_color,\n                self.config.selected_draw_config.handle_width / self.scale,\n            )\n        )\n        painter.setBrush(QBrush(handle_color))\n\n        if annotation.rectangle:\n            rect = annotation.rectangle\n            # Draw corner handles\n            for corner in [\n                rect.topLeft(),\n                rect.topRight(),\n                rect.bottomLeft(),\n                rect.bottomRight(),\n            ]:\n                painter.drawEllipse(\n                    corner,\n                    self.config.selected_draw_config.handle_point_size / self.scale,\n                    self.config.selected_draw_config.handle_point_size / self.scale,\n                )\n            # Draw edge handles\n            for edge in [\n                QPointF(rect.center().x(), rect.top()),\n                QPointF(rect.center().x(), rect.bottom()),\n                QPointF(rect.left(), rect.center().y()),\n                QPointF(rect.right(), rect.center().y()),\n            ]:\n                painter.drawEllipse(\n                    edge,\n                    self.config.selected_draw_config.handle_edge_size / self.scale,\n                    self.config.selected_draw_config.handle_edge_size / self.scale,\n                )\n\n        elif annotation.polygon:\n            # Draw vertex handles\n            for point in annotation.polygon:\n                painter.drawEllipse(\n                    point,\n                    self.config.selected_draw_config.handle_point_size / self.scale,\n                    self.config.selected_draw_config.handle_point_size / self.scale,\n                )\n\n        painter.restore()\n</code></pre>"},{"location":"api-reference/#imagebaker.layers.annotable_layer.AnnotableLayer.find_annotation_and_handle_at","title":"<code>find_annotation_and_handle_at(pos, margin=10.0)</code>","text":"<p>Find annotation and specific handle at given position</p> Source code in <code>imagebaker/layers/annotable_layer.py</code> <pre><code>def find_annotation_and_handle_at(self, pos: QPointF, margin=10.0):\n    \"\"\"Find annotation and specific handle at given position\"\"\"\n    for annotation in reversed(self.annotations):\n        if not annotation.visible or not annotation.is_complete:\n            continue\n\n        # Check rectangle handles\n        if annotation.rectangle:\n            rect = annotation.rectangle\n            handles = {\n                \"top_left\": rect.topLeft(),\n                \"top_right\": rect.topRight(),\n                \"bottom_left\": rect.bottomLeft(),\n                \"bottom_right\": rect.bottomRight(),\n                \"top_center\": QPointF(rect.center().x(), rect.top()),\n                \"bottom_center\": QPointF(rect.center().x(), rect.bottom()),\n                \"left_center\": QPointF(rect.left(), rect.center().y()),\n                \"right_center\": QPointF(rect.right(), rect.center().y()),\n            }\n\n            for handle_name, handle_pos in handles.items():\n                if (handle_pos - pos).manhattanLength() &lt; margin:\n                    return annotation, handle_name\n\n            if rect.contains(pos):\n                return annotation, \"move\"\n\n        # Check polygon points\n        elif annotation.polygon:\n            for i, point in enumerate(annotation.polygon):\n                if (point - pos).manhattanLength() &lt; margin:\n                    return annotation, f\"point_{i}\"\n\n            if annotation.polygon.containsPoint(pos, Qt.OddEvenFill):\n                return annotation, \"move\"\n\n        # Check points\n        elif annotation.points:\n            if (annotation.points[0] - pos).manhattanLength() &lt; margin:\n                return annotation, \"point_0\"\n\n    return None, None\n</code></pre>"},{"location":"api-reference/#workers","title":"Workers","text":""},{"location":"api-reference/#baker-worker","title":"Baker Worker","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>imagebaker/workers/baker_worker.py</code> <pre><code>class BakerWorker(QObject):\n    finished = Signal(list)  # Emit a list of BakingResult objects\n    error = Signal(str)\n\n    def __init__(\n        self,\n        states: dict[int, list[\"LayerState\"]],\n        layers: list[\"Layer\"],\n        filename: Path,\n    ):\n        \"\"\"\n        Worker to bake the images and masks for a given set of states.\n\n        Args:\n            states: Dictionary of step -&gt; list of LayerState objects\n            layers: List of Layer objects\n            filename: Path to the output file\n        \"\"\"\n        super().__init__()\n        self.states = states  # Dictionary of step -&gt; list of states\n        self.layers = layers\n        self.filename = filename\n\n    def process(self):\n        results = []\n        try:\n            for step, states in sorted(self.states.items()):\n                logger.info(f\"Processing step {step}\")\n\n                # Calculate bounding box for all layers in this step\n                top_left = QPointF(sys.maxsize, sys.maxsize)\n                bottom_right = QPointF(-sys.maxsize, -sys.maxsize)\n\n                # contains all states in currenct step\n                for state in states:\n                    layer = self._get_layer(state.layer_id)\n                    if layer and layer.visible and not layer.image.isNull():\n                        update_opacities = False\n                        logger.debug(\n                            f\"Updating layer {layer.layer_name} with state: {state}\"\n                        )\n\n                        if (\n                            layer.edge_width != state.edge_width\n                            or layer.edge_opacity != state.edge_opacity\n                        ):\n                            update_opacities = True\n                        layer.layer_state = state\n                        if update_opacities:\n                            layer._apply_edge_opacity()\n                        layer.update()\n\n                        transform = QTransform()\n                        transform.translate(layer.position.x(), layer.position.y())\n                        transform.rotate(layer.rotation)\n                        transform.scale(layer.scale_x, layer.scale_y)\n\n                        original_rect = QRectF(QPointF(0, 0), layer.image.size())\n                        transformed_rect = transform.mapRect(original_rect)\n\n                        top_left.setX(min(top_left.x(), transformed_rect.left()))\n                        top_left.setY(min(top_left.y(), transformed_rect.top()))\n                        bottom_right.setX(\n                            max(bottom_right.x(), transformed_rect.right())\n                        )\n                        bottom_right.setY(\n                            max(bottom_right.y(), transformed_rect.bottom())\n                        )\n\n                # Create the output image for this step\n                width = int(bottom_right.x() - top_left.x())\n                height = int(bottom_right.y() - top_left.y())\n                if width &lt;= 0 or height &lt;= 0:\n                    continue\n\n                image = QImage(width, height, QImage.Format_ARGB32)\n                image.fill(Qt.transparent)\n                masks = []\n                mask_names = []\n                new_annotations = []\n\n                painter = QPainter(image)\n                try:\n                    painter.setRenderHints(\n                        QPainter.Antialiasing | QPainter.SmoothPixmapTransform\n                    )\n                    for state in states:\n                        layer = self._get_layer(state.layer_id)\n\n                        if layer and layer.visible and not layer.image.isNull():\n                            # Draw the layer image with transformations\n                            painter.save()\n                            try:\n                                painter.translate(layer.position - top_left)\n                                painter.rotate(layer.rotation)\n                                painter.scale(layer.scale_x, layer.scale_y)\n                                pixmap_with_alpha = QPixmap(layer.image.size())\n                                pixmap_with_alpha.fill(Qt.transparent)\n\n                                temp_painter = QPainter(pixmap_with_alpha)\n                                try:\n                                    opacity = layer.opacity / 255.0\n                                    temp_painter.setOpacity(opacity)\n                                    temp_painter.drawPixmap(0, 0, layer.image)\n                                finally:\n                                    temp_painter.end()\n\n                                painter.drawPixmap(0, 0, pixmap_with_alpha)\n                            finally:\n                                painter.restore()\n\n                            # Draw the drawing states\n                            if state.drawing_states:\n                                painter.save()\n                                try:\n                                    painter.translate(layer.position - top_left)\n                                    painter.rotate(layer.rotation)\n                                    painter.scale(layer.scale_x, layer.scale_y)\n                                    for drawing_state in state.drawing_states:\n                                        painter.setPen(\n                                            QPen(\n                                                drawing_state.color,\n                                                drawing_state.size,\n                                                Qt.SolidLine,\n                                                Qt.RoundCap,\n                                                Qt.RoundJoin,\n                                            )\n                                        )\n                                        painter.drawPoint(\n                                            drawing_state.position - top_left\n                                        )\n                                finally:\n                                    painter.restore()\n\n                            # Generate the layer mask\n                            layer_mask = QImage(width, height, QImage.Format_ARGB32)\n                            layer_mask.fill(Qt.transparent)\n                            mask_painter = QPainter(layer_mask)\n                            try:\n                                mask_painter.setRenderHints(\n                                    QPainter.Antialiasing\n                                    | QPainter.SmoothPixmapTransform\n                                )\n                                mask_painter.translate(layer.position - top_left)\n                                mask_painter.rotate(layer.rotation)\n                                mask_painter.scale(layer.scale_x, layer.scale_y)\n                                mask_painter.drawPixmap(QPoint(0, 0), layer.image)\n\n                                if state.drawing_states:\n                                    mask_painter.save()\n                                    try:\n                                        for drawing_state in state.drawing_states:\n                                            mask_painter.setPen(\n                                                QPen(\n                                                    Qt.black,\n                                                    drawing_state.size,\n                                                    Qt.SolidLine,\n                                                    Qt.RoundCap,\n                                                    Qt.RoundJoin,\n                                                )\n                                            )\n                                            mask_painter.drawPoint(\n                                                drawing_state.position\n                                            )\n                                    finally:\n                                        mask_painter.restore()\n                            finally:\n                                mask_painter.end()\n\n                            # Convert mask to 8-bit\n                            mask_arr = qpixmap_to_numpy(layer_mask)\n                            alpha_channel = mask_arr[:, :, 3].copy()  # Extract alpha\n\n                            # Binarize the mask (0 or 255)\n                            alpha_channel[alpha_channel &gt; 0] = 255\n\n                            masks.append(alpha_channel)\n                            mask_names.append(layer.layer_name)\n\n                            # Generate annotations\n                            if layer.allow_annotation_export:\n                                ann: Annotation = layer.annotations[0]\n                                new_annotation = self._generate_annotation(\n                                    ann, alpha_channel\n                                )\n                                new_annotations.append(new_annotation)\n                finally:\n                    painter.end()\n\n                # Save the image\n                filename = self.filename.parent / f\"{self.filename.stem}_{step}.png\"\n\n                # Append the result\n                results.append(\n                    BakingResult(\n                        filename=filename,\n                        step=step,\n                        image=image,\n                        masks=masks,\n                        mask_names=mask_names,\n                        annotations=new_annotations,\n                    )\n                )\n\n            # Emit all results\n            self.finished.emit(results)\n\n        except Exception as e:\n            import traceback\n\n            logger.error(f\"Error in BakerWorker: {e}\")\n            self.error.emit(str(e))\n            traceback.print_exc()\n\n    def _get_layer(self, layer_id):\n        for layer in self.layers:\n            if layer.layer_id == layer_id:\n                return layer\n        return None\n\n    def _generate_annotation(self, ann: Annotation, alpha_channel):\n        \"\"\"Generate an annotation based on the alpha channel.\"\"\"\n        new_annotation = Annotation(\n            label=ann.label,\n            color=ann.color,\n            annotation_id=ann.annotation_id,\n            is_complete=True,\n            visible=True,\n        )\n\n        if ann.points:\n            new_annotation.points = ann.points\n        elif ann.rectangle:\n            xywhs = mask_to_rectangles(alpha_channel, merge_rectangles=True)\n            if len(xywhs) == 0:\n                logger.info(\"No rectangles found\")\n                # return None\n            else:\n                logger.info(f\"Found {len(xywhs)} rectangles\")\n                new_annotation.rectangle = QRectF(\n                    xywhs[0][0], xywhs[0][1], xywhs[0][2], xywhs[0][3]\n                )\n        elif ann.polygon:\n            polygon = mask_to_polygons(alpha_channel, merge_polygons=True)\n            poly = QPolygonF([QPointF(p[0], p[1]) for p in polygon[0]])\n            new_annotation.polygon = poly\n        else:\n            logger.info(\"No annotation found\")\n        return new_annotation\n</code></pre>"},{"location":"api-reference/#layerify-worker","title":"Layerify Worker","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>imagebaker/workers/layerify_worker.py</code> <pre><code>class LayerifyWorker(QObject):\n    finished = Signal(Annotation, QPixmap)\n    error = Signal(str)\n\n    def __init__(self, image, annotations, config):\n        \"\"\"\n        Worker to layerify an image based on annotations.\n\n        Args:\n            image (QPixmap): Image to layerify.\n            annotations (List[Annotation]): List of annotations to layerify.\n            config (Config): Config object containing settings.\n        \"\"\"\n        super().__init__()\n        self.image = image.copy()\n        self.annotations = annotations\n        self.config = config\n\n    def process(self):\n        try:\n            for annotation in self.annotations:\n                logger.info(f\"Layerifying annotation {annotation}\")\n                if annotation.rectangle:\n                    cropped_image = self.image.copy(annotation.rectangle.toRect())\n                elif annotation.polygon:\n                    # Get bounding box and crop\n                    bounding_rect = annotation.polygon.boundingRect().toRect()\n                    cropped_pixmap = self.image.copy(bounding_rect)\n\n                    # Convert to ARGB32 format to ensure alpha channel support\n                    cropped_image = cropped_pixmap.toImage().convertToFormat(\n                        QImage.Format_ARGB32\n                    )\n\n                    # Create mask with sharp edges\n                    mask = QImage(cropped_image.size(), QImage.Format_ARGB32)\n                    mask.fill(Qt.transparent)\n\n                    # Translate polygon coordinates\n                    translated_poly = annotation.polygon.translated(\n                        -bounding_rect.topLeft()\n                    )\n\n                    # Draw mask without anti-aliasing\n                    painter = QPainter(mask)\n                    painter.setRenderHint(QPainter.Antialiasing, False)\n                    painter.setBrush(QColor(255, 255, 255, 255))  # Opaque white\n                    painter.setPen(Qt.NoPen)\n                    painter.drawPolygon(translated_poly)\n                    painter.end()\n\n                    # Apply mask to image\n                    for y in range(cropped_image.height()):\n                        for x in range(cropped_image.width()):\n                            mask_alpha = mask.pixelColor(x, y).alpha()\n                            color = cropped_image.pixelColor(x, y)\n\n                            # Set alpha to 0 outside polygon, 255 inside\n                            color.setAlpha(255 if mask_alpha &gt; 0 else 0)\n                            cropped_image.setPixelColor(x, y, color)\n\n                    # Convert back to pixmap with proper alpha\n                    cropped_image = QPixmap.fromImage(cropped_image)\n                else:\n                    cropped_image = self.image\n\n                self.finished.emit(annotation, cropped_image)\n\n        except Exception as e:\n            print(e)\n            import traceback\n\n            traceback.print_exc()\n            self.error.emit(str(e))\n</code></pre>"},{"location":"api-reference/#model-prediction-worker","title":"Model Prediction Worker","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>imagebaker/workers/model_worker.py</code> <pre><code>class ModelPredictionWorker(QObject):\n    finished = Signal(list)\n    error = Signal(str)\n\n    def __init__(\n        self,\n        model: BaseModel,\n        image: np.ndarray,\n        points: list[int],\n        polygons: list[list[int]],\n        rectangles: list[list[int]],\n        label_hints: list[int],\n    ):\n        \"\"\"\n        A worker that runs the model prediction in a separate thread.\n\n        Args:\n            model (BaseModel): The model to use for prediction.\n            image (np.ndarray): The image to predict on.\n            points (list[int]): The points to predict on.\n            polygons (list[list[int]]): The polygons to predict on.\n            rectangles (list[list[int]]): The rectangles to predict on.\n            label_hints (list[int]): The label hints to use.\n        \"\"\"\n        super().__init__()\n        self.model = model\n        self.image = image\n        self.points = points\n        self.polygons = polygons\n        self.rectangles = rectangles\n        self.label_hints = label_hints\n\n    def process(self):\n        try:\n            result = self.model.predict(\n                self.image,\n                self.points,\n                self.rectangles,\n                self.polygons,\n                self.label_hints,\n            )\n            self.finished.emit(result)\n        except Exception as e:\n            self.error.emit(str(e))\n            traceback.print_exc()\n            logger.error(f\"Model error: {e}\")\n            return\n</code></pre>"},{"location":"api-reference/#utilities","title":"Utilities","text":""},{"location":"api-reference/#image-utilities","title":"Image Utilities","text":""},{"location":"api-reference/#imagebaker.utils.image.draw_annotations","title":"<code>draw_annotations(image, annotations)</code>","text":"<p>Draw annotations on an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>Image to draw on.</p> required <code>annotations</code> <code>list[Annotation]</code> <p>List of annotations to draw.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Image with annotations drawn.</p> Source code in <code>imagebaker/utils/image.py</code> <pre><code>def draw_annotations(image: np.ndarray, annotations: list[Annotation]) -&gt; np.ndarray:\n    \"\"\"\n    Draw annotations on an image.\n\n    Args:\n        image (np.ndarray): Image to draw on.\n        annotations (list[Annotation]): List of annotations to draw.\n\n    Returns:\n        np.ndarray: Image with annotations drawn.\n    \"\"\"\n    color = (0, 255, 0, 255) if image.shape[2] == 4 else (0, 255, 0)\n\n    for i, ann in enumerate(annotations):\n        if ann.rectangle:\n            # if image has alpha channel, make color full alpha\n            cv2.rectangle(\n                image,\n                (int(ann.rectangle.x()), int(ann.rectangle.y())),\n                (\n                    int(ann.rectangle.x() + ann.rectangle.width()),\n                    int(ann.rectangle.y() + ann.rectangle.height()),\n                ),\n                color,\n                2,\n            )\n            rect_center = ann.rectangle.center()\n\n            cv2.putText(\n                image,\n                ann.label,\n                (int(rect_center.x()), int(rect_center.y())),\n                cv2.FONT_HERSHEY_SIMPLEX,\n                1,\n                color,\n                2,\n            )\n        elif ann.polygon:\n            cv2.polylines(\n                image,\n                [np.array([[int(p.x()), int(p.y())] for p in ann.polygon])],\n                True,\n                color,\n                2,\n            )\n            polygon_center = ann.polygon.boundingRect().center()\n            cv2.putText(\n                image,\n                ann.label,\n                (int(polygon_center.x()), int(polygon_center.y())),\n                cv2.FONT_HERSHEY_SIMPLEX,\n                1,\n                color,\n                2,\n            )\n        elif ann.points:\n            for p in ann.points:\n                cv2.circle(image, (int(p.x()), int(p.y())), 5, color, -1)\n            cv2.putText(\n                image,\n                ann.label,\n                (int(ann.points[0].x()), int(ann.points[0].y())),\n                cv2.FONT_HERSHEY_SIMPLEX,\n                1,\n                color,\n                2,\n            )\n    return image\n</code></pre>"},{"location":"api-reference/#imagebaker.utils.image.qpixmap_to_numpy","title":"<code>qpixmap_to_numpy(pixmap)</code>","text":"<p>Convert QPixmap to RGBA numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>pixmap</code> <code>QPixmap | QImage</code> <p>The QPixmap to convert</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Array with shape (height, width, 4) containing RGBA values</p> Source code in <code>imagebaker/utils/image.py</code> <pre><code>def qpixmap_to_numpy(pixmap: QPixmap | QImage) -&gt; np.ndarray:\n    \"\"\"\n    Convert QPixmap to RGBA numpy array.\n\n    Args:\n        pixmap: The QPixmap to convert\n\n    Returns:\n        numpy.ndarray: Array with shape (height, width, 4) containing RGBA values\n    \"\"\"\n\n    if isinstance(pixmap, QPixmap):\n        # Convert QPixmap to QImage first\n        image = pixmap.toImage()\n    else:\n        image = pixmap\n    # Convert to Format_RGBA8888 for consistent channel ordering\n    if image.format() != QImage.Format_RGBA8888:\n        image = image.convertToFormat(QImage.Format_RGBA8888)\n\n    width = image.width()\n    height = image.height()\n\n    # Get the bytes directly from the QImage\n    ptr = image.constBits()\n\n    # Convert memoryview to bytes and then to numpy array\n    bytes_data = bytes(ptr)\n    arr = np.frombuffer(bytes_data, dtype=np.uint8).reshape((height, width, 4))\n\n    return arr\n</code></pre>"},{"location":"api-reference/#state-utilities","title":"State Utilities","text":""},{"location":"api-reference/#imagebaker.utils.state_utils.calculate_intermediate_states","title":"<code>calculate_intermediate_states(previous_state, current_state, steps)</code>","text":"<p>Calculate intermediate states between previous_state and current_state for a layer. Append the current_state to the list of states after calculating intermediates.</p> <p>Parameters:</p> Name Type Description Default <code>previous_state</code> <code>LayerState</code> <p>Previous state of the layer.</p> required <code>current_state</code> <code>LayerState</code> <p>Current state of the layer.</p> required <code>steps</code> <code>int</code> <p>Number of intermediate states to calculate.</p> required Source code in <code>imagebaker/utils/state_utils.py</code> <pre><code>def calculate_intermediate_states(\n    previous_state: LayerState | None, current_state: LayerState | None, steps: int\n):\n    \"\"\"\n    Calculate intermediate states between previous_state and current_state for a layer.\n    Append the current_state to the list of states after calculating intermediates.\n\n    Args:\n        previous_state (LayerState): Previous state of the layer.\n        current_state (LayerState): Current state of the layer.\n        steps (int): Number of intermediate states to calculate.\n    \"\"\"\n    if not previous_state or not current_state:\n        return [current_state]  # If no previous state, return only the current state\n\n    intermediate_states = []\n    for i in range(1, steps + 1):\n        # Interpolate attributes between previous_state and current_state\n        interpolated_state = LayerState(\n            layer_id=current_state.layer_id,\n            layer_name=current_state.layer_name,\n            opacity=previous_state.opacity\n            + (current_state.opacity - previous_state.opacity) * (i / steps),\n            position=QPointF(\n                previous_state.position.x()\n                + (current_state.position.x() - previous_state.position.x())\n                * (i / steps),\n                previous_state.position.y()\n                + (current_state.position.y() - previous_state.position.y())\n                * (i / steps),\n            ),\n            rotation=previous_state.rotation\n            + (current_state.rotation - previous_state.rotation) * (i / steps),\n            scale=previous_state.scale\n            + (current_state.scale - previous_state.scale) * (i / steps),\n            scale_x=previous_state.scale_x\n            + (current_state.scale_x - previous_state.scale_x) * (i / steps),\n            scale_y=previous_state.scale_y\n            + (current_state.scale_y - previous_state.scale_y) * (i / steps),\n            transform_origin=QPointF(\n                previous_state.transform_origin.x()\n                + (\n                    current_state.transform_origin.x()\n                    - previous_state.transform_origin.x()\n                )\n                * (i / steps),\n                previous_state.transform_origin.y()\n                + (\n                    current_state.transform_origin.y()\n                    - previous_state.transform_origin.y()\n                )\n                * (i / steps),\n            ),\n            order=current_state.order,\n            visible=current_state.visible,\n            allow_annotation_export=current_state.allow_annotation_export,\n            playing=current_state.playing,\n            selected=False,\n            is_annotable=current_state.is_annotable,\n            status=current_state.status,\n            edge_opacity=previous_state.edge_opacity\n            + (current_state.edge_opacity - previous_state.edge_opacity) * (i / steps),\n            edge_width=previous_state.edge_width\n            + (current_state.edge_width - previous_state.edge_width) * (i / steps),\n        )\n\n        # Deep copy the drawing_states from the previous_state\n        interpolated_state.drawing_states = [\n            DrawingState(\n                position=d.position,\n                color=d.color,\n                size=d.size,\n            )\n            for d in current_state.drawing_states\n        ]\n\n        intermediate_states.append(interpolated_state)\n\n    # Append the current state as the final state\n    current_state.drawing_states.extend(\n        [\n            DrawingState(\n                position=d.position,\n                color=d.color,\n                size=d.size,\n            )\n            for d in current_state.drawing_states\n        ]\n    )\n    intermediate_states.append(current_state)\n\n    return intermediate_states\n</code></pre>"},{"location":"api-reference/#transform-mask-utilities","title":"Transform Mask Utilities","text":""},{"location":"api-reference/#imagebaker.utils.transform_mask.mask_to_polygons","title":"<code>mask_to_polygons(mask, min_polygon_area=10, merge_polygons=False, merge_distance=5)</code>","text":"<p>Convert a binary mask to a list of polygons. Each polygon is a list of (x, y) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>Binary mask (0 or 255).</p> required <code>min_polygon_area</code> <code>float</code> <p>Minimum area for a polygon to be included.</p> <code>10</code> <code>merge_polygons</code> <code>bool</code> <p>If True, merges nearby/overlapping polygons.</p> <code>False</code> <code>merge_distance</code> <code>int</code> <p>Max distance between polygons to merge (if merge_polygons=True).</p> <code>5</code> <p>Returns:</p> Type Description <code>List[List[Tuple[int, int]]]</code> <p>List[List[Tuple[int, int]]]: List of polygons, each represented as a list of (x, y) points.</p> Source code in <code>imagebaker/utils/transform_mask.py</code> <pre><code>def mask_to_polygons(\n    mask: np.ndarray,\n    min_polygon_area: float = 10,\n    merge_polygons: bool = False,\n    merge_distance: int = 5,  # Max distance between polygons to merge\n) -&gt; List[List[Tuple[int, int]]]:\n    \"\"\"\n    Convert a binary mask to a list of polygons.\n    Each polygon is a list of (x, y) coordinates.\n\n    Args:\n        mask (np.ndarray): Binary mask (0 or 255).\n        min_polygon_area (float): Minimum area for a polygon to be included.\n        merge_polygons (bool): If True, merges nearby/overlapping polygons.\n        merge_distance (int): Max distance between polygons to merge (if merge_polygons=True).\n\n    Returns:\n        List[List[Tuple[int, int]]]: List of polygons, each represented as a list of (x, y) points.\n    \"\"\"\n    contours, _ = cv2.findContours(\n        mask.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE\n    )\n\n    polygons = []\n    for contour in contours:\n        area = cv2.contourArea(contour)\n        if area &gt;= min_polygon_area:\n            polygons.append(contour)\n\n    # Sort polygons by area (descending)\n    polygons = sorted(\n        polygons, key=lambda p: cv2.contourArea(np.array(p)), reverse=True\n    )\n\n    # Merge polygons if requested\n    if merge_polygons and len(polygons) &gt; 1:\n        # Use morphological dilation to merge nearby regions\n        kernel = np.ones((merge_distance, merge_distance), np.uint8)\n        merged_mask = cv2.dilate(mask, kernel, iterations=1)\n\n        # Re-extract contours after merging\n        merged_contours, _ = cv2.findContours(\n            merged_mask.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE\n        )\n\n        # Filter again by area\n        merged_polygons = []\n        for contour in merged_contours:\n            area = cv2.contourArea(contour)\n            if area &gt;= min_polygon_area:\n                merged_polygons.append(contour)\n\n        polygons = merged_polygons\n\n    # Convert contours to list of points\n    result = []\n    for poly in polygons:\n        points = poly.squeeze().tolist()  # Remove extra dimensions\n        if len(points) &gt;= 3:  # Ensure it's a valid polygon\n            result.append([(int(x), int(y)) for x, y in points])\n\n    return result\n</code></pre>"},{"location":"api-reference/#imagebaker.utils.transform_mask.mask_to_rectangles","title":"<code>mask_to_rectangles(mask, merge_rectangles=False, merge_threshold=1, merge_epsilon=0.5)</code>","text":"<p>Convert a binary mask to a list of rectangles. Each rectangle is a tuple of (x, y, w, h).</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>Binary mask (0 or 255).</p> required <code>merge_rectangles</code> <code>bool</code> <p>If True, merges overlapping or nearby rectangles.</p> <code>False</code> <code>merge_threshold</code> <code>int</code> <p>Min number of rectangles to merge into one.</p> <code>1</code> <code>merge_epsilon</code> <code>float</code> <p>Controls how close rectangles must be to merge (0.0 to 1.0).</p> <code>0.5</code> <p>Returns:</p> Type Description <code>List[Tuple[int, int, int, int]]</code> <p>List[Tuple[int, int, int, int]]: List of rectangles, each as (x, y, w, h).</p> Source code in <code>imagebaker/utils/transform_mask.py</code> <pre><code>def mask_to_rectangles(\n    mask: np.ndarray,\n    merge_rectangles: bool = False,\n    merge_threshold: int = 1,\n    merge_epsilon: float = 0.5,\n) -&gt; List[Tuple[int, int, int, int]]:\n    \"\"\"\n    Convert a binary mask to a list of rectangles.\n    Each rectangle is a tuple of (x, y, w, h).\n\n    Args:\n        mask (np.ndarray): Binary mask (0 or 255).\n        merge_rectangles (bool): If True, merges overlapping or nearby rectangles.\n        merge_threshold (int): Min number of rectangles to merge into one.\n        merge_epsilon (float): Controls how close rectangles must be to merge (0.0 to 1.0).\n\n    Returns:\n        List[Tuple[int, int, int, int]]: List of rectangles, each as (x, y, w, h).\n    \"\"\"\n    contours, _ = cv2.findContours(\n        mask.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE\n    )\n\n    rectangles = []\n    for contour in contours:\n        x, y, w, h = cv2.boundingRect(contour)\n        rectangles.append((x, y, w, h))\n\n    if merge_rectangles and len(rectangles) &gt; 1:\n        # Convert rectangles to the format expected by groupRectangles\n        rects = np.array(rectangles)\n        # groupRectangles requires [x, y, w, h] format\n        grouped_rects, _ = cv2.groupRectangles(\n            rects.tolist(), merge_threshold, merge_epsilon\n        )\n        rectangles = [tuple(map(int, rect)) for rect in grouped_rects]\n\n    return rectangles\n</code></pre>"}]}